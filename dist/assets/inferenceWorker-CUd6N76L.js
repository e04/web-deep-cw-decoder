(function(){"use strict";var __vite_glob_1_0="data:application/octet-stream;base64,aW1wb3J0IHsgQ29udGFpbmVyLCBGbGV4LCBTdGFjaywgVGV4dCB9IGZyb20gIkBtYW50aW5lL2NvcmUiOwppbXBvcnQgeyBEZWNvZGVyIH0gZnJvbSAiLi9EZWNvZGVyIjsKCmZ1bmN0aW9uIEFwcCgpIHsKICByZXR1cm4gKAogICAgPENvbnRhaW5lciBzdHJhdGVneT0iYmxvY2siIHNpemU9ezgwMH0gcD0iOCI+CiAgICAgIDxTdGFjayBnYXA9ezh9PgogICAgICAgIDxTdGFjayBnYXA9ezB9PgogICAgICAgICAgPEZsZXggYWxpZ249ImNlbnRlciIganVzdGlmeT0ic3BhY2UtYmV0d2VlbiI+CiAgICAgICAgICAgIDxUZXh0IHNpemU9InhsIiBmdz17NzAwfT4KICAgICAgICAgICAgICB3ZWItZGVlcC1jdy1kZWNvZGVyCiAgICAgICAgICAgIDwvVGV4dD4KICAgICAgICAgICAgPFRleHQgc2l6ZT0ieHMiIGM9ImRpbW1lZCI+CiAgICAgICAgICAgICAgdjAuMi4wCiAgICAgICAgICAgIDwvVGV4dD4KICAgICAgICAgIDwvRmxleD4KICAgICAgICA8L1N0YWNrPgogICAgICAgIDxEZWNvZGVyIC8+CiAgICAgICAgPEZsZXgganVzdGlmeT0icmlnaHQiPgogICAgICAgICAgPFRleHQgY29tcG9uZW50PSJhIiBjPSJkaW1tZWQiIGhyZWY9Imh0dHBzOi8vZ2l0aHViLmNvbS9lMDQvIj4KICAgICAgICAgICAgQ29weXJpZ2h0IMKpIDIwMjYgZTA0CiAgICAgICAgICA8L1RleHQ+CiAgICAgICAgPC9GbGV4PgogICAgICA8L1N0YWNrPgogICAgPC9Db250YWluZXI+CiAgKTsKfQoKZXhwb3J0IGRlZmF1bHQgQXBwOwo=",__vite_glob_1_1=""+new URL("Decoder-BsVZEppn.tsx",self.location.href).href,__vite_glob_1_2="data:application/octet-stream;base64,aW1wb3J0IHsgdXNlUmVmIH0gZnJvbSAicmVhY3QiOwppbXBvcnQgeyBCb3ggfSBmcm9tICJAbWFudGluZS9jb3JlIjsKaW1wb3J0IHsgdXNlU3BlY3Ryb2dyYW1SZW5kZXJlciB9IGZyb20gIi4vaG9va3MvdXNlU3BlY3Ryb2dyYW1SZW5kZXJlciI7CmltcG9ydCB7IHVzZUNhbnZhc0ludGVyYWN0aW9uIH0gZnJvbSAiLi9ob29rcy91c2VDYW52YXNJbnRlcmFjdGlvbiI7CmltcG9ydCB7IGNhbGN1bGF0ZUJhbmRQb3NpdGlvbiB9IGZyb20gIi4vdXRpbHMvZnJlcXVlbmN5VXRpbHMiOwoKdHlwZSBTY29wZVByb3BzID0gewogIHN0cmVhbTogTWVkaWFTdHJlYW07CiAgc2V0RmlsdGVyRnJlcTogKGZyZXE6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7CiAgZmlsdGVyRnJlcTogbnVtYmVyIHwgbnVsbDsKICBmaWx0ZXJXaWR0aDogbnVtYmVyOwogIGdhaW46IG51bWJlcjsKfTsKCmV4cG9ydCBjb25zdCBTY29wZSA9ICh7CiAgc3RyZWFtLAogIHNldEZpbHRlckZyZXEsCiAgZmlsdGVyRnJlcSwKICBmaWx0ZXJXaWR0aCwKICBnYWluLAp9OiBTY29wZVByb3BzKSA9PiB7CiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbD4obnVsbCk7CgogIHVzZVNwZWN0cm9ncmFtUmVuZGVyZXIoeyBzdHJlYW0sIGdhaW4sIGNhbnZhc1JlZiB9KTsKCiAgdXNlQ2FudmFzSW50ZXJhY3Rpb24oeyBjYW52YXNSZWYsIGZpbHRlckZyZXEsIHNldEZpbHRlckZyZXEsIGZpbHRlcldpZHRoIH0pOwoKICBjb25zdCB7IHRvcFBlcmNlbnQsIGhlaWdodFBlcmNlbnQgfSA9IGNhbGN1bGF0ZUJhbmRQb3NpdGlvbigKICAgIGZpbHRlckZyZXEsCiAgICBmaWx0ZXJXaWR0aAogICk7CgogIHJldHVybiAoCiAgICA8Qm94IHN0eWxlPXt7IHBvc2l0aW9uOiAicmVsYXRpdmUiLCB3aWR0aDogIjEwMCUiIH19PgogICAgICA8Qm94CiAgICAgICAgY29tcG9uZW50PSJjYW52YXMiCiAgICAgICAgcmVmPXtjYW52YXNSZWZ9CiAgICAgICAgc3R5bGU9e3sKICAgICAgICAgIGRpc3BsYXk6ICJibG9jayIsCiAgICAgICAgICBiYWNrZ3JvdW5kOiAidmFyKC0tbWFudGluZS1jb2xvci1kYXJrLTkpIiwKICAgICAgICAgIHdpZHRoOiAiMTAwJSIsCiAgICAgICAgICBoZWlnaHQ6ICIyNTZweCIsCiAgICAgICAgICBib3JkZXJSYWRpdXM6ICI0cHgiLAogICAgICAgICAgYm9yZGVyOiAiMXB4IHNvbGlkIHZhcigtLW1hbnRpbmUtY29sb3ItZGFyay00KSIsCiAgICAgICAgfX0KICAgICAgLz4KICAgICAgPEJveAogICAgICAgIHN0eWxlPXt7CiAgICAgICAgICBwb3NpdGlvbjogImFic29sdXRlIiwKICAgICAgICAgIGxlZnQ6IDAsCiAgICAgICAgICByaWdodDogMCwKICAgICAgICAgIHRvcDogYCR7dG9wUGVyY2VudH0lYCwKICAgICAgICAgIGhlaWdodDogYCR7aGVpZ2h0UGVyY2VudH0lYCwKICAgICAgICAgIGJvcmRlclRvcDogIjFweCBzb2xpZCB2YXIoLS1tYW50aW5lLWNvbG9yLXJlZC03KSIsCiAgICAgICAgICBib3JkZXJCb3R0b206ICIxcHggc29saWQgdmFyKC0tbWFudGluZS1jb2xvci1yZWQtNykiLAogICAgICAgICAgcG9pbnRlckV2ZW50czogIm5vbmUiLAogICAgICAgIH19CiAgICAgIC8+CiAgICA8L0JveD4KICApOwp9Owo=",__vite_glob_1_3="data:video/mp2t;base64,ZXhwb3J0IGNvbnN0IEVOR0xJU0hfQ09ORklHID0gewogIE1PREVMX0ZJTEU6ICJtb2RlbC5vbm54IiwKICBWT0NBQlVMQVJZOiBbCiAgICAiW1VOS10iLAogICAgIi8iLAogICAgIjAiLAogICAgIjEiLAogICAgIjIiLAogICAgIjMiLAogICAgIjQiLAogICAgIjUiLAogICAgIjYiLAogICAgIjciLAogICAgIjgiLAogICAgIjkiLAogICAgIj8iLAogICAgIkEiLAogICAgIkIiLAogICAgIkMiLAogICAgIkQiLAogICAgIkUiLAogICAgIkYiLAogICAgIkciLAogICAgIkgiLAogICAgIkkiLAogICAgIkoiLAogICAgIksiLAogICAgIkwiLAogICAgIk0iLAogICAgIk4iLAogICAgIk8iLAogICAgIlAiLAogICAgIlEiLAogICAgIlIiLAogICAgIlMiLAogICAgIlQiLAogICAgIlUiLAogICAgIlYiLAogICAgIlciLAogICAgIlgiLAogICAgIlkiLAogICAgIloiLAogICAgIu6MsCIsCiAgICAi7oyxIiwKICAgICLujLIiLAogICAgIu6MsyIsCiAgICAi7oy0IiwKICAgICLujLUiLAogICAgIu6MtiIsCiAgICAiICIsCiAgXSwKICBBQkJSRVZJQVRJT046IHsKICAgICLujLAiOiAiQVIiLAogICAgIu6MsSI6ICJCVCIsCiAgICAi7oyyIjogIkhIIiwKICAgICLujLMiOiAiS04iLAogICAgIu6MtCI6ICJTSyIsCiAgICAi7oy1IjogIkJLIiwKICAgICLujLYiOiAiVVIiLAogIH0sCn07CgpleHBvcnQgY29uc3QgSkFQQU5FU0VfQ09ORklHID0gewogIE1PREVMX0ZJTEU6ICJtb2RlbF9qYS5vbm54IiwKICBWT0NBQlVMQVJZOiBbCiAgICAiW1VOS10iLAogICAgIiAiLAogICAgIu+8iSIsCiAgICAiMCIsCiAgICAiMSIsCiAgICAiMiIsCiAgICAiMyIsCiAgICAiNCIsCiAgICAiNSIsCiAgICAiNiIsCiAgICAiNyIsCiAgICAiOCIsCiAgICAiOSIsCiAgICAiPyIsCiAgICAi44CBIiwKICAgICLjgI0iLAogICAgIuOCmyIsCiAgICAi44KcIiwKICAgICLjgqIiLAogICAgIuOCpCIsCiAgICAi44KmIiwKICAgICLjgqgiLAogICAgIuOCqiIsCiAgICAi44KrIiwKICAgICLjgq0iLAogICAgIuOCryIsCiAgICAi44KxIiwKICAgICLjgrMiLAogICAgIuOCtSIsCiAgICAi44K3IiwKICAgICLjgrkiLAogICAgIuOCuyIsCiAgICAi44K9IiwKICAgICLjgr8iLAogICAgIuODgSIsCiAgICAi44OEIiwKICAgICLjg4YiLAogICAgIuODiCIsCiAgICAi44OKIiwKICAgICLjg4siLAogICAgIuODjCIsCiAgICAi44ONIiwKICAgICLjg44iLAogICAgIuODjyIsCiAgICAi44OSIiwKICAgICLjg5UiLAogICAgIuODmCIsCiAgICAi44ObIiwKICAgICLjg54iLAogICAgIuODnyIsCiAgICAi44OgIiwKICAgICLjg6EiLAogICAgIuODoiIsCiAgICAi44OkIiwKICAgICLjg6YiLAogICAgIuODqCIsCiAgICAi44OpIiwKICAgICLjg6oiLAogICAgIuODqyIsCiAgICAi44OsIiwKICAgICLjg60iLAogICAgIuODryIsCiAgICAi44OwIiwKICAgICLjg7EiLAogICAgIuODsiIsCiAgICAi44OzIiwKICAgICLjg7wiLAogICAgIuacrCIsCiAgICAi6KiCIiwKICAgICLvvIgiLAogICAgIiAiLAogIF0sCiAgQUJCUkVWSUFUSU9OOiB7CiAgICAi5pysIjogIu++ju++miIsCiAgICAi6KiCIjogIu++l+++gCIsCiAgfSwKfTsKCmV4cG9ydCBjb25zdCBOdW1Ub0NoYXIgPSBPYmplY3QuZnJvbUVudHJpZXMoCiAgRU5HTElTSF9DT05GSUcuVk9DQUJVTEFSWS5tYXAoKGNoYXIsIGkpID0+IFtpLCBjaGFyXSksCik7CgpleHBvcnQgY29uc3QgRkZUX0xFTkdUSCA9IDI1NjsKZXhwb3J0IGNvbnN0IEhPUF9MRU5HVEggPSA2NDsKZXhwb3J0IGNvbnN0IFNBTVBMRV9SQVRFID0gMzIwMDsKZXhwb3J0IGNvbnN0IEJVRkZFUl9EVVJBVElPTl9TID0gMTI7CmV4cG9ydCBjb25zdCBJTkZFUkVOQ0VfSU5URVJWQUxfUyA9IDAuMjU7CmV4cG9ydCBjb25zdCBCVUZGRVJfU0FNUExFUyA9IEJVRkZFUl9EVVJBVElPTl9TICogU0FNUExFX1JBVEU7CgpleHBvcnQgY29uc3QgTUlOX0ZSRVFfSFogPSAxMDA7CmV4cG9ydCBjb25zdCBNQVhfRlJFUV9IWiA9IDE1MDA7CgpleHBvcnQgY29uc3QgREVDT0RBQkxFX01JTl9GUkVRX0haID0gNDAwOwpleHBvcnQgY29uc3QgREVDT0RBQkxFX01BWF9GUkVRX0haID0gMTIwMDsK",__vite_glob_1_4=""+new URL("global-DiXlIB9t.css",self.location.href).href,__vite_glob_1_5="data:application/octet-stream;base64,aW1wb3J0IHsgU3RyaWN0TW9kZSB9IGZyb20gInJlYWN0IjsKaW1wb3J0IHsgY3JlYXRlUm9vdCB9IGZyb20gInJlYWN0LWRvbS9jbGllbnQiOwppbXBvcnQgQXBwIGZyb20gIi4vQXBwLnRzeCI7CmltcG9ydCAiQG1hbnRpbmUvY29yZS9zdHlsZXMuY3NzIjsKaW1wb3J0ICIuL2dsb2JhbC5jc3MiOwppbXBvcnQgeyBNYW50aW5lUHJvdmlkZXIgfSBmcm9tICJAbWFudGluZS9jb3JlIjsKCmNyZWF0ZVJvb3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoInJvb3QiKSEpLnJlbmRlcigKICA8U3RyaWN0TW9kZT4KICAgIDxNYW50aW5lUHJvdmlkZXIgZGVmYXVsdENvbG9yU2NoZW1lPSJkYXJrIj4KICAgICAgPEFwcCAvPgogICAgPC9NYW50aW5lUHJvdmlkZXI+CiAgPC9TdHJpY3RNb2RlPgopOwo=",__vite_glob_1_6=""+new URL("model-DGBqNjjL.onnx",self.location.href).href,__vite_glob_1_7=""+new URL("model_ja-Dh7kaPzG.onnx",self.location.href).href,__vite_glob_1_8="data:video/mp2t;base64,aW1wb3J0IHR5cGUgKiBhcyBfT3J0IGZyb20gIm9ubnhydW50aW1lLXdlYiI7CgpkZWNsYXJlIGdsb2JhbCB7CiAgY29uc3Qgb3J0OiB0eXBlb2YgX09ydDsKfQoKZXhwb3J0IHt9Owo=",__vite_glob_1_9="data:video/mp2t;base64,ZXhwb3J0IGNsYXNzIEZGVCB7CiAgcHVibGljIHJlYWRvbmx5IGZmdFNpemU6IG51bWJlcjsKICBwcml2YXRlIHJldmVyc2VUYWJsZTogVWludDMyQXJyYXk7CiAgcHJpdmF0ZSBzaW5UYWJsZTogRmxvYXQzMkFycmF5OwogIHByaXZhdGUgY29zVGFibGU6IEZsb2F0MzJBcnJheTsKCiAgY29uc3RydWN0b3IoZmZ0U2l6ZTogbnVtYmVyKSB7CiAgICBpZiAoKGZmdFNpemUgJiAoZmZ0U2l6ZSAtIDEpKSAhPT0gMCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkZGVCBzaXplIG11c3QgYmUgYSBwb3dlciBvZiAyLiIpOwogICAgfQogICAgdGhpcy5mZnRTaXplID0gZmZ0U2l6ZTsKCiAgICB0aGlzLnJldmVyc2VUYWJsZSA9IG5ldyBVaW50MzJBcnJheShmZnRTaXplKTsKICAgIHRoaXMuc2luVGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KGZmdFNpemUpOwogICAgdGhpcy5jb3NUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0U2l6ZSk7CgogICAgbGV0IGxpbWl0ID0gMTsKICAgIGxldCBiaXQgPSBmZnRTaXplID4+IDE7CiAgICB3aGlsZSAobGltaXQgPCBmZnRTaXplKSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkrKykgewogICAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW2kgKyBsaW1pdF0gPSB0aGlzLnJldmVyc2VUYWJsZVtpXSArIGJpdDsKICAgICAgfQogICAgICBsaW1pdCA9IGxpbWl0IDw8IDE7CiAgICAgIGJpdCA9IGJpdCA+PiAxOwogICAgfQoKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmZ0U2l6ZTsgaSsrKSB7CiAgICAgIGNvbnN0IGFuZ2xlID0gKC0yICogTWF0aC5QSSAqIGkpIC8gZmZ0U2l6ZTsKICAgICAgdGhpcy5zaW5UYWJsZVtpXSA9IE1hdGguc2luKGFuZ2xlKTsKICAgICAgdGhpcy5jb3NUYWJsZVtpXSA9IE1hdGguY29zKGFuZ2xlKTsKICAgIH0KICB9CgogIHB1YmxpYyB0cmFuc2Zvcm0oY29tcGxleEFycmF5OiBGbG9hdDMyQXJyYXkpOiB2b2lkIHsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mZnRTaXplOyBpKyspIHsKICAgICAgY29uc3QgcmV2ZXJzZWRJbmRleCA9IHRoaXMucmV2ZXJzZVRhYmxlW2ldOwogICAgICBpZiAoaSA8IHJldmVyc2VkSW5kZXgpIHsKICAgICAgICBbY29tcGxleEFycmF5W2kgKiAyXSwgY29tcGxleEFycmF5W3JldmVyc2VkSW5kZXggKiAyXV0gPSBbCiAgICAgICAgICBjb21wbGV4QXJyYXlbcmV2ZXJzZWRJbmRleCAqIDJdLAogICAgICAgICAgY29tcGxleEFycmF5W2kgKiAyXSwKICAgICAgICBdOwogICAgICAgIFtjb21wbGV4QXJyYXlbaSAqIDIgKyAxXSwgY29tcGxleEFycmF5W3JldmVyc2VkSW5kZXggKiAyICsgMV1dID0gWwogICAgICAgICAgY29tcGxleEFycmF5W3JldmVyc2VkSW5kZXggKiAyICsgMV0sCiAgICAgICAgICBjb21wbGV4QXJyYXlbaSAqIDIgKyAxXSwKICAgICAgICBdOwogICAgICB9CiAgICB9CgogICAgZm9yIChsZXQgaGFsZlNpemUgPSAxOyBoYWxmU2l6ZSA8IHRoaXMuZmZ0U2l6ZTsgaGFsZlNpemUgKj0gMikgewogICAgICBjb25zdCBzdGVwID0gMiAqIGhhbGZTaXplOwogICAgICBjb25zdCBhbmdsZVN0ZXAgPSB0aGlzLmZmdFNpemUgLyBzdGVwOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmZ0U2l6ZTsgaSArPSBzdGVwKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYWxmU2l6ZTsgaisrKSB7CiAgICAgICAgICBjb25zdCBhbmdsZUluZGV4ID0gaiAqIGFuZ2xlU3RlcDsKICAgICAgICAgIGNvbnN0IHdSZWFsID0gdGhpcy5jb3NUYWJsZVthbmdsZUluZGV4XTsKICAgICAgICAgIGNvbnN0IHdJbWFnID0gdGhpcy5zaW5UYWJsZVthbmdsZUluZGV4XTsKCiAgICAgICAgICBjb25zdCBpX2ogPSAoaSArIGopICogMjsKICAgICAgICAgIGNvbnN0IGlfal9oYWxmID0gKGkgKyBqICsgaGFsZlNpemUpICogMjsKCiAgICAgICAgICBjb25zdCB0ciA9CiAgICAgICAgICAgIHdSZWFsICogY29tcGxleEFycmF5W2lfal9oYWxmXSAtIHdJbWFnICogY29tcGxleEFycmF5W2lfal9oYWxmICsgMV07CiAgICAgICAgICBjb25zdCB0aSA9CiAgICAgICAgICAgIHdSZWFsICogY29tcGxleEFycmF5W2lfal9oYWxmICsgMV0gKyB3SW1hZyAqIGNvbXBsZXhBcnJheVtpX2pfaGFsZl07CgogICAgICAgICAgY29uc3QgdXIgPSBjb21wbGV4QXJyYXlbaV9qXTsKICAgICAgICAgIGNvbnN0IHVpID0gY29tcGxleEFycmF5W2lfaiArIDFdOwoKICAgICAgICAgIGNvbXBsZXhBcnJheVtpX2pdID0gdXIgKyB0cjsKICAgICAgICAgIGNvbXBsZXhBcnJheVtpX2ogKyAxXSA9IHVpICsgdGk7CiAgICAgICAgICBjb21wbGV4QXJyYXlbaV9qX2hhbGZdID0gdXIgLSB0cjsKICAgICAgICAgIGNvbXBsZXhBcnJheVtpX2pfaGFsZiArIDFdID0gdWkgLSB0aTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9Cn0KCmV4cG9ydCBjbGFzcyBTVEZUIHsKICBwdWJsaWMgcmVhZG9ubHkgZmZ0U2l6ZTogbnVtYmVyOwogIHB1YmxpYyByZWFkb25seSBob3BTaXplOiBudW1iZXI7CiAgcHJpdmF0ZSBmZnQ6IEZGVDsKICBwcml2YXRlIHdpbmRvdzogRmxvYXQzMkFycmF5OwoKICBjb25zdHJ1Y3RvcihmZnRTaXplOiBudW1iZXIsIGhvcFNpemU6IG51bWJlcikgewogICAgaWYgKGZmdFNpemUgPD0gMCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkZGVCBzaXplIG11c3QgYmUgcG9zaXRpdmUuIik7CiAgICB9CiAgICBpZiAoaG9wU2l6ZSA8PSAwKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiSG9wIHNpemUgbXVzdCBiZSBwb3NpdGl2ZS4iKTsKICAgIH0KCiAgICB0aGlzLmZmdFNpemUgPSBmZnRTaXplOwogICAgdGhpcy5ob3BTaXplID0gaG9wU2l6ZTsKICAgIHRoaXMuZmZ0ID0gbmV3IEZGVChmZnRTaXplKTsKICAgIHRoaXMud2luZG93ID0gdGhpcy5nZW5lcmF0ZUhhbm5pbmdXaW5kb3coKTsKICB9CgogIHByaXZhdGUgZ2VuZXJhdGVIYW5uaW5nV2luZG93KCk6IEZsb2F0MzJBcnJheSB7CiAgICBjb25zdCB3aW5kb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZSk7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmZ0U2l6ZTsgaSsrKSB7CiAgICAgIHdpbmRvd1tpXSA9IDAuNSAqICgxIC0gTWF0aC5jb3MoKDIgKiBNYXRoLlBJICogaSkgLyAodGhpcy5mZnRTaXplIC0gMSkpKTsKICAgIH0KICAgIHJldHVybiB3aW5kb3c7CiAgfQoKICBwdWJsaWMgYW5hbHl6ZShzaWduYWw6IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheVtdIHsKICAgIGNvbnN0IHNwZWN0cm9ncmFtOiBGbG9hdDMyQXJyYXlbXSA9IFtdOwogICAgY29uc3QgZnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZSk7CiAgICBjb25zdCBjb21wbGV4RnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZSAqIDIpOwoKICAgIGZvciAobGV0IGkgPSAwOyBpICsgdGhpcy5mZnRTaXplIDw9IHNpZ25hbC5sZW5ndGg7IGkgKz0gdGhpcy5ob3BTaXplKSB7CiAgICAgIGNvbnN0IHNpZ25hbFNsaWNlID0gc2lnbmFsLnN1YmFycmF5KGksIGkgKyB0aGlzLmZmdFNpemUpOwogICAgICBmcmFtZS5zZXQoc2lnbmFsU2xpY2UpOwoKICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmZmdFNpemU7IGorKykgewogICAgICAgIGZyYW1lW2pdICo9IHRoaXMud2luZG93W2pdOwogICAgICB9CgogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuZmZ0U2l6ZTsgaisrKSB7CiAgICAgICAgY29tcGxleEZyYW1lW2ogKiAyXSA9IGZyYW1lW2pdOwogICAgICAgIGNvbXBsZXhGcmFtZVtqICogMiArIDFdID0gMDsKICAgICAgfQoKICAgICAgdGhpcy5mZnQudHJhbnNmb3JtKGNvbXBsZXhGcmFtZSk7CgogICAgICBzcGVjdHJvZ3JhbS5wdXNoKGNvbXBsZXhGcmFtZS5zbGljZSgpKTsKICAgIH0KCiAgICByZXR1cm4gc3BlY3Ryb2dyYW07CiAgfQp9Cg==",__vite_glob_1_10="data:video/mp2t;base64,aW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAicmVhY3QiOwppbXBvcnQgeyBJTkZFUkVOQ0VfSU5URVJWQUxfUyB9IGZyb20gIi4vY29uc3QiOwppbXBvcnQgeyBsb2FkTW9kZWwsIHJ1bkluZmVyZW5jZSB9IGZyb20gIi4vdXRpbHMvaW5mZXJlbmNlIjsKaW1wb3J0IHsgdXNlQXVkaW9Qcm9jZXNzaW5nIH0gZnJvbSAiLi9ob29rcy91c2VBdWRpb1Byb2Nlc3NpbmciOwppbXBvcnQgdHlwZSB7IFRleHRTZWdtZW50IH0gZnJvbSAiLi91dGlscy90ZXh0RGVjb2RlciI7Cgp0eXBlIFVzZURlY29kZVBhcmFtcyA9IHsKICBmaWx0ZXJGcmVxOiBudW1iZXIgfCBudWxsOwogIGZpbHRlcldpZHRoOiBudW1iZXI7CiAgZ2FpbjogbnVtYmVyOwogIHN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsOwogIGxhbmd1YWdlOiAiRU4iIHwgIkVOL0pBIjsKfTsKCi8qKgogKiBDV+ODh+OCs+ODvOODieapn+iDveOCkuaPkOS+m+OBmeOCi+OCq+OCueOCv+ODoOODleODg+OCrwogKi8KZXhwb3J0IGNvbnN0IHVzZURlY29kZSA9ICh7CiAgZmlsdGVyRnJlcSwKICBmaWx0ZXJXaWR0aCwKICBnYWluLAogIHN0cmVhbSwKICBsYW5ndWFnZSwKfTogVXNlRGVjb2RlUGFyYW1zKSA9PiB7CiAgY29uc3QgW2xvYWRlZCwgc2V0TG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTsKICBjb25zdCBbbG9hZGVkSmEsIHNldExvYWRlZEphXSA9IHVzZVN0YXRlKGZhbHNlKTsKICBjb25zdCBbY3VycmVudFNlZ21lbnRzLCBzZXRDdXJyZW50U2VnbWVudHNdID0gdXNlU3RhdGU8VGV4dFNlZ21lbnRbXT4oW10pOwogIGNvbnN0IFtjdXJyZW50U2VnbWVudHNKYSwgc2V0Q3VycmVudFNlZ21lbnRzSmFdID0gdXNlU3RhdGU8VGV4dFNlZ21lbnRbXT4oW10pOwogIGNvbnN0IFtpc0RlY29kaW5nLCBzZXRJc0RlY29kaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTsKCiAgY29uc3QgZmlsdGVyUGFyYW1zUmVmID0gdXNlUmVmKHsgZmlsdGVyRnJlcSwgZmlsdGVyV2lkdGggfSk7CiAgY29uc3QgaW5mZXJlbmNlSW50ZXJ2YWxJZCA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpOwoKICBjb25zdCBhdWRpb0J1ZmZlclJlZiA9IHVzZUF1ZGlvUHJvY2Vzc2luZyhzdHJlYW0sIGdhaW4pOwoKICB1c2VFZmZlY3QoKCkgPT4gewogICAgKGFzeW5jICgpID0+IHsKICAgICAgYXdhaXQgbG9hZE1vZGVsKCJlbiIpOwogICAgICBzZXRMb2FkZWQodHJ1ZSk7CiAgICB9KSgpOwogIH0sIFtdKTsKCiAgdXNlRWZmZWN0KCgpID0+IHsKICAgIGlmIChsYW5ndWFnZSA9PT0gIkVOL0pBIiAmJiAhbG9hZGVkSmEpIHsKICAgICAgKGFzeW5jICgpID0+IHsKICAgICAgICBhd2FpdCBsb2FkTW9kZWwoImphIik7CiAgICAgICAgc2V0TG9hZGVkSmEodHJ1ZSk7CiAgICAgIH0pKCk7CiAgICB9CiAgfSwgW2xhbmd1YWdlLCBsb2FkZWRKYV0pOwoKICAvLyDjg5XjgqPjg6vjgr/jg7zjg5Hjg6njg6Hjg7zjgr/jga7mm7TmlrAKICB1c2VFZmZlY3QoKCkgPT4gewogICAgZmlsdGVyUGFyYW1zUmVmLmN1cnJlbnQgPSB7IGZpbHRlckZyZXEsIGZpbHRlcldpZHRoIH07CiAgfSwgW2ZpbHRlckZyZXEsIGZpbHRlcldpZHRoXSk7CgogIC8vIOODh+OCs+ODvOODieWHpueQhgogIHVzZUVmZmVjdCgoKSA9PiB7CiAgICBpZiAoIXN0cmVhbSB8fCAhbG9hZGVkKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpbmZlcmVuY2VJbnRlcnZhbElkLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7CiAgICAgIGNvbnN0IHsgZmlsdGVyRnJlcSwgZmlsdGVyV2lkdGggfSA9IGZpbHRlclBhcmFtc1JlZi5jdXJyZW50OwogICAgICAKICAgICAgY29uc3Qgc2VnbWVudHNFbiA9IGF3YWl0IHJ1bkluZmVyZW5jZSgKICAgICAgICBhdWRpb0J1ZmZlclJlZi5jdXJyZW50LAogICAgICAgIGZpbHRlckZyZXEsCiAgICAgICAgZmlsdGVyV2lkdGgsCiAgICAgICAgImVuIgogICAgICApOwogICAgICBzZXRDdXJyZW50U2VnbWVudHMoc2VnbWVudHNFbik7CiAgICAgIAogICAgICBpZiAobGFuZ3VhZ2UgPT09ICJFTi9KQSIgJiYgbG9hZGVkSmEpIHsKICAgICAgICBjb25zdCBzZWdtZW50c0phID0gYXdhaXQgcnVuSW5mZXJlbmNlKAogICAgICAgICAgYXVkaW9CdWZmZXJSZWYuY3VycmVudCwKICAgICAgICAgIGZpbHRlckZyZXEsCiAgICAgICAgICBmaWx0ZXJXaWR0aCwKICAgICAgICAgICJqYSIKICAgICAgICApOwogICAgICAgIHNldEN1cnJlbnRTZWdtZW50c0phKHNlZ21lbnRzSmEpOwogICAgICB9CiAgICB9LCBJTkZFUkVOQ0VfSU5URVJWQUxfUyAqIDEwMDApOwoKICAgIHNldElzRGVjb2RpbmcodHJ1ZSk7CgogICAgcmV0dXJuICgpID0+IHsKICAgICAgc2V0SXNEZWNvZGluZyhmYWxzZSk7CiAgICAgIGlmIChpbmZlcmVuY2VJbnRlcnZhbElkLmN1cnJlbnQpIHsKICAgICAgICBjbGVhckludGVydmFsKGluZmVyZW5jZUludGVydmFsSWQuY3VycmVudCk7CiAgICAgIH0KICAgIH07CiAgfSwgW3N0cmVhbSwgbG9hZGVkLCBsb2FkZWRKYSwgbGFuZ3VhZ2UsIGF1ZGlvQnVmZmVyUmVmXSk7CgogIHJldHVybiB7IGxvYWRlZCwgbG9hZGVkSmEsIGN1cnJlbnRTZWdtZW50cywgY3VycmVudFNlZ21lbnRzSmEsIGlzRGVjb2RpbmcgfTsKfTsK",__vite_glob_1_11="data:video/mp2t;base64,Ly8vIDxyZWZlcmVuY2UgdHlwZXM9InZpdGUvY2xpZW50IiAvPgo=";/*!
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Hd=Object.create,an=Object.defineProperty,qd=Object.getOwnPropertyDescriptor,jd=Object.getOwnPropertyNames,Xd=Object.getPrototypeOf,Kd=Object.prototype.hasOwnProperty,Co=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(r,i)=>(typeof require<"u"?require:r)[i]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),O=(t,r)=>()=>(t&&(r=t(t=0)),r),mt=(t,r)=>()=>(r||t((r={exports:{}}).exports,r),r.exports),Or=(t,r)=>{for(var i in r)an(t,i,{get:r[i],enumerable:!0})},Qa=(t,r,i,o)=>{if(r&&typeof r=="object"||typeof r=="function")for(let u of jd(r))!Kd.call(t,u)&&u!==i&&an(t,u,{get:()=>r[u],enumerable:!(o=qd(r,u))||o.enumerable});return t},rr=(t,r,i)=>(i=t!=null?Hd(Xd(t)):{},Qa(!t||!t.__esModule?an(i,"default",{value:t,enumerable:!0}):i,t)),sn=t=>Qa(an({},"__esModule",{value:!0}),t),un,ke,nr,Jd,ln,fn=O(()=>{un=new Map,ke=[],nr=(t,r,i)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let o=un.get(t);if(o===void 0)un.set(t,{backend:r,priority:i});else{if(o.priority>i)return;if(o.priority===i&&o.backend!==r)throw new Error(`cannot register backend "${t}" using priority ${i}`)}if(i>=0){let u=ke.indexOf(t);u!==-1&&ke.splice(u,1);for(let n=0;n<ke.length;n++)if(un.get(ke[n]).priority<=i){ke.splice(n,0,t);return}ke.push(t)}return}throw new TypeError("not a valid backend")},Jd=async t=>{let r=un.get(t);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let i=!!r.initPromise;try{return i||(r.initPromise=r.backend.init(t)),await r.initPromise,r.initialized=!0,r.backend}catch(o){return i||(r.error=`${o}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},ln=async t=>{let r=t.executionProviders||[],i=r.map(p=>typeof p=="string"?p:p.name),o=i.length===0?ke:i,u,n=[],a=new Set;for(let p of o){let e=await Jd(p);typeof e=="string"?n.push({name:p,err:e}):(u||(u=e),u===e&&a.add(p))}if(!u)throw new Error(`no available backend found. ERR: ${n.map(p=>`[${p.name}] ${p.err}`).join(", ")}`);for(let{name:p,err:e}of n)i.includes(p)&&console.warn(`removing requested execution provider "${p}" from session options because it is not available: ${e}`);let c=r.filter(p=>a.has(typeof p=="string"?p:p.name));return[u,new Proxy(t,{get:(p,e)=>e==="executionProviders"?c:Reflect.get(p,e)})]}}),ts=O(()=>{fn()}),es,rs=O(()=>{es="1.20.0"}),ns,Gt,No=O(()=>{rs(),ns="warning",Gt={wasm:{},webgl:{},webgpu:{},versions:{common:es},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);ns=t}},get logLevel(){return ns}},Object.defineProperty(Gt,"logLevel",{enumerable:!0})}),z,os=O(()=>{No(),z=Gt}),is,as,ss=O(()=>{is=(t,r)=>{let i=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);i.width=t.dims[3],i.height=t.dims[2];let o=i.getContext("2d");if(o!=null){let u,n;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(u=t.dims[2],n=t.dims[3]):(u=t.dims[3],n=t.dims[2]);let a=r?.format!==void 0?r.format:"RGB",c=r?.norm,p,e;c===void 0||c.mean===void 0?p=[255,255,255,255]:typeof c.mean=="number"?p=[c.mean,c.mean,c.mean,c.mean]:(p=[c.mean[0],c.mean[1],c.mean[2],0],c.mean[3]!==void 0&&(p[3]=c.mean[3])),c===void 0||c.bias===void 0?e=[0,0,0,0]:typeof c.bias=="number"?e=[c.bias,c.bias,c.bias,c.bias]:(e=[c.bias[0],c.bias[1],c.bias[2],0],c.bias[3]!==void 0&&(e[3]=c.bias[3]));let l=n*u,s=0,d=l,h=l*2,g=-1;a==="RGBA"?(s=0,d=l,h=l*2,g=l*3):a==="RGB"?(s=0,d=l,h=l*2):a==="RBG"&&(s=0,h=l,d=l*2);for(let m=0;m<n;m++)for(let I=0;I<u;I++){let _=(t.data[s++]-e[0])*p[0],v=(t.data[d++]-e[1])*p[1],S=(t.data[h++]-e[2])*p[2],E=g===-1?255:(t.data[g++]-e[3])*p[3];o.fillStyle="rgba("+_+","+v+","+S+","+E+")",o.fillRect(I,m,1,1)}if("toDataURL"in i)return i.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},as=(t,r)=>{let i=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(i!=null){let u,n,a;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(u=t.dims[2],n=t.dims[1],a=t.dims[3]):(u=t.dims[3],n=t.dims[2],a=t.dims[1]);let c=r!==void 0&&r.format!==void 0?r.format:"RGB",p=r?.norm,e,l;p===void 0||p.mean===void 0?e=[255,255,255,255]:typeof p.mean=="number"?e=[p.mean,p.mean,p.mean,p.mean]:(e=[p.mean[0],p.mean[1],p.mean[2],255],p.mean[3]!==void 0&&(e[3]=p.mean[3])),p===void 0||p.bias===void 0?l=[0,0,0,0]:typeof p.bias=="number"?l=[p.bias,p.bias,p.bias,p.bias]:(l=[p.bias[0],p.bias[1],p.bias[2],0],p.bias[3]!==void 0&&(l[3]=p.bias[3]));let s=n*u;if(r!==void 0&&(r.format!==void 0&&a===4&&r.format!=="RGBA"||a===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,g=1,m=2,I=3,_=0,v=s,S=s*2,E=-1;c==="RGBA"?(_=0,v=s,S=s*2,E=s*3):c==="RGB"?(_=0,v=s,S=s*2):c==="RBG"&&(_=0,S=s,v=s*2),o=i.createImageData(u,n);for(let $=0;$<n*u;h+=d,g+=d,m+=d,I+=d,$++)o.data[h]=(t.data[_++]-l[0])*e[0],o.data[g]=(t.data[v++]-l[1])*e[1],o.data[m]=(t.data[S++]-l[2])*e[2],o.data[I]=E===-1?255:(t.data[E++]-l[3])*e[3]}else throw new Error("Can not access image data");return o}}),Ro,us,ls,fs,cs,ps,ds=O(()=>{cn(),Ro=(t,r)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:i,width:o}=r,u=r.norm??{mean:255,bias:0},n,a;typeof u.mean=="number"?n=[u.mean,u.mean,u.mean,u.mean]:n=[u.mean[0],u.mean[1],u.mean[2],u.mean[3]??255],typeof u.bias=="number"?a=[u.bias,u.bias,u.bias,u.bias]:a=[u.bias[0],u.bias[1],u.bias[2],u.bias[3]??0];let c=r.format!==void 0?r.format:"RGBA",p=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",e=i*o,l=p==="RGBA"?new Float32Array(e*4):new Float32Array(e*3),s=4,d=0,h=1,g=2,m=3,I=0,_=e,v=e*2,S=-1;c==="RGB"&&(s=3,d=0,h=1,g=2,m=-1),p==="RGBA"?S=e*3:p==="RBG"?(I=0,v=e,_=e*2):p==="BGR"&&(v=0,_=e,I=e*2);for(let E=0;E<e;E++,d+=s,g+=s,h+=s,m+=s)l[I++]=(t[d]+a[0])/n[0],l[_++]=(t[h]+a[1])/n[1],l[v++]=(t[g]+a[2])/n[2],S!==-1&&m!==-1&&(l[S++]=(t[m]+a[3])/n[3]);return p==="RGBA"?new St("float32",l,[1,4,i,o]):new St("float32",l,[1,3,i,o])},us=async(t,r)=>{let i=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,u=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,n=typeof t=="string",a,c=r??{},p=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},e=l=>typeof HTMLCanvasElement<"u"&&l instanceof HTMLCanvasElement||l instanceof OffscreenCanvas?l.getContext("2d"):null;if(i){let l=p();l.width=t.width,l.height=t.height;let s=e(l);if(s!=null){let d=t.height,h=t.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(d=r.resizedHeight,h=r.resizedWidth),r!==void 0){if(c=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");c.tensorFormat="RGBA",c.height=d,c.width=h}else c.tensorFormat="RGBA",c.height=d,c.width=h;s.drawImage(t,0,0),a=s.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(o){let l,s;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(l=r.resizedHeight,s=r.resizedWidth):(l=t.height,s=t.width),r!==void 0&&(c=r),c.format="RGBA",c.height=l,c.width=s,r!==void 0){let d=p();d.width=s,d.height=l;let h=e(d);if(h!=null)h.putImageData(t,0,0),a=h.getImageData(0,0,s,l).data;else throw new Error("Can not access image data")}else a=t.data}else if(u){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let l=p();l.width=t.width,l.height=t.height;let s=e(l);if(s!=null){let d=t.height,h=t.width;return s.drawImage(t,0,0,h,d),a=s.getImageData(0,0,h,d).data,c.height=d,c.width=h,Ro(a,c)}else throw new Error("Can not access image data")}else{if(n)return new Promise((l,s)=>{let d=p(),h=e(d);if(!t||!h)return s();let g=new Image;g.crossOrigin="Anonymous",g.src=t,g.onload=()=>{d.width=g.width,d.height=g.height,h.drawImage(g,0,0,d.width,d.height);let m=h.getImageData(0,0,d.width,d.height);c.height=d.height,c.width=d.width,l(Ro(m.data,c))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return Ro(a,c);throw new Error("Input data provided is not supported - aborted tensor creation")},ls=(t,r)=>{let{width:i,height:o,download:u,dispose:n}=r,a=[1,o,i,4];return new St({location:"texture",type:"float32",texture:t,dims:a,download:u,dispose:n})},fs=(t,r)=>{let{dataType:i,dims:o,download:u,dispose:n}=r;return new St({location:"gpu-buffer",type:i??"float32",gpuBuffer:t,dims:o,download:u,dispose:n})},cs=(t,r)=>{let{dataType:i,dims:o,download:u,dispose:n}=r;return new St({location:"ml-tensor",type:i??"float32",mlTensor:t,dims:o,download:u,dispose:n})},ps=(t,r,i)=>new St({location:"cpu-pinned",type:t,data:r,dims:i??[r.length]})}),Be,Sr,hs,ms,bs=O(()=>{Be=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Sr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),hs=!1,ms=()=>{if(!hs){hs=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,r=typeof BigUint64Array<"u"&&BigUint64Array.from,i=typeof Float16Array<"u"&&Float16Array.from;t&&(Be.set("int64",BigInt64Array),Sr.set(BigInt64Array,"int64")),r&&(Be.set("uint64",BigUint64Array),Sr.set(BigUint64Array,"uint64")),i?(Be.set("float16",Float16Array),Sr.set(Float16Array,"float16")):Be.set("float16",Uint16Array)}}}),gs,ys,xs=O(()=>{cn(),gs=t=>{let r=1;for(let i=0;i<t.length;i++){let o=t[i];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${i}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${o}`);r*=o}return r},ys=(t,r)=>{switch(t.location){case"cpu":return new St(t.type,t.data,r);case"cpu-pinned":return new St({location:"cpu-pinned",data:t.data,type:t.type,dims:r});case"texture":return new St({location:"texture",texture:t.texture,type:t.type,dims:r});case"gpu-buffer":return new St({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:r});case"ml-tensor":return new St({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),St,cn=O(()=>{ss(),ds(),bs(),xs(),St=class{constructor(t,r,i){ms();let o,u;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,o=t.type,u=t.dims,t.location){case"cpu-pinned":{let a=Be.get(o);if(!a)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(t.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=t.data;break}case"texture":{if(o!=="float32")throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="uint8"&&o!=="bool"&&o!=="uint4"&&o!=="int4")throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="uint64"&&o!=="int8"&&o!=="uint8"&&o!=="bool")throw new TypeError(`unsupported type "${o}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,c;if(typeof t=="string")if(o=t,c=i,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");a=r}else{let p=Be.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16"&&p===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);t==="uint64"||t==="int64"?a=p.from(r,BigInt):a=p.from(r)}else if(r instanceof p)a=r;else if(r instanceof Uint8ClampedArray)if(t==="uint8")a=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(c=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let p=typeof t[0];if(p==="string")o="string",a=t;else if(p==="boolean")o="bool",a=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(t instanceof Uint8ClampedArray)o="uint8",a=Uint8Array.from(t);else{let p=Sr.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,a=t}if(c===void 0)c=[a.length];else if(!Array.isArray(c))throw new TypeError("A tensor's dims must be a number array");u=c,this.cpuData=a,this.dataLocation="cpu"}let n=gs(u);if(this.cpuData&&n!==this.cpuData.length&&!((o==="uint4"||o==="int4")&&Math.ceil(n/2)===this.cpuData.length))throw new Error(`Tensor's size(${n}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=u,this.size=n}static async fromImage(t,r){return us(t,r)}static fromTexture(t,r){return ls(t,r)}static fromGpuBuffer(t,r){return fs(t,r)}static fromMLTensor(t,r){return cs(t,r)}static fromPinnedBuffer(t,r,i){return ps(t,r,i)}toDataURL(t){return is(this,t)}toImageData(t){return as(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ys(this,t)}}}),yt,pn=O(()=>{cn(),yt=St}),Ts,ws,Fe,Ce,Go=O(()=>{No(),Ts=(t,r)=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||console.timeStamp(`${t}::ORT::${r}`)},ws=(t,r)=>{let i=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let u=0;u<i.length;u++){if(o&&!i[u].includes("TRACE_FUNC")){let n=`FUNC_${t}::${i[u].trim().split(" ")[1]}`;r&&(n+=`::${r}`),Ts("CPU",n);return}i[u].includes("TRACE_FUNC")&&(o=!0)}},Fe=t=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||ws("BEGIN",t)},Ce=t=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||ws("END",t)}}),dn,vs=O(()=>{fn(),pn(),Go(),dn=class wa{constructor(r){this.handler=r}async run(r,i,o){Fe();let u={},n={};if(typeof r!="object"||r===null||r instanceof yt||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof i=="object"){if(i===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(i instanceof yt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(i)){if(i.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let e of i){if(typeof e!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(e)===-1)throw new RangeError(`'fetches' contains invalid output name: ${e}.`);u[e]=null}if(typeof o=="object"&&o!==null)n=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,l=Object.getOwnPropertyNames(i);for(let s of this.outputNames)if(l.indexOf(s)!==-1){let d=i[s];(d===null||d instanceof yt)&&(e=!0,a=!1,u[s]=d)}if(e){if(typeof o=="object"&&o!==null)n=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else n=i}}else if(typeof i<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let e of this.inputNames)if(typeof r[e]>"u")throw new Error(`input '${e}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)u[e]=null;let c=await this.handler.run(r,u,n),p={};for(let e in c)if(Object.hasOwnProperty.call(c,e)){let l=c[e];l instanceof yt?p[e]=l:p[e]=new yt(l.type,l.data,l.dims)}return Ce(),p}async release(){return this.handler.dispose()}static async create(r,i,o,u){Fe();let n,a={};if(typeof r=="string"){if(n=r,typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(n=r,typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let l=r,s=0,d=r.byteLength;if(typeof i=="object"&&i!==null)a=i;else if(typeof i=="number"){if(s=i,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=l.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${l.byteLength}).`);if(d=r.byteLength-s,typeof o=="number"){if(d=o,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||s+d>l.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${l.byteLength-s}].`);if(typeof u=="object"&&u!==null)a=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof i<"u")throw new TypeError("'options' must be an object.");n=new Uint8Array(l,s,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[c,p]=await ln(a),e=await c.createInferenceSessionHandler(n,p);return Ce(),new wa(e)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Yd,Is=O(()=>{vs(),Yd=dn}),_s=O(()=>{}),Os=O(()=>{}),Ss=O(()=>{}),As=O(()=>{}),Zd,hn,Ps=O(()=>{fn(),pn(),Zd="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",hn=class va{constructor(r,i,o){this.handler=r,this.hasOptimizerModel=i,this.hasEvalModel=o}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(r,i){let o=r.evalModel||"",u=r.optimizerModel||"",n=i||{},[a,c]=await ln(n);if(a.createTrainingSessionHandler){let p=await a.createTrainingSessionHandler(r.checkpointState,r.trainModel,o,u,c);return new va(p,!!r.optimizerModel,!!r.evalModel)}else throw new Error(Zd)}typeNarrowingForRunStep(r,i,o,u,n){let a={},c={};if(typeof o!="object"||o===null||o instanceof yt||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let p=!0;if(typeof u=="object"){if(u===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(u instanceof yt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(u)){if(u.length===0)throw new TypeError("'fetches' cannot be an empty array.");p=!1;for(let e of u){if(typeof e!="string")throw new TypeError("'fetches' must be a string array or an object.");if(i.indexOf(e)===-1)throw new RangeError(`'fetches' contains invalid output name: ${e}.`);a[e]=null}if(typeof n=="object"&&n!==null)c=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,l=Object.getOwnPropertyNames(u);for(let s of i)if(l.indexOf(s)!==-1){let d=u[s];(d===null||d instanceof yt)&&(e=!0,p=!1,a[s]=d)}if(e){if(typeof n=="object"&&n!==null)c=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else c=u}}else if(typeof u<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let e of r)if(typeof o[e]>"u")throw new Error(`input '${e}' is missing in 'feeds'.`);if(p)for(let e of i)a[e]=null;return[a,c]}convertHandlerReturnTypeToMapOfTensors(r){let i={};for(let o in r)if(Object.hasOwnProperty.call(r,o)){let u=r[o];u instanceof yt?i[o]=u:i[o]=new yt(u.type,u.data,u.dims)}return i}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(r,i,o){let[u,n]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,r,i,o),a=await this.handler.runTrainStep(r,u,n);return this.convertHandlerReturnTypeToMapOfTensors(a)}async runOptimizerStep(r){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(r||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(r,i,o){if(this.hasEvalModel){let[u,n]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,r,i,o),a=await this.handler.runEvalStep(r,u,n);return this.convertHandlerReturnTypeToMapOfTensors(a)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(r=!0){return this.handler.getParametersSize(r)}async loadParametersBuffer(r,i=!0){let o=await this.getParametersSize(i);if(r.length!==4*o)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(r,i)}async getContiguousParameters(r=!0){return this.handler.getContiguousParameters(r)}async release(){return this.handler.dispose()}}}),Qd,Es=O(()=>{Ps(),Qd=hn}),Mo={};Or(Mo,{InferenceSession:()=>Yd,TRACE:()=>Ts,TRACE_FUNC_BEGIN:()=>Fe,TRACE_FUNC_END:()=>Ce,Tensor:()=>yt,TrainingSession:()=>Qd,env:()=>z,registerBackend:()=>nr});var Yt=O(()=>{ts(),os(),Is(),pn(),_s(),Os(),Go(),Ss(),As(),Es()});function _e(t,r,i,o){if(r===void 0)return eh(t);if(i===void 0)mn(t,r);else if(typeof i=="number"&&o===void 0)mn(t,r);else if(typeof i=="string"&&o===void 0)mn(t,i,1,r);else if(typeof i=="string"&&typeof o=="number")mn(t,i,o,r);else throw new TypeError("input is valid")}function eh(t){return{verbose:_e.verbose.bind(null,t),info:_e.info.bind(null,t),warning:_e.warning.bind(null,t),error:_e.error.bind(null,t),fatal:_e.fatal.bind(null,t)}}function mn(t,r,i,o){let u=Ar[o||""]||Ar[""];Ls[t]<Ls[u.minimalSeverity]||(u.logDateTime&&(r=`${new Date().toISOString()}|${r}`),u.logSourceLocation,th[u.provider].log(t,r,o))}var Uo,Vo,Ls,th,$s,Ar,tt,gn,yn,xn,bn,Ut=O(()=>{Uo=class{log(t,r,i){}},Vo=class{log(t,r,i){console.log(`${this.color(t)} ${i?"\x1B[35m"+i+"\x1B[0m ":""}${r}`)}color(t){switch(t){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${t}`)}}},Ls={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},th={none:new Uo,console:new Vo},$s={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Ar={"":$s},(t=>{function r(e,l){t("verbose",e,l)}t.verbose=r;function i(e,l){t("info",e,l)}t.info=i;function o(e,l){t("warning",e,l)}t.warning=o;function u(e,l){t("error",e,l)}t.error=u;function n(e,l){t("fatal",e,l)}t.fatal=n;function a(e){Ar={},c("",e||{})}t.reset=a;function c(e,l){if(e==="*")a(l);else{let s=Ar[e]||$s;Ar[e]={provider:l.provider||s.provider,minimalSeverity:l.minimalSeverity||s.minimalSeverity,logDateTime:l.logDateTime===void 0?s.logDateTime:l.logDateTime,logSourceLocation:l.logSourceLocation===void 0?s.logSourceLocation:l.logSourceLocation}}}t.set=c;function p(e){let l={};e.logLevel&&(l.minimalSeverity=e.logLevel),c("",l)}t.setWithEnv=p})(_e||={}),tt=_e,gn=class{constructor(t,r,i,o,u,n){this.category=t,this.name=r,this.startTime=i,this.endCallback=o,this.timer=u,this.ctx=n}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},yn=class{constructor(t,r,i,o){this.category=t,this.name=r,this.startTime=i,this.endTime=o}},xn=class{constructor(t,r,i){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=t===void 0?1e4:t,this._flushBatchSize=r===void 0?10:r,this._flushIntervalInMilliseconds=i===void 0?5e3:i}static create(t){return t===void 0?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=bn(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,r,i,o){let u=this._started?this.begin(t,r,o):void 0,n=!1,a=i();if(a&&typeof a.then=="function")return n=!0,new Promise((c,p)=>{a.then(async e=>{u&&await u.end(),c(e)},async e=>{u&&await u.end(),p(e)})});if(!n&&u){let c=u.end();if(c&&typeof c.then=="function")return new Promise((p,e)=>{c.then(()=>{p(a)},l=>{e(l)})})}return a}begin(t,r,i){if(!this._started)throw new Error("profiler is not started yet");if(i===void 0){let o=bn();return this.flush(o),new gn(t,r,o,u=>this.endSync(u))}else{let o=i.beginTimer();return new gn(t,r,0,async u=>this.end(u),o,i)}}async end(t){let r=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new yn(t.category,t.name,t.startTime,r)),this.flush(r))}endSync(t){let r=bn();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new yn(t.category,t.name,t.startTime,r)),this.flush(r))}logOneEvent(t){tt.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(let r=this._flushPointer;this._flushPointer<r+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=bn()}}get started(){return this._started}},bn=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function ks(t,r,i){for(let o of i){let u=o[0],n=o[1],a=o[2],c=o[3],p=o[4];if(t.opType===u){for(let e of r)if((e.domain===n||e.domain==="ai.onnx"&&n==="")&&rh(e.version,a))return{opImpl:c,opInit:p}}}throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${r.map(o=>`${o.domain||"ai.onnx"} v${o.version}`).join(", ")}`)}function rh(t,r){if(r.endsWith("+")){let i=Number.parseInt(r.substring(0,r.length-1),10);return!isNaN(i)&&i<=t}else if(r.split("-").length===2){let i=r.split("-"),o=Number.parseInt(i[0],10),u=Number.parseInt(i[1],10);return!isNaN(o)&&!isNaN(u)&&o<=t&&t<=u}else return Number.parseInt(r,10)===t}var Bs=O(()=>{}),Fs=mt(t=>{t.__esModule=!0;var r=(function(){function i(o){if(!o)throw new TypeError("Invalid argument; `value` has no value.");this.value=i.EMPTY,o&&i.isGuid(o)&&(this.value=o)}return i.isGuid=function(o){var u=o.toString();return o&&(o instanceof i||i.validator.test(u))},i.create=function(){return new i([i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-"))},i.createEmpty=function(){return new i("emptyguid")},i.parse=function(o){return new i(o)},i.raw=function(){return[i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-")},i.gen=function(o){for(var u="",n=0;n<o;n++)u+=((1+Math.random())*65536|0).toString(16).substring(1);return u},i.prototype.equals=function(o){return i.isGuid(o)&&this.value===o.toString()},i.prototype.isEmpty=function(){return this.value===i.EMPTY},i.prototype.toString=function(){return this.value},i.prototype.toJSON=function(){return{value:this.value}},i.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),i.EMPTY="00000000-0000-0000-0000-000000000000",i})();t.Guid=r});function rt(t,r,i){this.low=t|0,this.high=r|0,this.unsigned=!!i}function Et(t){return(t&&t.__isLong__)===!0}function Cs(t){var r=Math.clz32(t&-t);return t?31-r:r}function Ne(t,r){var i,o,u;return r?(t>>>=0,(u=0<=t&&t<256)&&(o=Rs[t],o)?o:(i=J(t,0,!0),u&&(Rs[t]=i),i)):(t|=0,(u=-128<=t&&t<128)&&(o=Ns[t],o)?o:(i=J(t,t<0?-1:0,!1),u&&(Ns[t]=i),i))}function zt(t,r){if(isNaN(t))return r?ye:Zt;if(r){if(t<0)return ye;if(t>=Vs)return Hs}else{if(t<=-Ms)return Ct;if(t+1>=Ms)return Ws}return t<0?zt(-t,r).neg():J(t%ir|0,t/ir|0,r)}function J(t,r,i){return new rt(t,r,i)}function Ho(t,r,i){if(t.length===0)throw Error("empty string");if(typeof r=="number"?(i=r,r=!1):r=!!r,t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return r?ye:Zt;if(i=i||10,i<2||36<i)throw RangeError("radix");var o;if((o=t.indexOf("-"))>0)throw Error("interior hyphen");if(o===0)return Ho(t.substring(1),r,i).neg();for(var u=zt(Tn(i,8)),n=Zt,a=0;a<t.length;a+=8){var c=Math.min(8,t.length-a),p=parseInt(t.substring(a,a+c),i);if(c<8){var e=zt(Tn(i,c));n=n.mul(e).add(zt(p))}else n=n.mul(u),n=n.add(zt(p))}return n.unsigned=r,n}function Qt(t,r){return typeof t=="number"?zt(t,r):typeof t=="string"?Ho(t,r):J(t.low,t.high,typeof r=="boolean"?r:t.unsigned)}var Vt,Ns,Rs,Tn,Gs,oh,ir,Vs,Ms,Us,Zt,ye,or,zs,Wo,Ws,Hs,Ct,D,xe,qo=O(()=>{Vt=null;try{Vt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}rt.prototype.__isLong__,Object.defineProperty(rt.prototype,"__isLong__",{value:!0}),rt.isLong=Et,Ns={},Rs={},rt.fromInt=Ne,rt.fromNumber=zt,rt.fromBits=J,Tn=Math.pow,rt.fromString=Ho,rt.fromValue=Qt,Gs=65536,oh=1<<24,ir=Gs*Gs,Vs=ir*ir,Ms=Vs/2,Us=Ne(oh),Zt=Ne(0),rt.ZERO=Zt,ye=Ne(0,!0),rt.UZERO=ye,or=Ne(1),rt.ONE=or,zs=Ne(1,!0),rt.UONE=zs,Wo=Ne(-1),rt.NEG_ONE=Wo,Ws=J(-1,2147483647,!1),rt.MAX_VALUE=Ws,Hs=J(-1,-1,!0),rt.MAX_UNSIGNED_VALUE=Hs,Ct=J(0,-2147483648,!1),rt.MIN_VALUE=Ct,D=rt.prototype,D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*ir+(this.low>>>0):this.high*ir+(this.low>>>0)},D.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ct)){var r=zt(t),i=this.div(r),o=i.mul(r).sub(this);return i.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var u=zt(Tn(t,6),this.unsigned),n=this,a="";;){var c=n.div(u),p=n.sub(c.mul(u)).toInt()>>>0,e=p.toString(t);if(n=c,n.isZero())return e+a;for(;e.length<6;)e="0"+e;a=""+e+a}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ct)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,r=31;r>0&&!(t&1<<r);r--);return this.high!=0?r+33:r+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(t){return Et(t)||(t=Qt(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low},D.eq=D.equals,D.notEquals=function(t){return!this.eq(t)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(t){return this.comp(t)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(t){return this.comp(t)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(t){return this.comp(t)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(t){return this.comp(t)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(t){if(Et(t)||(t=Qt(t)),this.eq(t))return 0;var r=this.isNegative(),i=t.isNegative();return r&&!i?-1:!r&&i?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(Ct)?Ct:this.not().add(or)},D.neg=D.negate,D.add=function(t){Et(t)||(t=Qt(t));var r=this.high>>>16,i=this.high&65535,o=this.low>>>16,u=this.low&65535,n=t.high>>>16,a=t.high&65535,c=t.low>>>16,p=t.low&65535,e=0,l=0,s=0,d=0;return d+=u+p,s+=d>>>16,d&=65535,s+=o+c,l+=s>>>16,s&=65535,l+=i+a,e+=l>>>16,l&=65535,e+=r+n,e&=65535,J(s<<16|d,e<<16|l,this.unsigned)},D.subtract=function(t){return Et(t)||(t=Qt(t)),this.add(t.neg())},D.sub=D.subtract,D.multiply=function(t){if(this.isZero())return this;if(Et(t)||(t=Qt(t)),Vt){var r=Vt.mul(this.low,this.high,t.low,t.high);return J(r,Vt.get_high(),this.unsigned)}if(t.isZero())return this.unsigned?ye:Zt;if(this.eq(Ct))return t.isOdd()?Ct:Zt;if(t.eq(Ct))return this.isOdd()?Ct:Zt;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(Us)&&t.lt(Us))return zt(this.toNumber()*t.toNumber(),this.unsigned);var i=this.high>>>16,o=this.high&65535,u=this.low>>>16,n=this.low&65535,a=t.high>>>16,c=t.high&65535,p=t.low>>>16,e=t.low&65535,l=0,s=0,d=0,h=0;return h+=n*e,d+=h>>>16,h&=65535,d+=u*e,s+=d>>>16,d&=65535,d+=n*p,s+=d>>>16,d&=65535,s+=o*e,l+=s>>>16,s&=65535,s+=u*p,l+=s>>>16,s&=65535,s+=n*c,l+=s>>>16,s&=65535,l+=i*e+o*p+u*c+n*a,l&=65535,J(d<<16|h,l<<16|s,this.unsigned)},D.mul=D.multiply,D.divide=function(t){if(Et(t)||(t=Qt(t)),t.isZero())throw Error("division by zero");if(Vt){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var r=(this.unsigned?Vt.div_u:Vt.div_s)(this.low,this.high,t.low,t.high);return J(r,Vt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ye:Zt;var i,o,u;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return ye;if(t.gt(this.shru(1)))return zs;u=ye}else{if(this.eq(Ct)){if(t.eq(or)||t.eq(Wo))return Ct;if(t.eq(Ct))return or;var n=this.shr(1);return i=n.div(t).shl(1),i.eq(Zt)?t.isNegative()?or:Wo:(o=this.sub(t.mul(i)),u=i.add(o.div(t)),u)}else if(t.eq(Ct))return this.unsigned?ye:Zt;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();u=Zt}for(o=this;o.gte(t);){i=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(i)/Math.LN2),c=a<=48?1:Tn(2,a-48),p=zt(i),e=p.mul(t);e.isNegative()||e.gt(o);)i-=c,p=zt(i,this.unsigned),e=p.mul(t);p.isZero()&&(p=or),u=u.add(p),o=o.sub(e)}return u},D.div=D.divide,D.modulo=function(t){if(Et(t)||(t=Qt(t)),Vt){var r=(this.unsigned?Vt.rem_u:Vt.rem_s)(this.low,this.high,t.low,t.high);return J(r,Vt.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return J(~this.low,~this.high,this.unsigned)},D.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},D.clz=D.countLeadingZeros,D.countTrailingZeros=function(){return this.low?Cs(this.low):Cs(this.high)+32},D.ctz=D.countTrailingZeros,D.and=function(t){return Et(t)||(t=Qt(t)),J(this.low&t.low,this.high&t.high,this.unsigned)},D.or=function(t){return Et(t)||(t=Qt(t)),J(this.low|t.low,this.high|t.high,this.unsigned)},D.xor=function(t){return Et(t)||(t=Qt(t)),J(this.low^t.low,this.high^t.high,this.unsigned)},D.shiftLeft=function(t){return Et(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?J(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):J(0,this.low<<t-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(t){return Et(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?J(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):J(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(t){return Et(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?J(this.low>>>t|this.high<<32-t,this.high>>>t,this.unsigned):t===32?J(this.high,0,this.unsigned):J(this.high>>>t-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.rotateLeft=function(t){var r;return Et(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?J(this.high,this.low,this.unsigned):t<32?(r=32-t,J(this.low<<t|this.high>>>r,this.high<<t|this.low>>>r,this.unsigned)):(t-=32,r=32-t,J(this.high<<t|this.low>>>r,this.low<<t|this.high>>>r,this.unsigned))},D.rotl=D.rotateLeft,D.rotateRight=function(t){var r;return Et(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?J(this.high,this.low,this.unsigned):t<32?(r=32-t,J(this.high<<r|this.low>>>t,this.low<<r|this.high>>>t,this.unsigned)):(t-=32,r=32-t,J(this.low<<r|this.high>>>t,this.high<<r|this.low>>>t,this.unsigned))},D.rotr=D.rotateRight,D.toSigned=function(){return this.unsigned?J(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:J(this.low,this.high,!0)},D.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var t=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]},D.toBytesBE=function(){var t=this.high,r=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,r>>>24,r>>>16&255,r>>>8&255,r&255]},rt.fromBytes=function(t,r,i){return i?rt.fromBytesLE(t,r):rt.fromBytesBE(t,r)},rt.fromBytesLE=function(t,r){return new rt(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,r)},rt.fromBytesBE=function(t,r){return new rt(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],r)},xe=rt}),w,wn=O(()=>{w={},w.Offset,w.Table,w.SIZEOF_SHORT=2,w.SIZEOF_INT=4,w.FILE_IDENTIFIER_LENGTH=4,w.SIZE_PREFIX_LENGTH=4,w.Encoding={UTF8_BYTES:1,UTF16_STRING:2},w.int32=new Int32Array(2),w.float32=new Float32Array(w.int32.buffer),w.float64=new Float64Array(w.int32.buffer),w.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,w.Long=function(t,r){this.low=t|0,this.high=r|0},w.Long.create=function(t,r){return t==0&&r==0?w.Long.ZERO:new w.Long(t,r)},w.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},w.Long.prototype.equals=function(t){return this.low==t.low&&this.high==t.high},w.Long.ZERO=new w.Long(0,0),w.Builder=function(t){if(t)var r=t;else var r=1024;this.bb=w.ByteBuffer.allocate(r),this.space=r,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},w.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},w.Builder.prototype.forceDefaults=function(t){this.force_defaults=t},w.Builder.prototype.dataBuffer=function(){return this.bb},w.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},w.Builder.prototype.prep=function(t,r){t>this.minalign&&(this.minalign=t);for(var i=~(this.bb.capacity()-this.space+r)+1&t-1;this.space<i+t+r;){var o=this.bb.capacity();this.bb=w.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-o}this.pad(i)},w.Builder.prototype.pad=function(t){for(var r=0;r<t;r++)this.bb.writeInt8(--this.space,0)},w.Builder.prototype.writeInt8=function(t){this.bb.writeInt8(this.space-=1,t)},w.Builder.prototype.writeInt16=function(t){this.bb.writeInt16(this.space-=2,t)},w.Builder.prototype.writeInt32=function(t){this.bb.writeInt32(this.space-=4,t)},w.Builder.prototype.writeInt64=function(t){this.bb.writeInt64(this.space-=8,t)},w.Builder.prototype.writeFloat32=function(t){this.bb.writeFloat32(this.space-=4,t)},w.Builder.prototype.writeFloat64=function(t){this.bb.writeFloat64(this.space-=8,t)},w.Builder.prototype.addInt8=function(t){this.prep(1,0),this.writeInt8(t)},w.Builder.prototype.addInt16=function(t){this.prep(2,0),this.writeInt16(t)},w.Builder.prototype.addInt32=function(t){this.prep(4,0),this.writeInt32(t)},w.Builder.prototype.addInt64=function(t){this.prep(8,0),this.writeInt64(t)},w.Builder.prototype.addFloat32=function(t){this.prep(4,0),this.writeFloat32(t)},w.Builder.prototype.addFloat64=function(t){this.prep(8,0),this.writeFloat64(t)},w.Builder.prototype.addFieldInt8=function(t,r,i){(this.force_defaults||r!=i)&&(this.addInt8(r),this.slot(t))},w.Builder.prototype.addFieldInt16=function(t,r,i){(this.force_defaults||r!=i)&&(this.addInt16(r),this.slot(t))},w.Builder.prototype.addFieldInt32=function(t,r,i){(this.force_defaults||r!=i)&&(this.addInt32(r),this.slot(t))},w.Builder.prototype.addFieldInt64=function(t,r,i){(this.force_defaults||!r.equals(i))&&(this.addInt64(r),this.slot(t))},w.Builder.prototype.addFieldFloat32=function(t,r,i){(this.force_defaults||r!=i)&&(this.addFloat32(r),this.slot(t))},w.Builder.prototype.addFieldFloat64=function(t,r,i){(this.force_defaults||r!=i)&&(this.addFloat64(r),this.slot(t))},w.Builder.prototype.addFieldOffset=function(t,r,i){(this.force_defaults||r!=i)&&(this.addOffset(r),this.slot(t))},w.Builder.prototype.addFieldStruct=function(t,r,i){r!=i&&(this.nested(r),this.slot(t))},w.Builder.prototype.nested=function(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},w.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},w.Builder.prototype.slot=function(t){this.vtable[t]=this.offset()},w.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},w.Builder.growByteBuffer=function(t){var r=t.capacity();if(r&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var i=r<<1,o=w.ByteBuffer.allocate(i);return o.setPosition(i-r),o.bytes().set(t.bytes(),i-r),o},w.Builder.prototype.addOffset=function(t){this.prep(w.SIZEOF_INT,0),this.writeInt32(this.offset()-t+w.SIZEOF_INT)},w.Builder.prototype.startObject=function(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(var r=0;r<t;r++)this.vtable[r]=0;this.isNested=!0,this.object_start=this.offset()},w.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var t=this.offset(),r=this.vtable_in_use-1;r>=0&&this.vtable[r]==0;r--);for(var i=r+1;r>=0;r--)this.addInt16(this.vtable[r]!=0?t-this.vtable[r]:0);var o=2;this.addInt16(t-this.object_start);var u=(i+o)*w.SIZEOF_SHORT;this.addInt16(u);var n=0,a=this.space;t:for(r=0;r<this.vtables.length;r++){var c=this.bb.capacity()-this.vtables[r];if(u==this.bb.readInt16(c)){for(var p=w.SIZEOF_SHORT;p<u;p+=w.SIZEOF_SHORT)if(this.bb.readInt16(a+p)!=this.bb.readInt16(c+p))continue t;n=this.vtables[r];break}}return n?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,n-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t},w.Builder.prototype.finish=function(t,r,i){var o=i?w.SIZE_PREFIX_LENGTH:0;if(r){var u=r;if(this.prep(this.minalign,w.SIZEOF_INT+w.FILE_IDENTIFIER_LENGTH+o),u.length!=w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+w.FILE_IDENTIFIER_LENGTH);for(var n=w.FILE_IDENTIFIER_LENGTH-1;n>=0;n--)this.writeInt8(u.charCodeAt(n))}this.prep(this.minalign,w.SIZEOF_INT+o),this.addOffset(t),o&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},w.Builder.prototype.finishSizePrefixed=function(t,r){this.finish(t,r,!0)},w.Builder.prototype.requiredField=function(t,r){var i=this.bb.capacity()-t,o=i-this.bb.readInt32(i),u=this.bb.readInt16(o+r)!=0;if(!u)throw new Error("FlatBuffers: field "+r+" must be set")},w.Builder.prototype.startVector=function(t,r,i){this.notNested(),this.vector_num_elems=r,this.prep(w.SIZEOF_INT,t*r),this.prep(i,t*r)},w.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},w.Builder.prototype.createString=function(t){if(t instanceof Uint8Array)var r=t;else for(var r=[],i=0;i<t.length;){var o,u=t.charCodeAt(i++);if(u<55296||u>=56320)o=u;else{var n=t.charCodeAt(i++);o=(u<<10)+n+-56613888}o<128?r.push(o):(o<2048?r.push(o>>6&31|192):(o<65536?r.push(o>>12&15|224):r.push(o>>18&7|240,o>>12&63|128),r.push(o>>6&63|128)),r.push(o&63|128))}this.addInt8(0),this.startVector(1,r.length,1),this.bb.setPosition(this.space-=r.length);for(var i=0,a=this.space,c=this.bb.bytes();i<r.length;i++)c[a++]=r[i];return this.endVector()},w.Builder.prototype.createLong=function(t,r){return w.Long.create(t,r)},w.ByteBuffer=function(t){this.bytes_=t,this.position_=0},w.ByteBuffer.allocate=function(t){return new w.ByteBuffer(new Uint8Array(t))},w.ByteBuffer.prototype.clear=function(){this.position_=0},w.ByteBuffer.prototype.bytes=function(){return this.bytes_},w.ByteBuffer.prototype.position=function(){return this.position_},w.ByteBuffer.prototype.setPosition=function(t){this.position_=t},w.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},w.ByteBuffer.prototype.readInt8=function(t){return this.readUint8(t)<<24>>24},w.ByteBuffer.prototype.readUint8=function(t){return this.bytes_[t]},w.ByteBuffer.prototype.readInt16=function(t){return this.readUint16(t)<<16>>16},w.ByteBuffer.prototype.readUint16=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8},w.ByteBuffer.prototype.readInt32=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24},w.ByteBuffer.prototype.readUint32=function(t){return this.readInt32(t)>>>0},w.ByteBuffer.prototype.readInt64=function(t){return new w.Long(this.readInt32(t),this.readInt32(t+4))},w.ByteBuffer.prototype.readUint64=function(t){return new w.Long(this.readUint32(t),this.readUint32(t+4))},w.ByteBuffer.prototype.readFloat32=function(t){return w.int32[0]=this.readInt32(t),w.float32[0]},w.ByteBuffer.prototype.readFloat64=function(t){return w.int32[w.isLittleEndian?0:1]=this.readInt32(t),w.int32[w.isLittleEndian?1:0]=this.readInt32(t+4),w.float64[0]},w.ByteBuffer.prototype.writeInt8=function(t,r){this.bytes_[t]=r},w.ByteBuffer.prototype.writeUint8=function(t,r){this.bytes_[t]=r},w.ByteBuffer.prototype.writeInt16=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8},w.ByteBuffer.prototype.writeUint16=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8},w.ByteBuffer.prototype.writeInt32=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8,this.bytes_[t+2]=r>>16,this.bytes_[t+3]=r>>24},w.ByteBuffer.prototype.writeUint32=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8,this.bytes_[t+2]=r>>16,this.bytes_[t+3]=r>>24},w.ByteBuffer.prototype.writeInt64=function(t,r){this.writeInt32(t,r.low),this.writeInt32(t+4,r.high)},w.ByteBuffer.prototype.writeUint64=function(t,r){this.writeUint32(t,r.low),this.writeUint32(t+4,r.high)},w.ByteBuffer.prototype.writeFloat32=function(t,r){w.float32[0]=r,this.writeInt32(t,w.int32[0])},w.ByteBuffer.prototype.writeFloat64=function(t,r){w.float64[0]=r,this.writeInt32(t,w.int32[w.isLittleEndian?0:1]),this.writeInt32(t+4,w.int32[w.isLittleEndian?1:0])},w.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+w.SIZEOF_INT+w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var t="",r=0;r<w.FILE_IDENTIFIER_LENGTH;r++)t+=String.fromCharCode(this.readInt8(this.position_+w.SIZEOF_INT+r));return t},w.ByteBuffer.prototype.__offset=function(t,r){var i=t-this.readInt32(t);return r<this.readInt16(i)?this.readInt16(i+r):0},w.ByteBuffer.prototype.__union=function(t,r){return t.bb_pos=r+this.readInt32(r),t.bb=this,t},w.ByteBuffer.prototype.__string=function(t,r){t+=this.readInt32(t);var i=this.readInt32(t),o="",u=0;if(t+=w.SIZEOF_INT,r===w.Encoding.UTF8_BYTES)return this.bytes_.subarray(t,t+i);for(;u<i;){var n,a=this.readUint8(t+u++);if(a<192)n=a;else{var c=this.readUint8(t+u++);if(a<224)n=(a&31)<<6|c&63;else{var p=this.readUint8(t+u++);if(a<240)n=(a&15)<<12|(c&63)<<6|p&63;else{var e=this.readUint8(t+u++);n=(a&7)<<18|(c&63)<<12|(p&63)<<6|e&63}}}n<65536?o+=String.fromCharCode(n):(n-=65536,o+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return o},w.ByteBuffer.prototype.__indirect=function(t){return t+this.readInt32(t)},w.ByteBuffer.prototype.__vector=function(t){return t+this.readInt32(t)+w.SIZEOF_INT},w.ByteBuffer.prototype.__vector_len=function(t){return this.readInt32(t+this.readInt32(t))},w.ByteBuffer.prototype.__has_identifier=function(t){if(t.length!=w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+w.FILE_IDENTIFIER_LENGTH);for(var r=0;r<w.FILE_IDENTIFIER_LENGTH;r++)if(t.charCodeAt(r)!=this.readInt8(this.position_+w.SIZEOF_INT+r))return!1;return!0},w.ByteBuffer.prototype.createLong=function(t,r){return w.Long.create(t,r)}}),F,Pr=O(()=>{wn(),(t=>{(r=>{(i=>{(o=>(o[o.UNDEFINED=0]="UNDEFINED",o[o.FLOAT=1]="FLOAT",o[o.INT=2]="INT",o[o.STRING=3]="STRING",o[o.TENSOR=4]="TENSOR",o[o.GRAPH=5]="GRAPH",o[o.FLOATS=6]="FLOATS",o[o.INTS=7]="INTS",o[o.STRINGS=8]="STRINGS",o[o.TENSORS=9]="TENSORS",o[o.GRAPHS=10]="GRAPHS",o[o.SPARSE_TENSOR=11]="SPARSE_TENSOR",o[o.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(i.AttributeType||={})})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{(o=>(o[o.UNKNOWN=0]="UNKNOWN",o[o.VALUE=1]="VALUE",o[o.PARAM=2]="PARAM"))(i.DimensionValueType||={})})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{(o=>(o[o.UNDEFINED=0]="UNDEFINED",o[o.FLOAT=1]="FLOAT",o[o.UINT8=2]="UINT8",o[o.INT8=3]="INT8",o[o.UINT16=4]="UINT16",o[o.INT16=5]="INT16",o[o.INT32=6]="INT32",o[o.INT64=7]="INT64",o[o.STRING=8]="STRING",o[o.BOOL=9]="BOOL",o[o.FLOAT16=10]="FLOAT16",o[o.DOUBLE=11]="DOUBLE",o[o.UINT32=12]="UINT32",o[o.UINT64=13]="UINT64",o[o.COMPLEX64=14]="COMPLEX64",o[o.COMPLEX128=15]="COMPLEX128",o[o.BFLOAT16=16]="BFLOAT16",o[o.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",o[o.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",o[o.FLOAT8E5M2=19]="FLOAT8E5M2",o[o.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(i.TensorDataType||={})})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{(o=>(o[o.Primitive=0]="Primitive",o[o.Fused=1]="Fused"))(i.NodeType||={})})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{(o=>(o[o.NONE=0]="NONE",o[o.tensor_type=1]="tensor_type",o[o.sequence_type=2]="sequence_type",o[o.map_type=3]="map_type"))(i.TypeInfoValue||={})})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsShape(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}dim(n,a){let c=this.bb.__offset(this.bb_pos,4);return c?(a||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,a){n.addFieldOffset(0,a,0)}static createDimVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startDimVector(n,a){n.startVector(4,a,4)}static endShape(n){return n.endObject()}static createShape(n,a){return o.startShape(n),o.addDim(n,a),o.endShape(n)}}i.Shape=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimension(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}value(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}denotation(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimension(n){n.startObject(2)}static addValue(n,a){n.addFieldOffset(0,a,0)}static addDenotation(n,a){n.addFieldOffset(1,a,0)}static endDimension(n){return n.endObject()}static createDimension(n,a,c){return o.startDimension(n),o.addValue(n,a),o.addDenotation(n,c),o.endDimension(n)}}i.Dimension=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimensionValue(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):0}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,a){n.addFieldInt8(0,a,0)}static addDimValue(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static addDimParam(n,a){n.addFieldOffset(2,a,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,a,c,p){return o.startDimensionValue(n),o.addDimType(n,a),o.addDimValue(n,c),o.addDimParam(n,p),o.endDimensionValue(n)}}i.DimensionValue=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensorTypeAndShape(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}shape(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,a){n.addFieldInt32(0,a,0)}static addShape(n,a){n.addFieldOffset(1,a,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,a,c){return o.startTensorTypeAndShape(n),o.addElemType(n,a),o.addShape(n,c),o.endTensorTypeAndShape(n)}}i.TensorTypeAndShape=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsMapType(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}valueType(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,a){n.addFieldInt32(0,a,0)}static addValueType(n,a){n.addFieldOffset(1,a,0)}static endMapType(n){return n.endObject()}static createMapType(n,a,c){return o.startMapType(n),o.addKeyType(n,a),o.addValueType(n,c),o.endMapType(n)}}i.MapType=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSequenceType(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,a){n.addFieldOffset(0,a,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,a){return o.startSequenceType(n),o.addElemType(n,a),o.endSequenceType(n)}}i.SequenceType=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(n,a,c,p){return n.prep(4,12),n.writeInt32(p),n.writeInt32(c),n.writeInt32(a),n.offset()}}i.EdgeEnd=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNodeEdge(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,a){let c=this.bb.__offset(this.bb_pos,6);return c?(a||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+c)+n*12,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,a){let c=this.bb.__offset(this.bb_pos,8);return c?(a||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+c)+n*12,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,a){n.addFieldInt32(0,a,0)}static addInputEdges(n,a){n.addFieldOffset(1,a,0)}static startInputEdgesVector(n,a){n.startVector(12,a,4)}static addOutputEdges(n,a){n.addFieldOffset(2,a,0)}static startOutputEdgesVector(n,a){n.startVector(12,a,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,a,c,p){return o.startNodeEdge(n),o.addNodeIndex(n,a),o.addInputEdges(n,c),o.addOutputEdges(n,p),o.endNodeEdge(n)}}i.NodeEdge=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNode(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):0}executionProviderType(n){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__string(this.bb_pos+a,n):null}inputs(n,a){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let c=this.bb.__offset(this.bb_pos,22);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,a){let c=this.bb.__offset(this.bb_pos,24);return c?(a||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.readInt32(this.bb.__vector(this.bb_pos+a)+n*4):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,a){let c=this.bb.__offset(this.bb_pos,28);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+n*4,a):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDomain(n,a){n.addFieldOffset(2,a,0)}static addSinceVersion(n,a){n.addFieldInt32(3,a,0)}static addIndex(n,a){n.addFieldInt32(4,a,0)}static addOpType(n,a){n.addFieldOffset(5,a,0)}static addType(n,a){n.addFieldInt32(6,a,0)}static addExecutionProviderType(n,a){n.addFieldOffset(7,a,0)}static addInputs(n,a){n.addFieldOffset(8,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(9,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addAttributes(n,a){n.addFieldOffset(10,a,0)}static createAttributesVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startAttributesVector(n,a){n.startVector(4,a,4)}static addInputArgCounts(n,a){n.addFieldOffset(11,a,0)}static createInputArgCountsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addInt32(a[c]);return n.endVector()}static startInputArgCountsVector(n,a){n.startVector(4,a,4)}static addImplicitInputs(n,a){n.addFieldOffset(12,a,0)}static createImplicitInputsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startImplicitInputsVector(n,a){n.startVector(4,a,4)}static endNode(n){return n.endObject()}static createNode(n,a,c,p,e,l,s,d,h,g,m,I,_,v){return o.startNode(n),o.addName(n,a),o.addDocString(n,c),o.addDomain(n,p),o.addSinceVersion(n,e),o.addIndex(n,l),o.addOpType(n,s),o.addType(n,d),o.addExecutionProviderType(n,h),o.addInputs(n,g),o.addOutputs(n,m),o.addAttributes(n,I),o.addInputArgCounts(n,_),o.addImplicitInputs(n,v),o.endNode(n)}}i.Node=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsValueInfo(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldOffset(2,a,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,a,c,p){return o.startValueInfo(n),o.addName(n,a),o.addDocString(n,c),o.addType(n,p),o.endValueInfo(n)}}i.ValueInfo=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTypeInfo(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):0}value(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__union(n,this.bb_pos+a):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,a){n.addFieldOffset(0,a,0)}static addValueType(n,a){n.addFieldInt8(1,a,0)}static addValue(n,a){n.addFieldOffset(2,a,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,a,c,p){return o.startTypeInfo(n),o.addDenotation(n,a),o.addValueType(n,c),o.addValue(n,p),o.endTypeInfo(n)}}i.TypeInfo=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsOperatorSetId(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,a){n.addFieldOffset(0,a,0)}static addVersion(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,a,c){return o.startOperatorSetId(n),o.addDomain(n,a),o.addVersion(n,c),o.endOperatorSetId(n)}}i.OperatorSetId=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensor(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}rawData(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint8(this.bb.__vector(this.bb_pos+a)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,a){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+n*4,a):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let c=a.length-1;c>=0;c--)n.addInt64(a[c]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static addDataType(n,a){n.addFieldInt32(3,a,0)}static addRawData(n,a){n.addFieldOffset(4,a,0)}static createRawDataVector(n,a){n.startVector(1,a.length,1);for(let c=a.length-1;c>=0;c--)n.addInt8(a[c]);return n.endVector()}static startRawDataVector(n,a){n.startVector(1,a,1)}static addStringData(n,a){n.addFieldOffset(5,a,0)}static createStringDataVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startStringDataVector(n,a){n.startVector(4,a,4)}static endTensor(n){return n.endObject()}static createTensor(n,a,c,p,e,l,s){return o.startTensor(n),o.addName(n,a),o.addDocString(n,c),o.addDims(n,p),o.addDataType(n,e),o.addRawData(n,l),o.addStringData(n,s),o.endTensor(n)}}i.Tensor=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSparseTensor(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}values(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}indices(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,a){n.addFieldOffset(0,a,0)}static addIndices(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let c=a.length-1;c>=0;c--)n.addInt64(a[c]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,a,c,p){return o.startSparseTensor(n),o.addValues(n,a),o.addIndices(n,c),o.addDims(n,p),o.endSparseTensor(n)}}i.SparseTensor=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsAttribute(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):0}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}t(n){let a=this.bb.__offset(this.bb_pos,16);return a?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}g(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}floats(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.readFloat32(this.bb.__vector(this.bb_pos+a)+n*4):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,a){let c=this.bb.__offset(this.bb_pos,24);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+n*4,a):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,a){let c=this.bb.__offset(this.bb_pos,26);return c?(a||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,a){let c=this.bb.__offset(this.bb_pos,28);return c?(a||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldInt32(2,a,0)}static addF(n,a){n.addFieldFloat32(3,a,0)}static addI(n,a){n.addFieldInt64(4,a,n.createLong(0,0))}static addS(n,a){n.addFieldOffset(5,a,0)}static addT(n,a){n.addFieldOffset(6,a,0)}static addG(n,a){n.addFieldOffset(7,a,0)}static addFloats(n,a){n.addFieldOffset(8,a,0)}static createFloatsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addFloat32(a[c]);return n.endVector()}static startFloatsVector(n,a){n.startVector(4,a,4)}static addInts(n,a){n.addFieldOffset(9,a,0)}static createIntsVector(n,a){n.startVector(8,a.length,8);for(let c=a.length-1;c>=0;c--)n.addInt64(a[c]);return n.endVector()}static startIntsVector(n,a){n.startVector(8,a,8)}static addStrings(n,a){n.addFieldOffset(10,a,0)}static createStringsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startStringsVector(n,a){n.startVector(4,a,4)}static addTensors(n,a){n.addFieldOffset(11,a,0)}static createTensorsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startTensorsVector(n,a){n.startVector(4,a,4)}static addGraphs(n,a){n.addFieldOffset(12,a,0)}static createGraphsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startGraphsVector(n,a){n.startVector(4,a,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,a,c,p,e,l,s,d,h,g,m,I,_,v){return o.startAttribute(n),o.addName(n,a),o.addDocString(n,c),o.addType(n,p),o.addF(n,e),o.addI(n,l),o.addS(n,s),o.addT(n,d),o.addG(n,h),o.addFloats(n,g),o.addInts(n,m),o.addStrings(n,I),o.addTensors(n,_),o.addGraphs(n,v),o.endAttribute(n)}}i.Attribute=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsGraph(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,a){let c=this.bb.__offset(this.bb_pos,4);return c?(a||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,a){let c=this.bb.__offset(this.bb_pos,6);return c?(a||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,a){let c=this.bb.__offset(this.bb_pos,8);return c?(a||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,a){let c=this.bb.__offset(this.bb_pos,12);return c?(a||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,a){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let c=this.bb.__offset(this.bb_pos,16);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,a){let c=this.bb.__offset(this.bb_pos,18);return c?(a||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,a){n.addFieldOffset(0,a,0)}static createInitializersVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startInitializersVector(n,a){n.startVector(4,a,4)}static addNodeArgs(n,a){n.addFieldOffset(1,a,0)}static createNodeArgsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startNodeArgsVector(n,a){n.startVector(4,a,4)}static addNodes(n,a){n.addFieldOffset(2,a,0)}static createNodesVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startNodesVector(n,a){n.startVector(4,a,4)}static addMaxNodeIndex(n,a){n.addFieldInt32(3,a,0)}static addNodeEdges(n,a){n.addFieldOffset(4,a,0)}static createNodeEdgesVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startNodeEdgesVector(n,a){n.startVector(4,a,4)}static addInputs(n,a){n.addFieldOffset(5,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(6,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addSparseInitializers(n,a){n.addFieldOffset(7,a,0)}static createSparseInitializersVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startSparseInitializersVector(n,a){n.startVector(4,a,4)}static endGraph(n){return n.endObject()}static createGraph(n,a,c,p,e,l,s,d,h){return o.startGraph(n),o.addInitializers(n,a),o.addNodeArgs(n,c),o.addNodes(n,p),o.addMaxNodeIndex(n,e),o.addNodeEdges(n,l),o.addInputs(n,s),o.addOutputs(n,d),o.addSparseInitializers(n,h),o.endGraph(n)}}i.Graph=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsModel(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,a){let c=this.bb.__offset(this.bb_pos,6);return c?(a||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}producerVersion(n){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__string(this.bb_pos+a,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__string(this.bb_pos+a,n):null}graph(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}graphDocString(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__string(this.bb_pos+a,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,a){n.addFieldInt64(0,a,n.createLong(0,0))}static addOpsetImport(n,a){n.addFieldOffset(1,a,0)}static createOpsetImportVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startOpsetImportVector(n,a){n.startVector(4,a,4)}static addProducerName(n,a){n.addFieldOffset(2,a,0)}static addProducerVersion(n,a){n.addFieldOffset(3,a,0)}static addDomain(n,a){n.addFieldOffset(4,a,0)}static addModelVersion(n,a){n.addFieldInt64(5,a,n.createLong(0,0))}static addDocString(n,a){n.addFieldOffset(6,a,0)}static addGraph(n,a){n.addFieldOffset(7,a,0)}static addGraphDocString(n,a){n.addFieldOffset(8,a,0)}static endModel(n){return n.endObject()}static createModel(n,a,c,p,e,l,s,d,h,g){return o.startModel(n),o.addIrVersion(n,a),o.addOpsetImport(n,c),o.addProducerName(n,p),o.addProducerVersion(n,e),o.addDomain(n,l),o.addModelVersion(n,s),o.addDocString(n,d),o.addGraph(n,h),o.addGraphDocString(n,g),o.endModel(n)}}i.Model=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsKernelCreateInfos(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb.__vector(this.bb_pos+a)+n*4):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,a){n.addFieldOffset(0,a,0)}static createNodeIndicesVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addInt32(a[c]);return n.endVector()}static startNodeIndicesVector(n,a){n.startVector(4,a,4)}static addKernelDefHashes(n,a){n.addFieldOffset(1,a,0)}static createKernelDefHashesVector(n,a){n.startVector(8,a.length,8);for(let c=a.length-1;c>=0;c--)n.addInt64(a[c]);return n.endVector()}static startKernelDefHashesVector(n,a){n.startVector(8,a,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,a,c){return o.startKernelCreateInfos(n),o.addNodeIndices(n,a),o.addKernelDefHashes(n,c),o.endKernelCreateInfos(n)}}i.KernelCreateInfos=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSubGraphSessionState(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,a){n.addFieldOffset(0,a,0)}static addSessionState(n,a){n.addFieldOffset(1,a,0)}static endSubGraphSessionState(n){let a=n.endObject();return n.requiredField(a,4),a}static createSubGraphSessionState(n,a,c){return o.startSubGraphSessionState(n),o.addGraphId(n,a),o.addSessionState(n,c),o.endSubGraphSessionState(n)}}i.SubGraphSessionState=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSessionState(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}subGraphSessionStates(n,a){let c=this.bb.__offset(this.bb_pos,6);return c?(a||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+n*4),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,a){n.addFieldOffset(0,a,0)}static addSubGraphSessionStates(n,a){n.addFieldOffset(1,a,0)}static createSubGraphSessionStatesVector(n,a){n.startVector(4,a.length,4);for(let c=a.length-1;c>=0;c--)n.addOffset(a[c]);return n.endVector()}static startSubGraphSessionStatesVector(n,a){n.startVector(4,a,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,a,c){return o.startSessionState(n),o.addKernels(n,a),o.addSubGraphSessionStates(n,c),o.endSessionState(n)}}i.SessionState=o})(r.fbs||={})})(t.experimental||={})})(F||={}),(t=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsInferenceSession(n,a){return(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new o).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}model(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,a){n.addFieldOffset(0,a,0)}static addModel(n,a){n.addFieldOffset(1,a,0)}static addSessionState(n,a){n.addFieldOffset(2,a,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,a){n.finish(a,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,a){n.finish(a,"ORTM",!0)}static createInferenceSession(n,a,c,p){return o.startInferenceSession(n),o.addOrtVersion(n,a),o.addModel(n,c),o.addSessionState(n,p),o.endInferenceSession(n)}}i.InferenceSession=o})(r.fbs||={})})(t.experimental||={})})(F||={})}),js=mt((t,r)=>{r.exports=i;function i(o,u){for(var n=new Array(arguments.length-1),a=0,c=2,p=!0;c<arguments.length;)n[a++]=arguments[c++];return new Promise(function(e,l){n[a]=function(s){if(p)if(p=!1,s)l(s);else{for(var d=new Array(arguments.length-1),h=0;h<d.length;)d[h++]=arguments[h];e.apply(null,d)}};try{o.apply(u||null,n)}catch(s){p&&(p=!1,l(s))}})}}),Ys=mt(t=>{var r=t;r.length=function(a){var c=a.length;if(!c)return 0;for(var p=0;--c%4>1&&a.charAt(c)==="=";)++p;return Math.ceil(a.length*3)/4-p};var i=new Array(64),o=new Array(123);for(u=0;u<64;)o[i[u]=u<26?u+65:u<52?u+71:u<62?u-4:u-59|43]=u++;var u;r.encode=function(a,c,p){for(var e=null,l=[],s=0,d=0,h;c<p;){var g=a[c++];switch(d){case 0:l[s++]=i[g>>2],h=(g&3)<<4,d=1;break;case 1:l[s++]=i[h|g>>4],h=(g&15)<<2,d=2;break;case 2:l[s++]=i[h|g>>6],l[s++]=i[g&63],d=0;break}s>8191&&((e||(e=[])).push(String.fromCharCode.apply(String,l)),s=0)}return d&&(l[s++]=i[h],l[s++]=61,d===1&&(l[s++]=61)),e?(s&&e.push(String.fromCharCode.apply(String,l.slice(0,s))),e.join("")):String.fromCharCode.apply(String,l.slice(0,s))};var n="invalid encoding";r.decode=function(a,c,p){for(var e=p,l=0,s,d=0;d<a.length;){var h=a.charCodeAt(d++);if(h===61&&l>1)break;if((h=o[h])===void 0)throw Error(n);switch(l){case 0:s=h,l=1;break;case 1:c[p++]=s<<2|(h&48)>>4,s=h,l=2;break;case 2:c[p++]=(s&15)<<4|(h&60)>>2,s=h,l=3;break;case 3:c[p++]=(s&3)<<6|h,l=0;break}}if(l===1)throw Error(n);return p-e},r.test=function(a){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a)}}),Qs=mt((t,r)=>{r.exports=i;function i(){this._listeners={}}i.prototype.on=function(o,u,n){return(this._listeners[o]||(this._listeners[o]=[])).push({fn:u,ctx:n||this}),this},i.prototype.off=function(o,u){if(o===void 0)this._listeners={};else if(u===void 0)this._listeners[o]=[];else for(var n=this._listeners[o],a=0;a<n.length;)n[a].fn===u?n.splice(a,1):++a;return this},i.prototype.emit=function(o){var u=this._listeners[o];if(u){for(var n=[],a=1;a<arguments.length;)n.push(arguments[a++]);for(a=0;a<u.length;)u[a].fn.apply(u[a++].ctx,n)}return this}}),au=mt((t,r)=>{r.exports=i(i);function i(c){return typeof Float32Array<"u"?(function(){var p=new Float32Array([-0]),e=new Uint8Array(p.buffer),l=e[3]===128;function s(m,I,_){p[0]=m,I[_]=e[0],I[_+1]=e[1],I[_+2]=e[2],I[_+3]=e[3]}function d(m,I,_){p[0]=m,I[_]=e[3],I[_+1]=e[2],I[_+2]=e[1],I[_+3]=e[0]}c.writeFloatLE=l?s:d,c.writeFloatBE=l?d:s;function h(m,I){return e[0]=m[I],e[1]=m[I+1],e[2]=m[I+2],e[3]=m[I+3],p[0]}function g(m,I){return e[3]=m[I],e[2]=m[I+1],e[1]=m[I+2],e[0]=m[I+3],p[0]}c.readFloatLE=l?h:g,c.readFloatBE=l?g:h})():(function(){function p(l,s,d,h){var g=s<0?1:0;if(g&&(s=-s),s===0)l(1/s>0?0:2147483648,d,h);else if(isNaN(s))l(2143289344,d,h);else if(s>34028234663852886e22)l((g<<31|2139095040)>>>0,d,h);else if(s<11754943508222875e-54)l((g<<31|Math.round(s/1401298464324817e-60))>>>0,d,h);else{var m=Math.floor(Math.log(s)/Math.LN2),I=Math.round(s*Math.pow(2,-m)*8388608)&8388607;l((g<<31|m+127<<23|I)>>>0,d,h)}}c.writeFloatLE=p.bind(null,o),c.writeFloatBE=p.bind(null,u);function e(l,s,d){var h=l(s,d),g=(h>>31)*2+1,m=h>>>23&255,I=h&8388607;return m===255?I?NaN:g*(1/0):m===0?g*1401298464324817e-60*I:g*Math.pow(2,m-150)*(I+8388608)}c.readFloatLE=e.bind(null,n),c.readFloatBE=e.bind(null,a)})(),typeof Float64Array<"u"?(function(){var p=new Float64Array([-0]),e=new Uint8Array(p.buffer),l=e[7]===128;function s(m,I,_){p[0]=m,I[_]=e[0],I[_+1]=e[1],I[_+2]=e[2],I[_+3]=e[3],I[_+4]=e[4],I[_+5]=e[5],I[_+6]=e[6],I[_+7]=e[7]}function d(m,I,_){p[0]=m,I[_]=e[7],I[_+1]=e[6],I[_+2]=e[5],I[_+3]=e[4],I[_+4]=e[3],I[_+5]=e[2],I[_+6]=e[1],I[_+7]=e[0]}c.writeDoubleLE=l?s:d,c.writeDoubleBE=l?d:s;function h(m,I){return e[0]=m[I],e[1]=m[I+1],e[2]=m[I+2],e[3]=m[I+3],e[4]=m[I+4],e[5]=m[I+5],e[6]=m[I+6],e[7]=m[I+7],p[0]}function g(m,I){return e[7]=m[I],e[6]=m[I+1],e[5]=m[I+2],e[4]=m[I+3],e[3]=m[I+4],e[2]=m[I+5],e[1]=m[I+6],e[0]=m[I+7],p[0]}c.readDoubleLE=l?h:g,c.readDoubleBE=l?g:h})():(function(){function p(l,s,d,h,g,m){var I=h<0?1:0;if(I&&(h=-h),h===0)l(0,g,m+s),l(1/h>0?0:2147483648,g,m+d);else if(isNaN(h))l(0,g,m+s),l(2146959360,g,m+d);else if(h>17976931348623157e292)l(0,g,m+s),l((I<<31|2146435072)>>>0,g,m+d);else{var _;if(h<22250738585072014e-324)_=h/5e-324,l(_>>>0,g,m+s),l((I<<31|_/4294967296)>>>0,g,m+d);else{var v=Math.floor(Math.log(h)/Math.LN2);v===1024&&(v=1023),_=h*Math.pow(2,-v),l(_*4503599627370496>>>0,g,m+s),l((I<<31|v+1023<<20|_*1048576&1048575)>>>0,g,m+d)}}}c.writeDoubleLE=p.bind(null,o,0,4),c.writeDoubleBE=p.bind(null,u,4,0);function e(l,s,d,h,g){var m=l(h,g+s),I=l(h,g+d),_=(I>>31)*2+1,v=I>>>20&2047,S=4294967296*(I&1048575)+m;return v===2047?S?NaN:_*(1/0):v===0?_*5e-324*S:_*Math.pow(2,v-1075)*(S+4503599627370496)}c.readDoubleLE=e.bind(null,n,0,4),c.readDoubleBE=e.bind(null,a,4,0)})(),c}function o(c,p,e){p[e]=c&255,p[e+1]=c>>>8&255,p[e+2]=c>>>16&255,p[e+3]=c>>>24}function u(c,p,e){p[e]=c>>>24,p[e+1]=c>>>16&255,p[e+2]=c>>>8&255,p[e+3]=c&255}function n(c,p){return(c[p]|c[p+1]<<8|c[p+2]<<16|c[p+3]<<24)>>>0}function a(c,p){return(c[p]<<24|c[p+1]<<16|c[p+2]<<8|c[p+3])>>>0}}),su=mt((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}}),lu=mt(t=>{var r=t;r.length=function(i){for(var o=0,u=0,n=0;n<i.length;++n)u=i.charCodeAt(n),u<128?o+=1:u<2048?o+=2:(u&64512)===55296&&(i.charCodeAt(n+1)&64512)===56320?(++n,o+=4):o+=3;return o},r.read=function(i,o,u){var n=u-o;if(n<1)return"";for(var a=null,c=[],p=0,e;o<u;)e=i[o++],e<128?c[p++]=e:e>191&&e<224?c[p++]=(e&31)<<6|i[o++]&63:e>239&&e<365?(e=((e&7)<<18|(i[o++]&63)<<12|(i[o++]&63)<<6|i[o++]&63)-65536,c[p++]=55296+(e>>10),c[p++]=56320+(e&1023)):c[p++]=(e&15)<<12|(i[o++]&63)<<6|i[o++]&63,p>8191&&((a||(a=[])).push(String.fromCharCode.apply(String,c)),p=0);return a?(p&&a.push(String.fromCharCode.apply(String,c.slice(0,p))),a.join("")):String.fromCharCode.apply(String,c.slice(0,p))},r.write=function(i,o,u){for(var n=u,a,c,p=0;p<i.length;++p)a=i.charCodeAt(p),a<128?o[u++]=a:a<2048?(o[u++]=a>>6|192,o[u++]=a&63|128):(a&64512)===55296&&((c=i.charCodeAt(p+1))&64512)===56320?(a=65536+((a&1023)<<10)+(c&1023),++p,o[u++]=a>>18|240,o[u++]=a>>12&63|128,o[u++]=a>>6&63|128,o[u++]=a&63|128):(o[u++]=a>>12|224,o[u++]=a>>6&63|128,o[u++]=a&63|128);return u-n}}),cu=mt((t,r)=>{r.exports=i;function i(o,u,n){var a=n||8192,c=a>>>1,p=null,e=a;return function(l){if(l<1||l>c)return o(l);e+l>a&&(p=o(a),e=0);var s=u.call(p,e,e+=l);return e&7&&(e=(e|7)+1),s}}}),du=mt((t,r)=>{r.exports=o;var i=Se();function o(c,p){this.lo=c>>>0,this.hi=p>>>0}var u=o.zero=new o(0,0);u.toNumber=function(){return 0},u.zzEncode=u.zzDecode=function(){return this},u.length=function(){return 1};var n=o.zeroHash="\0\0\0\0\0\0\0\0";o.fromNumber=function(c){if(c===0)return u;var p=c<0;p&&(c=-c);var e=c>>>0,l=(c-e)/4294967296>>>0;return p&&(l=~l>>>0,e=~e>>>0,++e>4294967295&&(e=0,++l>4294967295&&(l=0))),new o(e,l)},o.from=function(c){if(typeof c=="number")return o.fromNumber(c);if(i.isString(c))if(i.Long)c=i.Long.fromString(c);else return o.fromNumber(parseInt(c,10));return c.low||c.high?new o(c.low>>>0,c.high>>>0):u},o.prototype.toNumber=function(c){if(!c&&this.hi>>>31){var p=~this.lo+1>>>0,e=~this.hi>>>0;return p||(e=e+1>>>0),-(p+e*4294967296)}return this.lo+this.hi*4294967296},o.prototype.toLong=function(c){return i.Long?new i.Long(this.lo|0,this.hi|0,!!c):{low:this.lo|0,high:this.hi|0,unsigned:!!c}};var a=String.prototype.charCodeAt;o.fromHash=function(c){return c===n?u:new o((a.call(c,0)|a.call(c,1)<<8|a.call(c,2)<<16|a.call(c,3)<<24)>>>0,(a.call(c,4)|a.call(c,5)<<8|a.call(c,6)<<16|a.call(c,7)<<24)>>>0)},o.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},o.prototype.zzEncode=function(){var c=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^c)>>>0,this.lo=(this.lo<<1^c)>>>0,this},o.prototype.zzDecode=function(){var c=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^c)>>>0,this.hi=(this.hi>>>1^c)>>>0,this},o.prototype.length=function(){var c=this.lo,p=(this.lo>>>28|this.hi<<4)>>>0,e=this.hi>>>24;return e===0?p===0?c<16384?c<128?1:2:c<2097152?3:4:p<16384?p<128?5:6:p<2097152?7:8:e<128?9:10}}),Se=mt(t=>{var r=t;r.asPromise=js(),r.base64=Ys(),r.EventEmitter=Qs(),r.float=au(),r.inquire=su(),r.utf8=lu(),r.pool=cu(),r.LongBits=du(),r.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||t,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(u){return typeof u=="number"&&isFinite(u)&&Math.floor(u)===u},r.isString=function(u){return typeof u=="string"||u instanceof String},r.isObject=function(u){return u&&typeof u=="object"},r.isset=r.isSet=function(u,n){var a=u[n];return a!=null&&u.hasOwnProperty(n)?typeof a!="object"||(Array.isArray(a)?a.length:Object.keys(a).length)>0:!1},r.Buffer=(function(){try{var u=r.inquire("buffer").Buffer;return u.prototype.utf8Write?u:null}catch{return null}})(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(u){return typeof u=="number"?r.Buffer?r._Buffer_allocUnsafe(u):new r.Array(u):r.Buffer?r._Buffer_from(u):typeof Uint8Array>"u"?u:new Uint8Array(u)},r.Array=typeof Uint8Array<"u"?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(u){return u?r.LongBits.from(u).toHash():r.LongBits.zeroHash},r.longFromHash=function(u,n){var a=r.LongBits.fromHash(u);return r.Long?r.Long.fromBits(a.lo,a.hi,n):a.toNumber(!!n)};function i(u,n,a){for(var c=Object.keys(n),p=0;p<c.length;++p)(u[c[p]]===void 0||!a)&&(u[c[p]]=n[c[p]]);return u}r.merge=i,r.lcFirst=function(u){return u.charAt(0).toLowerCase()+u.substring(1)};function o(u){function n(a,c){if(!(this instanceof n))return new n(a,c);Object.defineProperty(this,"message",{get:function(){return a}}),Error.captureStackTrace?Error.captureStackTrace(this,n):Object.defineProperty(this,"stack",{value:new Error().stack||""}),c&&i(this,c)}return n.prototype=Object.create(Error.prototype,{constructor:{value:n,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return u},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),n}r.newError=o,r.ProtocolError=o("ProtocolError"),r.oneOfGetter=function(u){for(var n={},a=0;a<u.length;++a)n[u[a]]=1;return function(){for(var c=Object.keys(this),p=c.length-1;p>-1;--p)if(n[c[p]]===1&&this[c[p]]!==void 0&&this[c[p]]!==null)return c[p]}},r.oneOfSetter=function(u){return function(n){for(var a=0;a<u.length;++a)u[a]!==n&&delete this[u[a]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var u=r.Buffer;if(!u){r._Buffer_from=r._Buffer_allocUnsafe=null;return}r._Buffer_from=u.from!==Uint8Array.from&&u.from||function(n,a){return new u(n,a)},r._Buffer_allocUnsafe=u.allocUnsafe||function(n){return new u(n)}}}),ei=mt((t,r)=>{r.exports=l;var i=Se(),o,u=i.LongBits,n=i.base64,a=i.utf8;function c(v,S,E){this.fn=v,this.len=S,this.next=void 0,this.val=E}function p(){}function e(v){this.head=v.head,this.tail=v.tail,this.len=v.len,this.next=v.states}function l(){this.len=0,this.head=new c(p,0,0),this.tail=this.head,this.states=null}var s=function(){return i.Buffer?function(){return(l.create=function(){return new o})()}:function(){return new l}};l.create=s(),l.alloc=function(v){return new i.Array(v)},i.Array!==Array&&(l.alloc=i.pool(l.alloc,i.Array.prototype.subarray)),l.prototype._push=function(v,S,E){return this.tail=this.tail.next=new c(v,S,E),this.len+=S,this};function d(v,S,E){S[E]=v&255}function h(v,S,E){for(;v>127;)S[E++]=v&127|128,v>>>=7;S[E]=v}function g(v,S){this.len=v,this.next=void 0,this.val=S}g.prototype=Object.create(c.prototype),g.prototype.fn=h,l.prototype.uint32=function(v){return this.len+=(this.tail=this.tail.next=new g((v=v>>>0)<128?1:v<16384?2:v<2097152?3:v<268435456?4:5,v)).len,this},l.prototype.int32=function(v){return v<0?this._push(m,10,u.fromNumber(v)):this.uint32(v)},l.prototype.sint32=function(v){return this.uint32((v<<1^v>>31)>>>0)};function m(v,S,E){for(;v.hi;)S[E++]=v.lo&127|128,v.lo=(v.lo>>>7|v.hi<<25)>>>0,v.hi>>>=7;for(;v.lo>127;)S[E++]=v.lo&127|128,v.lo=v.lo>>>7;S[E++]=v.lo}l.prototype.uint64=function(v){var S=u.from(v);return this._push(m,S.length(),S)},l.prototype.int64=l.prototype.uint64,l.prototype.sint64=function(v){var S=u.from(v).zzEncode();return this._push(m,S.length(),S)},l.prototype.bool=function(v){return this._push(d,1,v?1:0)};function I(v,S,E){S[E]=v&255,S[E+1]=v>>>8&255,S[E+2]=v>>>16&255,S[E+3]=v>>>24}l.prototype.fixed32=function(v){return this._push(I,4,v>>>0)},l.prototype.sfixed32=l.prototype.fixed32,l.prototype.fixed64=function(v){var S=u.from(v);return this._push(I,4,S.lo)._push(I,4,S.hi)},l.prototype.sfixed64=l.prototype.fixed64,l.prototype.float=function(v){return this._push(i.float.writeFloatLE,4,v)},l.prototype.double=function(v){return this._push(i.float.writeDoubleLE,8,v)};var _=i.Array.prototype.set?function(v,S,E){S.set(v,E)}:function(v,S,E){for(var $=0;$<v.length;++$)S[E+$]=v[$]};l.prototype.bytes=function(v){var S=v.length>>>0;if(!S)return this._push(d,1,0);if(i.isString(v)){var E=l.alloc(S=n.length(v));n.decode(v,E,0),v=E}return this.uint32(S)._push(_,S,v)},l.prototype.string=function(v){var S=a.length(v);return S?this.uint32(S)._push(a.write,S,v):this._push(d,1,0)},l.prototype.fork=function(){return this.states=new e(this),this.head=this.tail=new c(p,0,0),this.len=0,this},l.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new c(p,0,0),this.len=0),this},l.prototype.ldelim=function(){var v=this.head,S=this.tail,E=this.len;return this.reset().uint32(E),E&&(this.tail.next=v.next,this.tail=S,this.len+=E),this},l.prototype.finish=function(){for(var v=this.head.next,S=this.constructor.alloc(this.len),E=0;v;)v.fn(v.val,S,E),E+=v.len,v=v.next;return S},l._configure=function(v){o=v,l.create=s(),o._configure()}}),vu=mt((t,r)=>{r.exports=u;var i=ei();(u.prototype=Object.create(i.prototype)).constructor=u;var o=Se();function u(){i.call(this)}u._configure=function(){u.alloc=o._Buffer_allocUnsafe,u.writeBytesBuffer=o.Buffer&&o.Buffer.prototype instanceof Uint8Array&&o.Buffer.prototype.set.name==="set"?function(a,c,p){c.set(a,p)}:function(a,c,p){if(a.copy)a.copy(c,p,0,a.length);else for(var e=0;e<a.length;)c[p++]=a[e++]}},u.prototype.bytes=function(a){o.isString(a)&&(a=o._Buffer_from(a,"base64"));var c=a.length>>>0;return this.uint32(c),c&&this._push(u.writeBytesBuffer,c,a),this};function n(a,c,p){a.length<40?o.utf8.write(a,c,p):c.utf8Write?c.utf8Write(a,p):c.write(a,p)}u.prototype.string=function(a){var c=o.Buffer.byteLength(a);return this.uint32(c),c&&this._push(n,c,a),this},u._configure()}),oi=mt((t,r)=>{r.exports=c;var i=Se(),o,u=i.LongBits,n=i.utf8;function a(h,g){return RangeError("index out of range: "+h.pos+" + "+(g||1)+" > "+h.len)}function c(h){this.buf=h,this.pos=0,this.len=h.length}var p=typeof Uint8Array<"u"?function(h){if(h instanceof Uint8Array||Array.isArray(h))return new c(h);throw Error("illegal buffer")}:function(h){if(Array.isArray(h))return new c(h);throw Error("illegal buffer")},e=function(){return i.Buffer?function(h){return(c.create=function(g){return i.Buffer.isBuffer(g)?new o(g):p(g)})(h)}:p};c.create=e(),c.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,c.prototype.uint32=(function(){var h=4294967295;return function(){if(h=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(h=(h|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return h;if((this.pos+=5)>this.len)throw this.pos=this.len,a(this,10);return h}})(),c.prototype.int32=function(){return this.uint32()|0},c.prototype.sint32=function(){var h=this.uint32();return h>>>1^-(h&1)|0};function l(){var h=new u(0,0),g=0;if(this.len-this.pos>4){for(;g<4;++g)if(h.lo=(h.lo|(this.buf[this.pos]&127)<<g*7)>>>0,this.buf[this.pos++]<128)return h;if(h.lo=(h.lo|(this.buf[this.pos]&127)<<28)>>>0,h.hi=(h.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return h;g=0}else{for(;g<3;++g){if(this.pos>=this.len)throw a(this);if(h.lo=(h.lo|(this.buf[this.pos]&127)<<g*7)>>>0,this.buf[this.pos++]<128)return h}return h.lo=(h.lo|(this.buf[this.pos++]&127)<<g*7)>>>0,h}if(this.len-this.pos>4){for(;g<5;++g)if(h.hi=(h.hi|(this.buf[this.pos]&127)<<g*7+3)>>>0,this.buf[this.pos++]<128)return h}else for(;g<5;++g){if(this.pos>=this.len)throw a(this);if(h.hi=(h.hi|(this.buf[this.pos]&127)<<g*7+3)>>>0,this.buf[this.pos++]<128)return h}throw Error("invalid varint encoding")}c.prototype.bool=function(){return this.uint32()!==0};function s(h,g){return(h[g-4]|h[g-3]<<8|h[g-2]<<16|h[g-1]<<24)>>>0}c.prototype.fixed32=function(){if(this.pos+4>this.len)throw a(this,4);return s(this.buf,this.pos+=4)},c.prototype.sfixed32=function(){if(this.pos+4>this.len)throw a(this,4);return s(this.buf,this.pos+=4)|0};function d(){if(this.pos+8>this.len)throw a(this,8);return new u(s(this.buf,this.pos+=4),s(this.buf,this.pos+=4))}c.prototype.float=function(){if(this.pos+4>this.len)throw a(this,4);var h=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,h},c.prototype.double=function(){if(this.pos+8>this.len)throw a(this,4);var h=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,h},c.prototype.bytes=function(){var h=this.uint32(),g=this.pos,m=this.pos+h;if(m>this.len)throw a(this,h);if(this.pos+=h,Array.isArray(this.buf))return this.buf.slice(g,m);if(g===m){var I=i.Buffer;return I?I.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,g,m)},c.prototype.string=function(){var h=this.bytes();return n.read(h,0,h.length)},c.prototype.skip=function(h){if(typeof h=="number"){if(this.pos+h>this.len)throw a(this,h);this.pos+=h}else do if(this.pos>=this.len)throw a(this);while(this.buf[this.pos++]&128);return this},c.prototype.skipType=function(h){switch(h){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(h=this.uint32()&7)!==4;)this.skipType(h);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+h+" at offset "+this.pos)}return this},c._configure=function(h){o=h,c.create=e(),o._configure();var g=i.Long?"toLong":"toNumber";i.merge(c.prototype,{int64:function(){return l.call(this)[g](!1)},uint64:function(){return l.call(this)[g](!0)},sint64:function(){return l.call(this).zzDecode()[g](!1)},fixed64:function(){return d.call(this)[g](!0)},sfixed64:function(){return d.call(this)[g](!1)}})}}),Lu=mt((t,r)=>{r.exports=u;var i=oi();(u.prototype=Object.create(i.prototype)).constructor=u;var o=Se();function u(n){i.call(this,n)}u._configure=function(){o.Buffer&&(u.prototype._slice=o.Buffer.prototype.slice)},u.prototype.string=function(){var n=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+n,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+n,this.len))},u._configure()}),ku=mt((t,r)=>{r.exports=o;var i=Se();(o.prototype=Object.create(i.EventEmitter.prototype)).constructor=o;function o(u,n,a){if(typeof u!="function")throw TypeError("rpcImpl must be a function");i.EventEmitter.call(this),this.rpcImpl=u,this.requestDelimited=!!n,this.responseDelimited=!!a}o.prototype.rpcCall=function u(n,a,c,p,e){if(!p)throw TypeError("request must be specified");var l=this;if(!e)return i.asPromise(u,l,n,a,c,p);if(!l.rpcImpl){setTimeout(function(){e(Error("already ended"))},0);return}try{return l.rpcImpl(n,a[l.requestDelimited?"encodeDelimited":"encode"](p).finish(),function(s,d){if(s)return l.emit("error",s,n),e(s);if(d===null){l.end(!0);return}if(!(d instanceof c))try{d=c[l.responseDelimited?"decodeDelimited":"decode"](d)}catch(h){return l.emit("error",h,n),e(h)}return l.emit("data",d,n),e(null,d)})}catch(s){l.emit("error",s,n),setTimeout(function(){e(s)},0);return}},o.prototype.end=function(u){return this.rpcImpl&&(u||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Fu=mt(t=>{var r=t;r.Service=ku()}),Nu=mt((t,r)=>{r.exports={}}),Mu=mt(t=>{var r=t;r.build="minimal",r.Writer=ei(),r.BufferWriter=vu(),r.Reader=oi(),r.BufferReader=Lu(),r.util=Se(),r.rpc=Fu(),r.roots=Nu(),r.configure=i;function i(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}i()}),Vu=mt((t,r)=>{r.exports=Mu()}),sr=mt((t,r)=>{var i=Vu(),o=i.Reader,u=i.Writer,n=i.util,a=i.roots.default||(i.roots.default={});a.onnx=(function(){var c={};return c.Version=(function(){var p={},e=Object.create(p);return e[p[0]="_START_VERSION"]=0,e[p[1]="IR_VERSION_2017_10_10"]=1,e[p[2]="IR_VERSION_2017_10_30"]=2,e[p[3]="IR_VERSION_2017_11_3"]=3,e[p[4]="IR_VERSION_2019_1_22"]=4,e[p[5]="IR_VERSION_2019_3_18"]=5,e[p[6]="IR_VERSION_2019_9_19"]=6,e[p[7]="IR_VERSION_2020_5_8"]=7,e[p[8]="IR_VERSION_2021_7_30"]=8,e[p[9]="IR_VERSION"]=9,e})(),c.AttributeProto=(function(){function p(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.name="",p.prototype.refAttrName="",p.prototype.docString="",p.prototype.type=0,p.prototype.f=0,p.prototype.i=n.Long?n.Long.fromBits(0,0,!1):0,p.prototype.s=n.newBuffer([]),p.prototype.t=null,p.prototype.g=null,p.prototype.sparseTensor=null,p.prototype.tp=null,p.prototype.floats=n.emptyArray,p.prototype.ints=n.emptyArray,p.prototype.strings=n.emptyArray,p.prototype.tensors=n.emptyArray,p.prototype.graphs=n.emptyArray,p.prototype.sparseTensors=n.emptyArray,p.prototype.typeProtos=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&l.uint32(10).string(e.name),e.f!=null&&Object.hasOwnProperty.call(e,"f")&&l.uint32(21).float(e.f),e.i!=null&&Object.hasOwnProperty.call(e,"i")&&l.uint32(24).int64(e.i),e.s!=null&&Object.hasOwnProperty.call(e,"s")&&l.uint32(34).bytes(e.s),e.t!=null&&Object.hasOwnProperty.call(e,"t")&&a.onnx.TensorProto.encode(e.t,l.uint32(42).fork()).ldelim(),e.g!=null&&Object.hasOwnProperty.call(e,"g")&&a.onnx.GraphProto.encode(e.g,l.uint32(50).fork()).ldelim(),e.floats!=null&&e.floats.length){l.uint32(58).fork();for(var s=0;s<e.floats.length;++s)l.float(e.floats[s]);l.ldelim()}if(e.ints!=null&&e.ints.length){l.uint32(66).fork();for(var s=0;s<e.ints.length;++s)l.int64(e.ints[s]);l.ldelim()}if(e.strings!=null&&e.strings.length)for(var s=0;s<e.strings.length;++s)l.uint32(74).bytes(e.strings[s]);if(e.tensors!=null&&e.tensors.length)for(var s=0;s<e.tensors.length;++s)a.onnx.TensorProto.encode(e.tensors[s],l.uint32(82).fork()).ldelim();if(e.graphs!=null&&e.graphs.length)for(var s=0;s<e.graphs.length;++s)a.onnx.GraphProto.encode(e.graphs[s],l.uint32(90).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&l.uint32(106).string(e.docString),e.tp!=null&&Object.hasOwnProperty.call(e,"tp")&&a.onnx.TypeProto.encode(e.tp,l.uint32(114).fork()).ldelim(),e.typeProtos!=null&&e.typeProtos.length)for(var s=0;s<e.typeProtos.length;++s)a.onnx.TypeProto.encode(e.typeProtos[s],l.uint32(122).fork()).ldelim();if(e.type!=null&&Object.hasOwnProperty.call(e,"type")&&l.uint32(160).int32(e.type),e.refAttrName!=null&&Object.hasOwnProperty.call(e,"refAttrName")&&l.uint32(170).string(e.refAttrName),e.sparseTensor!=null&&Object.hasOwnProperty.call(e,"sparseTensor")&&a.onnx.SparseTensorProto.encode(e.sparseTensor,l.uint32(178).fork()).ldelim(),e.sparseTensors!=null&&e.sparseTensors.length)for(var s=0;s<e.sparseTensors.length;++s)a.onnx.SparseTensorProto.encode(e.sparseTensors[s],l.uint32(186).fork()).ldelim();return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.AttributeProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.name=e.string();break}case 21:{d.refAttrName=e.string();break}case 13:{d.docString=e.string();break}case 20:{d.type=e.int32();break}case 2:{d.f=e.float();break}case 3:{d.i=e.int64();break}case 4:{d.s=e.bytes();break}case 5:{d.t=a.onnx.TensorProto.decode(e,e.uint32());break}case 6:{d.g=a.onnx.GraphProto.decode(e,e.uint32());break}case 22:{d.sparseTensor=a.onnx.SparseTensorProto.decode(e,e.uint32());break}case 14:{d.tp=a.onnx.TypeProto.decode(e,e.uint32());break}case 7:{if(d.floats&&d.floats.length||(d.floats=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.floats.push(e.float());else d.floats.push(e.float());break}case 8:{if(d.ints&&d.ints.length||(d.ints=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.ints.push(e.int64());else d.ints.push(e.int64());break}case 9:{d.strings&&d.strings.length||(d.strings=[]),d.strings.push(e.bytes());break}case 10:{d.tensors&&d.tensors.length||(d.tensors=[]),d.tensors.push(a.onnx.TensorProto.decode(e,e.uint32()));break}case 11:{d.graphs&&d.graphs.length||(d.graphs=[]),d.graphs.push(a.onnx.GraphProto.decode(e,e.uint32()));break}case 23:{d.sparseTensors&&d.sparseTensors.length||(d.sparseTensors=[]),d.sparseTensors.push(a.onnx.SparseTensorProto.decode(e,e.uint32()));break}case 15:{d.typeProtos&&d.typeProtos.length||(d.typeProtos=[]),d.typeProtos.push(a.onnx.TypeProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!n.isString(e.name))return"name: string expected";if(e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&!n.isString(e.refAttrName))return"refAttrName: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!n.isString(e.docString))return"docString: string expected";if(e.type!=null&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(e.f!=null&&e.hasOwnProperty("f")&&typeof e.f!="number")return"f: number expected";if(e.i!=null&&e.hasOwnProperty("i")&&!n.isInteger(e.i)&&!(e.i&&n.isInteger(e.i.low)&&n.isInteger(e.i.high)))return"i: integer|Long expected";if(e.s!=null&&e.hasOwnProperty("s")&&!(e.s&&typeof e.s.length=="number"||n.isString(e.s)))return"s: buffer expected";if(e.t!=null&&e.hasOwnProperty("t")){var l=a.onnx.TensorProto.verify(e.t);if(l)return"t."+l}if(e.g!=null&&e.hasOwnProperty("g")){var l=a.onnx.GraphProto.verify(e.g);if(l)return"g."+l}if(e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")){var l=a.onnx.SparseTensorProto.verify(e.sparseTensor);if(l)return"sparseTensor."+l}if(e.tp!=null&&e.hasOwnProperty("tp")){var l=a.onnx.TypeProto.verify(e.tp);if(l)return"tp."+l}if(e.floats!=null&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var s=0;s<e.floats.length;++s)if(typeof e.floats[s]!="number")return"floats: number[] expected"}if(e.ints!=null&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(var s=0;s<e.ints.length;++s)if(!n.isInteger(e.ints[s])&&!(e.ints[s]&&n.isInteger(e.ints[s].low)&&n.isInteger(e.ints[s].high)))return"ints: integer|Long[] expected"}if(e.strings!=null&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(var s=0;s<e.strings.length;++s)if(!(e.strings[s]&&typeof e.strings[s].length=="number"||n.isString(e.strings[s])))return"strings: buffer[] expected"}if(e.tensors!=null&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(var s=0;s<e.tensors.length;++s){var l=a.onnx.TensorProto.verify(e.tensors[s]);if(l)return"tensors."+l}}if(e.graphs!=null&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(var s=0;s<e.graphs.length;++s){var l=a.onnx.GraphProto.verify(e.graphs[s]);if(l)return"graphs."+l}}if(e.sparseTensors!=null&&e.hasOwnProperty("sparseTensors")){if(!Array.isArray(e.sparseTensors))return"sparseTensors: array expected";for(var s=0;s<e.sparseTensors.length;++s){var l=a.onnx.SparseTensorProto.verify(e.sparseTensors[s]);if(l)return"sparseTensors."+l}}if(e.typeProtos!=null&&e.hasOwnProperty("typeProtos")){if(!Array.isArray(e.typeProtos))return"typeProtos: array expected";for(var s=0;s<e.typeProtos.length;++s){var l=a.onnx.TypeProto.verify(e.typeProtos[s]);if(l)return"typeProtos."+l}}return null},p.fromObject=function(e){if(e instanceof a.onnx.AttributeProto)return e;var l=new a.onnx.AttributeProto;switch(e.name!=null&&(l.name=String(e.name)),e.refAttrName!=null&&(l.refAttrName=String(e.refAttrName)),e.docString!=null&&(l.docString=String(e.docString)),e.type){default:if(typeof e.type=="number"){l.type=e.type;break}break;case"UNDEFINED":case 0:l.type=0;break;case"FLOAT":case 1:l.type=1;break;case"INT":case 2:l.type=2;break;case"STRING":case 3:l.type=3;break;case"TENSOR":case 4:l.type=4;break;case"GRAPH":case 5:l.type=5;break;case"SPARSE_TENSOR":case 11:l.type=11;break;case"TYPE_PROTO":case 13:l.type=13;break;case"FLOATS":case 6:l.type=6;break;case"INTS":case 7:l.type=7;break;case"STRINGS":case 8:l.type=8;break;case"TENSORS":case 9:l.type=9;break;case"GRAPHS":case 10:l.type=10;break;case"SPARSE_TENSORS":case 12:l.type=12;break;case"TYPE_PROTOS":case 14:l.type=14;break}if(e.f!=null&&(l.f=Number(e.f)),e.i!=null&&(n.Long?(l.i=n.Long.fromValue(e.i)).unsigned=!1:typeof e.i=="string"?l.i=parseInt(e.i,10):typeof e.i=="number"?l.i=e.i:typeof e.i=="object"&&(l.i=new n.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),e.s!=null&&(typeof e.s=="string"?n.base64.decode(e.s,l.s=n.newBuffer(n.base64.length(e.s)),0):e.s.length>=0&&(l.s=e.s)),e.t!=null){if(typeof e.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");l.t=a.onnx.TensorProto.fromObject(e.t)}if(e.g!=null){if(typeof e.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");l.g=a.onnx.GraphProto.fromObject(e.g)}if(e.sparseTensor!=null){if(typeof e.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");l.sparseTensor=a.onnx.SparseTensorProto.fromObject(e.sparseTensor)}if(e.tp!=null){if(typeof e.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");l.tp=a.onnx.TypeProto.fromObject(e.tp)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");l.floats=[];for(var s=0;s<e.floats.length;++s)l.floats[s]=Number(e.floats[s])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");l.ints=[];for(var s=0;s<e.ints.length;++s)n.Long?(l.ints[s]=n.Long.fromValue(e.ints[s])).unsigned=!1:typeof e.ints[s]=="string"?l.ints[s]=parseInt(e.ints[s],10):typeof e.ints[s]=="number"?l.ints[s]=e.ints[s]:typeof e.ints[s]=="object"&&(l.ints[s]=new n.LongBits(e.ints[s].low>>>0,e.ints[s].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");l.strings=[];for(var s=0;s<e.strings.length;++s)typeof e.strings[s]=="string"?n.base64.decode(e.strings[s],l.strings[s]=n.newBuffer(n.base64.length(e.strings[s])),0):e.strings[s].length>=0&&(l.strings[s]=e.strings[s])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");l.tensors=[];for(var s=0;s<e.tensors.length;++s){if(typeof e.tensors[s]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");l.tensors[s]=a.onnx.TensorProto.fromObject(e.tensors[s])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");l.graphs=[];for(var s=0;s<e.graphs.length;++s){if(typeof e.graphs[s]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");l.graphs[s]=a.onnx.GraphProto.fromObject(e.graphs[s])}}if(e.sparseTensors){if(!Array.isArray(e.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");l.sparseTensors=[];for(var s=0;s<e.sparseTensors.length;++s){if(typeof e.sparseTensors[s]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");l.sparseTensors[s]=a.onnx.SparseTensorProto.fromObject(e.sparseTensors[s])}}if(e.typeProtos){if(!Array.isArray(e.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");l.typeProtos=[];for(var s=0;s<e.typeProtos.length;++s){if(typeof e.typeProtos[s]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");l.typeProtos[s]=a.onnx.TypeProto.fromObject(e.typeProtos[s])}}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.floats=[],s.ints=[],s.strings=[],s.tensors=[],s.graphs=[],s.typeProtos=[],s.sparseTensors=[]),l.defaults){if(s.name="",s.f=0,n.Long){var d=new n.Long(0,0,!1);s.i=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else s.i=l.longs===String?"0":0;l.bytes===String?s.s="":(s.s=[],l.bytes!==Array&&(s.s=n.newBuffer(s.s))),s.t=null,s.g=null,s.docString="",s.tp=null,s.type=l.enums===String?"UNDEFINED":0,s.refAttrName="",s.sparseTensor=null}if(e.name!=null&&e.hasOwnProperty("name")&&(s.name=e.name),e.f!=null&&e.hasOwnProperty("f")&&(s.f=l.json&&!isFinite(e.f)?String(e.f):e.f),e.i!=null&&e.hasOwnProperty("i")&&(typeof e.i=="number"?s.i=l.longs===String?String(e.i):e.i:s.i=l.longs===String?n.Long.prototype.toString.call(e.i):l.longs===Number?new n.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),e.s!=null&&e.hasOwnProperty("s")&&(s.s=l.bytes===String?n.base64.encode(e.s,0,e.s.length):l.bytes===Array?Array.prototype.slice.call(e.s):e.s),e.t!=null&&e.hasOwnProperty("t")&&(s.t=a.onnx.TensorProto.toObject(e.t,l)),e.g!=null&&e.hasOwnProperty("g")&&(s.g=a.onnx.GraphProto.toObject(e.g,l)),e.floats&&e.floats.length){s.floats=[];for(var h=0;h<e.floats.length;++h)s.floats[h]=l.json&&!isFinite(e.floats[h])?String(e.floats[h]):e.floats[h]}if(e.ints&&e.ints.length){s.ints=[];for(var h=0;h<e.ints.length;++h)typeof e.ints[h]=="number"?s.ints[h]=l.longs===String?String(e.ints[h]):e.ints[h]:s.ints[h]=l.longs===String?n.Long.prototype.toString.call(e.ints[h]):l.longs===Number?new n.LongBits(e.ints[h].low>>>0,e.ints[h].high>>>0).toNumber():e.ints[h]}if(e.strings&&e.strings.length){s.strings=[];for(var h=0;h<e.strings.length;++h)s.strings[h]=l.bytes===String?n.base64.encode(e.strings[h],0,e.strings[h].length):l.bytes===Array?Array.prototype.slice.call(e.strings[h]):e.strings[h]}if(e.tensors&&e.tensors.length){s.tensors=[];for(var h=0;h<e.tensors.length;++h)s.tensors[h]=a.onnx.TensorProto.toObject(e.tensors[h],l)}if(e.graphs&&e.graphs.length){s.graphs=[];for(var h=0;h<e.graphs.length;++h)s.graphs[h]=a.onnx.GraphProto.toObject(e.graphs[h],l)}if(e.docString!=null&&e.hasOwnProperty("docString")&&(s.docString=e.docString),e.tp!=null&&e.hasOwnProperty("tp")&&(s.tp=a.onnx.TypeProto.toObject(e.tp,l)),e.typeProtos&&e.typeProtos.length){s.typeProtos=[];for(var h=0;h<e.typeProtos.length;++h)s.typeProtos[h]=a.onnx.TypeProto.toObject(e.typeProtos[h],l)}if(e.type!=null&&e.hasOwnProperty("type")&&(s.type=l.enums===String?a.onnx.AttributeProto.AttributeType[e.type]===void 0?e.type:a.onnx.AttributeProto.AttributeType[e.type]:e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&(s.refAttrName=e.refAttrName),e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")&&(s.sparseTensor=a.onnx.SparseTensorProto.toObject(e.sparseTensor,l)),e.sparseTensors&&e.sparseTensors.length){s.sparseTensors=[];for(var h=0;h<e.sparseTensors.length;++h)s.sparseTensors[h]=a.onnx.SparseTensorProto.toObject(e.sparseTensors[h],l)}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.AttributeProto"},p.AttributeType=(function(){var e={},l=Object.create(e);return l[e[0]="UNDEFINED"]=0,l[e[1]="FLOAT"]=1,l[e[2]="INT"]=2,l[e[3]="STRING"]=3,l[e[4]="TENSOR"]=4,l[e[5]="GRAPH"]=5,l[e[11]="SPARSE_TENSOR"]=11,l[e[13]="TYPE_PROTO"]=13,l[e[6]="FLOATS"]=6,l[e[7]="INTS"]=7,l[e[8]="STRINGS"]=8,l[e[9]="TENSORS"]=9,l[e[10]="GRAPHS"]=10,l[e[12]="SPARSE_TENSORS"]=12,l[e[14]="TYPE_PROTOS"]=14,l})(),p})(),c.ValueInfoProto=(function(){function p(e){if(e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.name="",p.prototype.type=null,p.prototype.docString="",p.create=function(e){return new p(e)},p.encode=function(e,l){return l||(l=u.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&l.uint32(10).string(e.name),e.type!=null&&Object.hasOwnProperty.call(e,"type")&&a.onnx.TypeProto.encode(e.type,l.uint32(18).fork()).ldelim(),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&l.uint32(26).string(e.docString),l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.ValueInfoProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.name=e.string();break}case 2:{d.type=a.onnx.TypeProto.decode(e,e.uint32());break}case 3:{d.docString=e.string();break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!n.isString(e.name))return"name: string expected";if(e.type!=null&&e.hasOwnProperty("type")){var l=a.onnx.TypeProto.verify(e.type);if(l)return"type."+l}return e.docString!=null&&e.hasOwnProperty("docString")&&!n.isString(e.docString)?"docString: string expected":null},p.fromObject=function(e){if(e instanceof a.onnx.ValueInfoProto)return e;var l=new a.onnx.ValueInfoProto;if(e.name!=null&&(l.name=String(e.name)),e.type!=null){if(typeof e.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");l.type=a.onnx.TypeProto.fromObject(e.type)}return e.docString!=null&&(l.docString=String(e.docString)),l},p.toObject=function(e,l){l||(l={});var s={};return l.defaults&&(s.name="",s.type=null,s.docString=""),e.name!=null&&e.hasOwnProperty("name")&&(s.name=e.name),e.type!=null&&e.hasOwnProperty("type")&&(s.type=a.onnx.TypeProto.toObject(e.type,l)),e.docString!=null&&e.hasOwnProperty("docString")&&(s.docString=e.docString),s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ValueInfoProto"},p})(),c.NodeProto=(function(){function p(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.input=n.emptyArray,p.prototype.output=n.emptyArray,p.prototype.name="",p.prototype.opType="",p.prototype.domain="",p.prototype.attribute=n.emptyArray,p.prototype.docString="",p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.input!=null&&e.input.length)for(var s=0;s<e.input.length;++s)l.uint32(10).string(e.input[s]);if(e.output!=null&&e.output.length)for(var s=0;s<e.output.length;++s)l.uint32(18).string(e.output[s]);if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&l.uint32(26).string(e.name),e.opType!=null&&Object.hasOwnProperty.call(e,"opType")&&l.uint32(34).string(e.opType),e.attribute!=null&&e.attribute.length)for(var s=0;s<e.attribute.length;++s)a.onnx.AttributeProto.encode(e.attribute[s],l.uint32(42).fork()).ldelim();return e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&l.uint32(50).string(e.docString),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&l.uint32(58).string(e.domain),l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.NodeProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.input&&d.input.length||(d.input=[]),d.input.push(e.string());break}case 2:{d.output&&d.output.length||(d.output=[]),d.output.push(e.string());break}case 3:{d.name=e.string();break}case 4:{d.opType=e.string();break}case 7:{d.domain=e.string();break}case 5:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(a.onnx.AttributeProto.decode(e,e.uint32()));break}case 6:{d.docString=e.string();break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var l=0;l<e.input.length;++l)if(!n.isString(e.input[l]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(var l=0;l<e.output.length;++l)if(!n.isString(e.output[l]))return"output: string[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!n.isString(e.name))return"name: string expected";if(e.opType!=null&&e.hasOwnProperty("opType")&&!n.isString(e.opType))return"opType: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!n.isString(e.domain))return"domain: string expected";if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(var l=0;l<e.attribute.length;++l){var s=a.onnx.AttributeProto.verify(e.attribute[l]);if(s)return"attribute."+s}}return e.docString!=null&&e.hasOwnProperty("docString")&&!n.isString(e.docString)?"docString: string expected":null},p.fromObject=function(e){if(e instanceof a.onnx.NodeProto)return e;var l=new a.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");l.input=[];for(var s=0;s<e.input.length;++s)l.input[s]=String(e.input[s])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");l.output=[];for(var s=0;s<e.output.length;++s)l.output[s]=String(e.output[s])}if(e.name!=null&&(l.name=String(e.name)),e.opType!=null&&(l.opType=String(e.opType)),e.domain!=null&&(l.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");l.attribute=[];for(var s=0;s<e.attribute.length;++s){if(typeof e.attribute[s]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");l.attribute[s]=a.onnx.AttributeProto.fromObject(e.attribute[s])}}return e.docString!=null&&(l.docString=String(e.docString)),l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.input=[],s.output=[],s.attribute=[]),l.defaults&&(s.name="",s.opType="",s.docString="",s.domain=""),e.input&&e.input.length){s.input=[];for(var d=0;d<e.input.length;++d)s.input[d]=e.input[d]}if(e.output&&e.output.length){s.output=[];for(var d=0;d<e.output.length;++d)s.output[d]=e.output[d]}if(e.name!=null&&e.hasOwnProperty("name")&&(s.name=e.name),e.opType!=null&&e.hasOwnProperty("opType")&&(s.opType=e.opType),e.attribute&&e.attribute.length){s.attribute=[];for(var d=0;d<e.attribute.length;++d)s.attribute[d]=a.onnx.AttributeProto.toObject(e.attribute[d],l)}return e.docString!=null&&e.hasOwnProperty("docString")&&(s.docString=e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&(s.domain=e.domain),s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.NodeProto"},p})(),c.TrainingInfoProto=(function(){function p(e){if(this.initializationBinding=[],this.updateBinding=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.initialization=null,p.prototype.algorithm=null,p.prototype.initializationBinding=n.emptyArray,p.prototype.updateBinding=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.initialization!=null&&Object.hasOwnProperty.call(e,"initialization")&&a.onnx.GraphProto.encode(e.initialization,l.uint32(10).fork()).ldelim(),e.algorithm!=null&&Object.hasOwnProperty.call(e,"algorithm")&&a.onnx.GraphProto.encode(e.algorithm,l.uint32(18).fork()).ldelim(),e.initializationBinding!=null&&e.initializationBinding.length)for(var s=0;s<e.initializationBinding.length;++s)a.onnx.StringStringEntryProto.encode(e.initializationBinding[s],l.uint32(26).fork()).ldelim();if(e.updateBinding!=null&&e.updateBinding.length)for(var s=0;s<e.updateBinding.length;++s)a.onnx.StringStringEntryProto.encode(e.updateBinding[s],l.uint32(34).fork()).ldelim();return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.TrainingInfoProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.initialization=a.onnx.GraphProto.decode(e,e.uint32());break}case 2:{d.algorithm=a.onnx.GraphProto.decode(e,e.uint32());break}case 3:{d.initializationBinding&&d.initializationBinding.length||(d.initializationBinding=[]),d.initializationBinding.push(a.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 4:{d.updateBinding&&d.updateBinding.length||(d.updateBinding=[]),d.updateBinding.push(a.onnx.StringStringEntryProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.initialization!=null&&e.hasOwnProperty("initialization")){var l=a.onnx.GraphProto.verify(e.initialization);if(l)return"initialization."+l}if(e.algorithm!=null&&e.hasOwnProperty("algorithm")){var l=a.onnx.GraphProto.verify(e.algorithm);if(l)return"algorithm."+l}if(e.initializationBinding!=null&&e.hasOwnProperty("initializationBinding")){if(!Array.isArray(e.initializationBinding))return"initializationBinding: array expected";for(var s=0;s<e.initializationBinding.length;++s){var l=a.onnx.StringStringEntryProto.verify(e.initializationBinding[s]);if(l)return"initializationBinding."+l}}if(e.updateBinding!=null&&e.hasOwnProperty("updateBinding")){if(!Array.isArray(e.updateBinding))return"updateBinding: array expected";for(var s=0;s<e.updateBinding.length;++s){var l=a.onnx.StringStringEntryProto.verify(e.updateBinding[s]);if(l)return"updateBinding."+l}}return null},p.fromObject=function(e){if(e instanceof a.onnx.TrainingInfoProto)return e;var l=new a.onnx.TrainingInfoProto;if(e.initialization!=null){if(typeof e.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");l.initialization=a.onnx.GraphProto.fromObject(e.initialization)}if(e.algorithm!=null){if(typeof e.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");l.algorithm=a.onnx.GraphProto.fromObject(e.algorithm)}if(e.initializationBinding){if(!Array.isArray(e.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");l.initializationBinding=[];for(var s=0;s<e.initializationBinding.length;++s){if(typeof e.initializationBinding[s]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");l.initializationBinding[s]=a.onnx.StringStringEntryProto.fromObject(e.initializationBinding[s])}}if(e.updateBinding){if(!Array.isArray(e.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");l.updateBinding=[];for(var s=0;s<e.updateBinding.length;++s){if(typeof e.updateBinding[s]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");l.updateBinding[s]=a.onnx.StringStringEntryProto.fromObject(e.updateBinding[s])}}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.initializationBinding=[],s.updateBinding=[]),l.defaults&&(s.initialization=null,s.algorithm=null),e.initialization!=null&&e.hasOwnProperty("initialization")&&(s.initialization=a.onnx.GraphProto.toObject(e.initialization,l)),e.algorithm!=null&&e.hasOwnProperty("algorithm")&&(s.algorithm=a.onnx.GraphProto.toObject(e.algorithm,l)),e.initializationBinding&&e.initializationBinding.length){s.initializationBinding=[];for(var d=0;d<e.initializationBinding.length;++d)s.initializationBinding[d]=a.onnx.StringStringEntryProto.toObject(e.initializationBinding[d],l)}if(e.updateBinding&&e.updateBinding.length){s.updateBinding=[];for(var d=0;d<e.updateBinding.length;++d)s.updateBinding[d]=a.onnx.StringStringEntryProto.toObject(e.updateBinding[d],l)}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TrainingInfoProto"},p})(),c.ModelProto=(function(){function p(e){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.irVersion=n.Long?n.Long.fromBits(0,0,!1):0,p.prototype.opsetImport=n.emptyArray,p.prototype.producerName="",p.prototype.producerVersion="",p.prototype.domain="",p.prototype.modelVersion=n.Long?n.Long.fromBits(0,0,!1):0,p.prototype.docString="",p.prototype.graph=null,p.prototype.metadataProps=n.emptyArray,p.prototype.trainingInfo=n.emptyArray,p.prototype.functions=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.irVersion!=null&&Object.hasOwnProperty.call(e,"irVersion")&&l.uint32(8).int64(e.irVersion),e.producerName!=null&&Object.hasOwnProperty.call(e,"producerName")&&l.uint32(18).string(e.producerName),e.producerVersion!=null&&Object.hasOwnProperty.call(e,"producerVersion")&&l.uint32(26).string(e.producerVersion),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&l.uint32(34).string(e.domain),e.modelVersion!=null&&Object.hasOwnProperty.call(e,"modelVersion")&&l.uint32(40).int64(e.modelVersion),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&l.uint32(50).string(e.docString),e.graph!=null&&Object.hasOwnProperty.call(e,"graph")&&a.onnx.GraphProto.encode(e.graph,l.uint32(58).fork()).ldelim(),e.opsetImport!=null&&e.opsetImport.length)for(var s=0;s<e.opsetImport.length;++s)a.onnx.OperatorSetIdProto.encode(e.opsetImport[s],l.uint32(66).fork()).ldelim();if(e.metadataProps!=null&&e.metadataProps.length)for(var s=0;s<e.metadataProps.length;++s)a.onnx.StringStringEntryProto.encode(e.metadataProps[s],l.uint32(114).fork()).ldelim();if(e.trainingInfo!=null&&e.trainingInfo.length)for(var s=0;s<e.trainingInfo.length;++s)a.onnx.TrainingInfoProto.encode(e.trainingInfo[s],l.uint32(162).fork()).ldelim();if(e.functions!=null&&e.functions.length)for(var s=0;s<e.functions.length;++s)a.onnx.FunctionProto.encode(e.functions[s],l.uint32(202).fork()).ldelim();return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.ModelProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.irVersion=e.int64();break}case 8:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(a.onnx.OperatorSetIdProto.decode(e,e.uint32()));break}case 2:{d.producerName=e.string();break}case 3:{d.producerVersion=e.string();break}case 4:{d.domain=e.string();break}case 5:{d.modelVersion=e.int64();break}case 6:{d.docString=e.string();break}case 7:{d.graph=a.onnx.GraphProto.decode(e,e.uint32());break}case 14:{d.metadataProps&&d.metadataProps.length||(d.metadataProps=[]),d.metadataProps.push(a.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 20:{d.trainingInfo&&d.trainingInfo.length||(d.trainingInfo=[]),d.trainingInfo.push(a.onnx.TrainingInfoProto.decode(e,e.uint32()));break}case 25:{d.functions&&d.functions.length||(d.functions=[]),d.functions.push(a.onnx.FunctionProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&!n.isInteger(e.irVersion)&&!(e.irVersion&&n.isInteger(e.irVersion.low)&&n.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var l=0;l<e.opsetImport.length;++l){var s=a.onnx.OperatorSetIdProto.verify(e.opsetImport[l]);if(s)return"opsetImport."+s}}if(e.producerName!=null&&e.hasOwnProperty("producerName")&&!n.isString(e.producerName))return"producerName: string expected";if(e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&!n.isString(e.producerVersion))return"producerVersion: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!n.isString(e.domain))return"domain: string expected";if(e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&!n.isInteger(e.modelVersion)&&!(e.modelVersion&&n.isInteger(e.modelVersion.low)&&n.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!n.isString(e.docString))return"docString: string expected";if(e.graph!=null&&e.hasOwnProperty("graph")){var s=a.onnx.GraphProto.verify(e.graph);if(s)return"graph."+s}if(e.metadataProps!=null&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(var l=0;l<e.metadataProps.length;++l){var s=a.onnx.StringStringEntryProto.verify(e.metadataProps[l]);if(s)return"metadataProps."+s}}if(e.trainingInfo!=null&&e.hasOwnProperty("trainingInfo")){if(!Array.isArray(e.trainingInfo))return"trainingInfo: array expected";for(var l=0;l<e.trainingInfo.length;++l){var s=a.onnx.TrainingInfoProto.verify(e.trainingInfo[l]);if(s)return"trainingInfo."+s}}if(e.functions!=null&&e.hasOwnProperty("functions")){if(!Array.isArray(e.functions))return"functions: array expected";for(var l=0;l<e.functions.length;++l){var s=a.onnx.FunctionProto.verify(e.functions[l]);if(s)return"functions."+s}}return null},p.fromObject=function(e){if(e instanceof a.onnx.ModelProto)return e;var l=new a.onnx.ModelProto;if(e.irVersion!=null&&(n.Long?(l.irVersion=n.Long.fromValue(e.irVersion)).unsigned=!1:typeof e.irVersion=="string"?l.irVersion=parseInt(e.irVersion,10):typeof e.irVersion=="number"?l.irVersion=e.irVersion:typeof e.irVersion=="object"&&(l.irVersion=new n.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");l.opsetImport=[];for(var s=0;s<e.opsetImport.length;++s){if(typeof e.opsetImport[s]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");l.opsetImport[s]=a.onnx.OperatorSetIdProto.fromObject(e.opsetImport[s])}}if(e.producerName!=null&&(l.producerName=String(e.producerName)),e.producerVersion!=null&&(l.producerVersion=String(e.producerVersion)),e.domain!=null&&(l.domain=String(e.domain)),e.modelVersion!=null&&(n.Long?(l.modelVersion=n.Long.fromValue(e.modelVersion)).unsigned=!1:typeof e.modelVersion=="string"?l.modelVersion=parseInt(e.modelVersion,10):typeof e.modelVersion=="number"?l.modelVersion=e.modelVersion:typeof e.modelVersion=="object"&&(l.modelVersion=new n.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),e.docString!=null&&(l.docString=String(e.docString)),e.graph!=null){if(typeof e.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");l.graph=a.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");l.metadataProps=[];for(var s=0;s<e.metadataProps.length;++s){if(typeof e.metadataProps[s]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");l.metadataProps[s]=a.onnx.StringStringEntryProto.fromObject(e.metadataProps[s])}}if(e.trainingInfo){if(!Array.isArray(e.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");l.trainingInfo=[];for(var s=0;s<e.trainingInfo.length;++s){if(typeof e.trainingInfo[s]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");l.trainingInfo[s]=a.onnx.TrainingInfoProto.fromObject(e.trainingInfo[s])}}if(e.functions){if(!Array.isArray(e.functions))throw TypeError(".onnx.ModelProto.functions: array expected");l.functions=[];for(var s=0;s<e.functions.length;++s){if(typeof e.functions[s]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");l.functions[s]=a.onnx.FunctionProto.fromObject(e.functions[s])}}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.opsetImport=[],s.metadataProps=[],s.trainingInfo=[],s.functions=[]),l.defaults){if(n.Long){var d=new n.Long(0,0,!1);s.irVersion=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else s.irVersion=l.longs===String?"0":0;if(s.producerName="",s.producerVersion="",s.domain="",n.Long){var d=new n.Long(0,0,!1);s.modelVersion=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else s.modelVersion=l.longs===String?"0":0;s.docString="",s.graph=null}if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&(typeof e.irVersion=="number"?s.irVersion=l.longs===String?String(e.irVersion):e.irVersion:s.irVersion=l.longs===String?n.Long.prototype.toString.call(e.irVersion):l.longs===Number?new n.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&(s.producerName=e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&(s.producerVersion=e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&(s.domain=e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&(typeof e.modelVersion=="number"?s.modelVersion=l.longs===String?String(e.modelVersion):e.modelVersion:s.modelVersion=l.longs===String?n.Long.prototype.toString.call(e.modelVersion):l.longs===Number?new n.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&(s.docString=e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&(s.graph=a.onnx.GraphProto.toObject(e.graph,l)),e.opsetImport&&e.opsetImport.length){s.opsetImport=[];for(var h=0;h<e.opsetImport.length;++h)s.opsetImport[h]=a.onnx.OperatorSetIdProto.toObject(e.opsetImport[h],l)}if(e.metadataProps&&e.metadataProps.length){s.metadataProps=[];for(var h=0;h<e.metadataProps.length;++h)s.metadataProps[h]=a.onnx.StringStringEntryProto.toObject(e.metadataProps[h],l)}if(e.trainingInfo&&e.trainingInfo.length){s.trainingInfo=[];for(var h=0;h<e.trainingInfo.length;++h)s.trainingInfo[h]=a.onnx.TrainingInfoProto.toObject(e.trainingInfo[h],l)}if(e.functions&&e.functions.length){s.functions=[];for(var h=0;h<e.functions.length;++h)s.functions[h]=a.onnx.FunctionProto.toObject(e.functions[h],l)}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ModelProto"},p})(),c.StringStringEntryProto=(function(){function p(e){if(e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.key="",p.prototype.value="",p.create=function(e){return new p(e)},p.encode=function(e,l){return l||(l=u.create()),e.key!=null&&Object.hasOwnProperty.call(e,"key")&&l.uint32(10).string(e.key),e.value!=null&&Object.hasOwnProperty.call(e,"value")&&l.uint32(18).string(e.value),l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.StringStringEntryProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.key=e.string();break}case 2:{d.value=e.string();break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){return typeof e!="object"||e===null?"object expected":e.key!=null&&e.hasOwnProperty("key")&&!n.isString(e.key)?"key: string expected":e.value!=null&&e.hasOwnProperty("value")&&!n.isString(e.value)?"value: string expected":null},p.fromObject=function(e){if(e instanceof a.onnx.StringStringEntryProto)return e;var l=new a.onnx.StringStringEntryProto;return e.key!=null&&(l.key=String(e.key)),e.value!=null&&(l.value=String(e.value)),l},p.toObject=function(e,l){l||(l={});var s={};return l.defaults&&(s.key="",s.value=""),e.key!=null&&e.hasOwnProperty("key")&&(s.key=e.key),e.value!=null&&e.hasOwnProperty("value")&&(s.value=e.value),s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.StringStringEntryProto"},p})(),c.TensorAnnotation=(function(){function p(e){if(this.quantParameterTensorNames=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.tensorName="",p.prototype.quantParameterTensorNames=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.tensorName!=null&&Object.hasOwnProperty.call(e,"tensorName")&&l.uint32(10).string(e.tensorName),e.quantParameterTensorNames!=null&&e.quantParameterTensorNames.length)for(var s=0;s<e.quantParameterTensorNames.length;++s)a.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[s],l.uint32(18).fork()).ldelim();return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.TensorAnnotation;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.tensorName=e.string();break}case 2:{d.quantParameterTensorNames&&d.quantParameterTensorNames.length||(d.quantParameterTensorNames=[]),d.quantParameterTensorNames.push(a.onnx.StringStringEntryProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.tensorName!=null&&e.hasOwnProperty("tensorName")&&!n.isString(e.tensorName))return"tensorName: string expected";if(e.quantParameterTensorNames!=null&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var l=0;l<e.quantParameterTensorNames.length;++l){var s=a.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[l]);if(s)return"quantParameterTensorNames."+s}}return null},p.fromObject=function(e){if(e instanceof a.onnx.TensorAnnotation)return e;var l=new a.onnx.TensorAnnotation;if(e.tensorName!=null&&(l.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");l.quantParameterTensorNames=[];for(var s=0;s<e.quantParameterTensorNames.length;++s){if(typeof e.quantParameterTensorNames[s]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");l.quantParameterTensorNames[s]=a.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[s])}}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.quantParameterTensorNames=[]),l.defaults&&(s.tensorName=""),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&(s.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){s.quantParameterTensorNames=[];for(var d=0;d<e.quantParameterTensorNames.length;++d)s.quantParameterTensorNames[d]=a.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[d],l)}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorAnnotation"},p})(),c.GraphProto=(function(){function p(e){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.node=n.emptyArray,p.prototype.name="",p.prototype.initializer=n.emptyArray,p.prototype.sparseInitializer=n.emptyArray,p.prototype.docString="",p.prototype.input=n.emptyArray,p.prototype.output=n.emptyArray,p.prototype.valueInfo=n.emptyArray,p.prototype.quantizationAnnotation=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.node!=null&&e.node.length)for(var s=0;s<e.node.length;++s)a.onnx.NodeProto.encode(e.node[s],l.uint32(10).fork()).ldelim();if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&l.uint32(18).string(e.name),e.initializer!=null&&e.initializer.length)for(var s=0;s<e.initializer.length;++s)a.onnx.TensorProto.encode(e.initializer[s],l.uint32(42).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&l.uint32(82).string(e.docString),e.input!=null&&e.input.length)for(var s=0;s<e.input.length;++s)a.onnx.ValueInfoProto.encode(e.input[s],l.uint32(90).fork()).ldelim();if(e.output!=null&&e.output.length)for(var s=0;s<e.output.length;++s)a.onnx.ValueInfoProto.encode(e.output[s],l.uint32(98).fork()).ldelim();if(e.valueInfo!=null&&e.valueInfo.length)for(var s=0;s<e.valueInfo.length;++s)a.onnx.ValueInfoProto.encode(e.valueInfo[s],l.uint32(106).fork()).ldelim();if(e.quantizationAnnotation!=null&&e.quantizationAnnotation.length)for(var s=0;s<e.quantizationAnnotation.length;++s)a.onnx.TensorAnnotation.encode(e.quantizationAnnotation[s],l.uint32(114).fork()).ldelim();if(e.sparseInitializer!=null&&e.sparseInitializer.length)for(var s=0;s<e.sparseInitializer.length;++s)a.onnx.SparseTensorProto.encode(e.sparseInitializer[s],l.uint32(122).fork()).ldelim();return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.GraphProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.node&&d.node.length||(d.node=[]),d.node.push(a.onnx.NodeProto.decode(e,e.uint32()));break}case 2:{d.name=e.string();break}case 5:{d.initializer&&d.initializer.length||(d.initializer=[]),d.initializer.push(a.onnx.TensorProto.decode(e,e.uint32()));break}case 15:{d.sparseInitializer&&d.sparseInitializer.length||(d.sparseInitializer=[]),d.sparseInitializer.push(a.onnx.SparseTensorProto.decode(e,e.uint32()));break}case 10:{d.docString=e.string();break}case 11:{d.input&&d.input.length||(d.input=[]),d.input.push(a.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 12:{d.output&&d.output.length||(d.output=[]),d.output.push(a.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 13:{d.valueInfo&&d.valueInfo.length||(d.valueInfo=[]),d.valueInfo.push(a.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 14:{d.quantizationAnnotation&&d.quantizationAnnotation.length||(d.quantizationAnnotation=[]),d.quantizationAnnotation.push(a.onnx.TensorAnnotation.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var l=0;l<e.node.length;++l){var s=a.onnx.NodeProto.verify(e.node[l]);if(s)return"node."+s}}if(e.name!=null&&e.hasOwnProperty("name")&&!n.isString(e.name))return"name: string expected";if(e.initializer!=null&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(var l=0;l<e.initializer.length;++l){var s=a.onnx.TensorProto.verify(e.initializer[l]);if(s)return"initializer."+s}}if(e.sparseInitializer!=null&&e.hasOwnProperty("sparseInitializer")){if(!Array.isArray(e.sparseInitializer))return"sparseInitializer: array expected";for(var l=0;l<e.sparseInitializer.length;++l){var s=a.onnx.SparseTensorProto.verify(e.sparseInitializer[l]);if(s)return"sparseInitializer."+s}}if(e.docString!=null&&e.hasOwnProperty("docString")&&!n.isString(e.docString))return"docString: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var l=0;l<e.input.length;++l){var s=a.onnx.ValueInfoProto.verify(e.input[l]);if(s)return"input."+s}}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(var l=0;l<e.output.length;++l){var s=a.onnx.ValueInfoProto.verify(e.output[l]);if(s)return"output."+s}}if(e.valueInfo!=null&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(var l=0;l<e.valueInfo.length;++l){var s=a.onnx.ValueInfoProto.verify(e.valueInfo[l]);if(s)return"valueInfo."+s}}if(e.quantizationAnnotation!=null&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var l=0;l<e.quantizationAnnotation.length;++l){var s=a.onnx.TensorAnnotation.verify(e.quantizationAnnotation[l]);if(s)return"quantizationAnnotation."+s}}return null},p.fromObject=function(e){if(e instanceof a.onnx.GraphProto)return e;var l=new a.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");l.node=[];for(var s=0;s<e.node.length;++s){if(typeof e.node[s]!="object")throw TypeError(".onnx.GraphProto.node: object expected");l.node[s]=a.onnx.NodeProto.fromObject(e.node[s])}}if(e.name!=null&&(l.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");l.initializer=[];for(var s=0;s<e.initializer.length;++s){if(typeof e.initializer[s]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");l.initializer[s]=a.onnx.TensorProto.fromObject(e.initializer[s])}}if(e.sparseInitializer){if(!Array.isArray(e.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");l.sparseInitializer=[];for(var s=0;s<e.sparseInitializer.length;++s){if(typeof e.sparseInitializer[s]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");l.sparseInitializer[s]=a.onnx.SparseTensorProto.fromObject(e.sparseInitializer[s])}}if(e.docString!=null&&(l.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");l.input=[];for(var s=0;s<e.input.length;++s){if(typeof e.input[s]!="object")throw TypeError(".onnx.GraphProto.input: object expected");l.input[s]=a.onnx.ValueInfoProto.fromObject(e.input[s])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");l.output=[];for(var s=0;s<e.output.length;++s){if(typeof e.output[s]!="object")throw TypeError(".onnx.GraphProto.output: object expected");l.output[s]=a.onnx.ValueInfoProto.fromObject(e.output[s])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");l.valueInfo=[];for(var s=0;s<e.valueInfo.length;++s){if(typeof e.valueInfo[s]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");l.valueInfo[s]=a.onnx.ValueInfoProto.fromObject(e.valueInfo[s])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");l.quantizationAnnotation=[];for(var s=0;s<e.quantizationAnnotation.length;++s){if(typeof e.quantizationAnnotation[s]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");l.quantizationAnnotation[s]=a.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[s])}}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.node=[],s.initializer=[],s.input=[],s.output=[],s.valueInfo=[],s.quantizationAnnotation=[],s.sparseInitializer=[]),l.defaults&&(s.name="",s.docString=""),e.node&&e.node.length){s.node=[];for(var d=0;d<e.node.length;++d)s.node[d]=a.onnx.NodeProto.toObject(e.node[d],l)}if(e.name!=null&&e.hasOwnProperty("name")&&(s.name=e.name),e.initializer&&e.initializer.length){s.initializer=[];for(var d=0;d<e.initializer.length;++d)s.initializer[d]=a.onnx.TensorProto.toObject(e.initializer[d],l)}if(e.docString!=null&&e.hasOwnProperty("docString")&&(s.docString=e.docString),e.input&&e.input.length){s.input=[];for(var d=0;d<e.input.length;++d)s.input[d]=a.onnx.ValueInfoProto.toObject(e.input[d],l)}if(e.output&&e.output.length){s.output=[];for(var d=0;d<e.output.length;++d)s.output[d]=a.onnx.ValueInfoProto.toObject(e.output[d],l)}if(e.valueInfo&&e.valueInfo.length){s.valueInfo=[];for(var d=0;d<e.valueInfo.length;++d)s.valueInfo[d]=a.onnx.ValueInfoProto.toObject(e.valueInfo[d],l)}if(e.quantizationAnnotation&&e.quantizationAnnotation.length){s.quantizationAnnotation=[];for(var d=0;d<e.quantizationAnnotation.length;++d)s.quantizationAnnotation[d]=a.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[d],l)}if(e.sparseInitializer&&e.sparseInitializer.length){s.sparseInitializer=[];for(var d=0;d<e.sparseInitializer.length;++d)s.sparseInitializer[d]=a.onnx.SparseTensorProto.toObject(e.sparseInitializer[d],l)}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.GraphProto"},p})(),c.TensorProto=(function(){function p(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.dims=n.emptyArray,p.prototype.dataType=0,p.prototype.segment=null,p.prototype.floatData=n.emptyArray,p.prototype.int32Data=n.emptyArray,p.prototype.stringData=n.emptyArray,p.prototype.int64Data=n.emptyArray,p.prototype.name="",p.prototype.docString="",p.prototype.rawData=n.newBuffer([]),p.prototype.externalData=n.emptyArray,p.prototype.dataLocation=0,p.prototype.doubleData=n.emptyArray,p.prototype.uint64Data=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.dims!=null&&e.dims.length){l.uint32(10).fork();for(var s=0;s<e.dims.length;++s)l.int64(e.dims[s]);l.ldelim()}if(e.dataType!=null&&Object.hasOwnProperty.call(e,"dataType")&&l.uint32(16).int32(e.dataType),e.segment!=null&&Object.hasOwnProperty.call(e,"segment")&&a.onnx.TensorProto.Segment.encode(e.segment,l.uint32(26).fork()).ldelim(),e.floatData!=null&&e.floatData.length){l.uint32(34).fork();for(var s=0;s<e.floatData.length;++s)l.float(e.floatData[s]);l.ldelim()}if(e.int32Data!=null&&e.int32Data.length){l.uint32(42).fork();for(var s=0;s<e.int32Data.length;++s)l.int32(e.int32Data[s]);l.ldelim()}if(e.stringData!=null&&e.stringData.length)for(var s=0;s<e.stringData.length;++s)l.uint32(50).bytes(e.stringData[s]);if(e.int64Data!=null&&e.int64Data.length){l.uint32(58).fork();for(var s=0;s<e.int64Data.length;++s)l.int64(e.int64Data[s]);l.ldelim()}if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&l.uint32(66).string(e.name),e.rawData!=null&&Object.hasOwnProperty.call(e,"rawData")&&l.uint32(74).bytes(e.rawData),e.doubleData!=null&&e.doubleData.length){l.uint32(82).fork();for(var s=0;s<e.doubleData.length;++s)l.double(e.doubleData[s]);l.ldelim()}if(e.uint64Data!=null&&e.uint64Data.length){l.uint32(90).fork();for(var s=0;s<e.uint64Data.length;++s)l.uint64(e.uint64Data[s]);l.ldelim()}if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&l.uint32(98).string(e.docString),e.externalData!=null&&e.externalData.length)for(var s=0;s<e.externalData.length;++s)a.onnx.StringStringEntryProto.encode(e.externalData[s],l.uint32(106).fork()).ldelim();return e.dataLocation!=null&&Object.hasOwnProperty.call(e,"dataLocation")&&l.uint32(112).int32(e.dataLocation),l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.TensorProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.dims.push(e.int64());else d.dims.push(e.int64());break}case 2:{d.dataType=e.int32();break}case 3:{d.segment=a.onnx.TensorProto.Segment.decode(e,e.uint32());break}case 4:{if(d.floatData&&d.floatData.length||(d.floatData=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.floatData.push(e.float());else d.floatData.push(e.float());break}case 5:{if(d.int32Data&&d.int32Data.length||(d.int32Data=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.int32Data.push(e.int32());else d.int32Data.push(e.int32());break}case 6:{d.stringData&&d.stringData.length||(d.stringData=[]),d.stringData.push(e.bytes());break}case 7:{if(d.int64Data&&d.int64Data.length||(d.int64Data=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.int64Data.push(e.int64());else d.int64Data.push(e.int64());break}case 8:{d.name=e.string();break}case 12:{d.docString=e.string();break}case 9:{d.rawData=e.bytes();break}case 13:{d.externalData&&d.externalData.length||(d.externalData=[]),d.externalData.push(a.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 14:{d.dataLocation=e.int32();break}case 10:{if(d.doubleData&&d.doubleData.length||(d.doubleData=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.doubleData.push(e.double());else d.doubleData.push(e.double());break}case 11:{if(d.uint64Data&&d.uint64Data.length||(d.uint64Data=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.uint64Data.push(e.uint64());else d.uint64Data.push(e.uint64());break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var l=0;l<e.dims.length;++l)if(!n.isInteger(e.dims[l])&&!(e.dims[l]&&n.isInteger(e.dims[l].low)&&n.isInteger(e.dims[l].high)))return"dims: integer|Long[] expected"}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&!n.isInteger(e.dataType))return"dataType: integer expected";if(e.segment!=null&&e.hasOwnProperty("segment")){var s=a.onnx.TensorProto.Segment.verify(e.segment);if(s)return"segment."+s}if(e.floatData!=null&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(var l=0;l<e.floatData.length;++l)if(typeof e.floatData[l]!="number")return"floatData: number[] expected"}if(e.int32Data!=null&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(var l=0;l<e.int32Data.length;++l)if(!n.isInteger(e.int32Data[l]))return"int32Data: integer[] expected"}if(e.stringData!=null&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(var l=0;l<e.stringData.length;++l)if(!(e.stringData[l]&&typeof e.stringData[l].length=="number"||n.isString(e.stringData[l])))return"stringData: buffer[] expected"}if(e.int64Data!=null&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(var l=0;l<e.int64Data.length;++l)if(!n.isInteger(e.int64Data[l])&&!(e.int64Data[l]&&n.isInteger(e.int64Data[l].low)&&n.isInteger(e.int64Data[l].high)))return"int64Data: integer|Long[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!n.isString(e.name))return"name: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!n.isString(e.docString))return"docString: string expected";if(e.rawData!=null&&e.hasOwnProperty("rawData")&&!(e.rawData&&typeof e.rawData.length=="number"||n.isString(e.rawData)))return"rawData: buffer expected";if(e.externalData!=null&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(var l=0;l<e.externalData.length;++l){var s=a.onnx.StringStringEntryProto.verify(e.externalData[l]);if(s)return"externalData."+s}}if(e.dataLocation!=null&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(e.doubleData!=null&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(var l=0;l<e.doubleData.length;++l)if(typeof e.doubleData[l]!="number")return"doubleData: number[] expected"}if(e.uint64Data!=null&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(var l=0;l<e.uint64Data.length;++l)if(!n.isInteger(e.uint64Data[l])&&!(e.uint64Data[l]&&n.isInteger(e.uint64Data[l].low)&&n.isInteger(e.uint64Data[l].high)))return"uint64Data: integer|Long[] expected"}return null},p.fromObject=function(e){if(e instanceof a.onnx.TensorProto)return e;var l=new a.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");l.dims=[];for(var s=0;s<e.dims.length;++s)n.Long?(l.dims[s]=n.Long.fromValue(e.dims[s])).unsigned=!1:typeof e.dims[s]=="string"?l.dims[s]=parseInt(e.dims[s],10):typeof e.dims[s]=="number"?l.dims[s]=e.dims[s]:typeof e.dims[s]=="object"&&(l.dims[s]=new n.LongBits(e.dims[s].low>>>0,e.dims[s].high>>>0).toNumber())}if(e.dataType!=null&&(l.dataType=e.dataType|0),e.segment!=null){if(typeof e.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");l.segment=a.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");l.floatData=[];for(var s=0;s<e.floatData.length;++s)l.floatData[s]=Number(e.floatData[s])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");l.int32Data=[];for(var s=0;s<e.int32Data.length;++s)l.int32Data[s]=e.int32Data[s]|0}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");l.stringData=[];for(var s=0;s<e.stringData.length;++s)typeof e.stringData[s]=="string"?n.base64.decode(e.stringData[s],l.stringData[s]=n.newBuffer(n.base64.length(e.stringData[s])),0):e.stringData[s].length>=0&&(l.stringData[s]=e.stringData[s])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");l.int64Data=[];for(var s=0;s<e.int64Data.length;++s)n.Long?(l.int64Data[s]=n.Long.fromValue(e.int64Data[s])).unsigned=!1:typeof e.int64Data[s]=="string"?l.int64Data[s]=parseInt(e.int64Data[s],10):typeof e.int64Data[s]=="number"?l.int64Data[s]=e.int64Data[s]:typeof e.int64Data[s]=="object"&&(l.int64Data[s]=new n.LongBits(e.int64Data[s].low>>>0,e.int64Data[s].high>>>0).toNumber())}if(e.name!=null&&(l.name=String(e.name)),e.docString!=null&&(l.docString=String(e.docString)),e.rawData!=null&&(typeof e.rawData=="string"?n.base64.decode(e.rawData,l.rawData=n.newBuffer(n.base64.length(e.rawData)),0):e.rawData.length>=0&&(l.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");l.externalData=[];for(var s=0;s<e.externalData.length;++s){if(typeof e.externalData[s]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");l.externalData[s]=a.onnx.StringStringEntryProto.fromObject(e.externalData[s])}}switch(e.dataLocation){default:if(typeof e.dataLocation=="number"){l.dataLocation=e.dataLocation;break}break;case"DEFAULT":case 0:l.dataLocation=0;break;case"EXTERNAL":case 1:l.dataLocation=1;break}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");l.doubleData=[];for(var s=0;s<e.doubleData.length;++s)l.doubleData[s]=Number(e.doubleData[s])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");l.uint64Data=[];for(var s=0;s<e.uint64Data.length;++s)n.Long?(l.uint64Data[s]=n.Long.fromValue(e.uint64Data[s])).unsigned=!0:typeof e.uint64Data[s]=="string"?l.uint64Data[s]=parseInt(e.uint64Data[s],10):typeof e.uint64Data[s]=="number"?l.uint64Data[s]=e.uint64Data[s]:typeof e.uint64Data[s]=="object"&&(l.uint64Data[s]=new n.LongBits(e.uint64Data[s].low>>>0,e.uint64Data[s].high>>>0).toNumber(!0))}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.dims=[],s.floatData=[],s.int32Data=[],s.stringData=[],s.int64Data=[],s.doubleData=[],s.uint64Data=[],s.externalData=[]),l.defaults&&(s.dataType=0,s.segment=null,s.name="",l.bytes===String?s.rawData="":(s.rawData=[],l.bytes!==Array&&(s.rawData=n.newBuffer(s.rawData))),s.docString="",s.dataLocation=l.enums===String?"DEFAULT":0),e.dims&&e.dims.length){s.dims=[];for(var d=0;d<e.dims.length;++d)typeof e.dims[d]=="number"?s.dims[d]=l.longs===String?String(e.dims[d]):e.dims[d]:s.dims[d]=l.longs===String?n.Long.prototype.toString.call(e.dims[d]):l.longs===Number?new n.LongBits(e.dims[d].low>>>0,e.dims[d].high>>>0).toNumber():e.dims[d]}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&(s.dataType=e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&(s.segment=a.onnx.TensorProto.Segment.toObject(e.segment,l)),e.floatData&&e.floatData.length){s.floatData=[];for(var d=0;d<e.floatData.length;++d)s.floatData[d]=l.json&&!isFinite(e.floatData[d])?String(e.floatData[d]):e.floatData[d]}if(e.int32Data&&e.int32Data.length){s.int32Data=[];for(var d=0;d<e.int32Data.length;++d)s.int32Data[d]=e.int32Data[d]}if(e.stringData&&e.stringData.length){s.stringData=[];for(var d=0;d<e.stringData.length;++d)s.stringData[d]=l.bytes===String?n.base64.encode(e.stringData[d],0,e.stringData[d].length):l.bytes===Array?Array.prototype.slice.call(e.stringData[d]):e.stringData[d]}if(e.int64Data&&e.int64Data.length){s.int64Data=[];for(var d=0;d<e.int64Data.length;++d)typeof e.int64Data[d]=="number"?s.int64Data[d]=l.longs===String?String(e.int64Data[d]):e.int64Data[d]:s.int64Data[d]=l.longs===String?n.Long.prototype.toString.call(e.int64Data[d]):l.longs===Number?new n.LongBits(e.int64Data[d].low>>>0,e.int64Data[d].high>>>0).toNumber():e.int64Data[d]}if(e.name!=null&&e.hasOwnProperty("name")&&(s.name=e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&(s.rawData=l.bytes===String?n.base64.encode(e.rawData,0,e.rawData.length):l.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length){s.doubleData=[];for(var d=0;d<e.doubleData.length;++d)s.doubleData[d]=l.json&&!isFinite(e.doubleData[d])?String(e.doubleData[d]):e.doubleData[d]}if(e.uint64Data&&e.uint64Data.length){s.uint64Data=[];for(var d=0;d<e.uint64Data.length;++d)typeof e.uint64Data[d]=="number"?s.uint64Data[d]=l.longs===String?String(e.uint64Data[d]):e.uint64Data[d]:s.uint64Data[d]=l.longs===String?n.Long.prototype.toString.call(e.uint64Data[d]):l.longs===Number?new n.LongBits(e.uint64Data[d].low>>>0,e.uint64Data[d].high>>>0).toNumber(!0):e.uint64Data[d]}if(e.docString!=null&&e.hasOwnProperty("docString")&&(s.docString=e.docString),e.externalData&&e.externalData.length){s.externalData=[];for(var d=0;d<e.externalData.length;++d)s.externalData[d]=a.onnx.StringStringEntryProto.toObject(e.externalData[d],l)}return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&(s.dataLocation=l.enums===String?a.onnx.TensorProto.DataLocation[e.dataLocation]===void 0?e.dataLocation:a.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorProto"},p.DataType=(function(){var e={},l=Object.create(e);return l[e[0]="UNDEFINED"]=0,l[e[1]="FLOAT"]=1,l[e[2]="UINT8"]=2,l[e[3]="INT8"]=3,l[e[4]="UINT16"]=4,l[e[5]="INT16"]=5,l[e[6]="INT32"]=6,l[e[7]="INT64"]=7,l[e[8]="STRING"]=8,l[e[9]="BOOL"]=9,l[e[10]="FLOAT16"]=10,l[e[11]="DOUBLE"]=11,l[e[12]="UINT32"]=12,l[e[13]="UINT64"]=13,l[e[14]="COMPLEX64"]=14,l[e[15]="COMPLEX128"]=15,l[e[16]="BFLOAT16"]=16,l[e[17]="FLOAT8E4M3FN"]=17,l[e[18]="FLOAT8E4M3FNUZ"]=18,l[e[19]="FLOAT8E5M2"]=19,l[e[20]="FLOAT8E5M2FNUZ"]=20,l})(),p.Segment=(function(){function e(l){if(l)for(var s=Object.keys(l),d=0;d<s.length;++d)l[s[d]]!=null&&(this[s[d]]=l[s[d]])}return e.prototype.begin=n.Long?n.Long.fromBits(0,0,!1):0,e.prototype.end=n.Long?n.Long.fromBits(0,0,!1):0,e.create=function(l){return new e(l)},e.encode=function(l,s){return s||(s=u.create()),l.begin!=null&&Object.hasOwnProperty.call(l,"begin")&&s.uint32(8).int64(l.begin),l.end!=null&&Object.hasOwnProperty.call(l,"end")&&s.uint32(16).int64(l.end),s},e.encodeDelimited=function(l,s){return this.encode(l,s).ldelim()},e.decode=function(l,s){l instanceof o||(l=o.create(l));for(var d=s===void 0?l.len:l.pos+s,h=new a.onnx.TensorProto.Segment;l.pos<d;){var g=l.uint32();switch(g>>>3){case 1:{h.begin=l.int64();break}case 2:{h.end=l.int64();break}default:l.skipType(g&7);break}}return h},e.decodeDelimited=function(l){return l instanceof o||(l=new o(l)),this.decode(l,l.uint32())},e.verify=function(l){return typeof l!="object"||l===null?"object expected":l.begin!=null&&l.hasOwnProperty("begin")&&!n.isInteger(l.begin)&&!(l.begin&&n.isInteger(l.begin.low)&&n.isInteger(l.begin.high))?"begin: integer|Long expected":l.end!=null&&l.hasOwnProperty("end")&&!n.isInteger(l.end)&&!(l.end&&n.isInteger(l.end.low)&&n.isInteger(l.end.high))?"end: integer|Long expected":null},e.fromObject=function(l){if(l instanceof a.onnx.TensorProto.Segment)return l;var s=new a.onnx.TensorProto.Segment;return l.begin!=null&&(n.Long?(s.begin=n.Long.fromValue(l.begin)).unsigned=!1:typeof l.begin=="string"?s.begin=parseInt(l.begin,10):typeof l.begin=="number"?s.begin=l.begin:typeof l.begin=="object"&&(s.begin=new n.LongBits(l.begin.low>>>0,l.begin.high>>>0).toNumber())),l.end!=null&&(n.Long?(s.end=n.Long.fromValue(l.end)).unsigned=!1:typeof l.end=="string"?s.end=parseInt(l.end,10):typeof l.end=="number"?s.end=l.end:typeof l.end=="object"&&(s.end=new n.LongBits(l.end.low>>>0,l.end.high>>>0).toNumber())),s},e.toObject=function(l,s){s||(s={});var d={};if(s.defaults){if(n.Long){var h=new n.Long(0,0,!1);d.begin=s.longs===String?h.toString():s.longs===Number?h.toNumber():h}else d.begin=s.longs===String?"0":0;if(n.Long){var h=new n.Long(0,0,!1);d.end=s.longs===String?h.toString():s.longs===Number?h.toNumber():h}else d.end=s.longs===String?"0":0}return l.begin!=null&&l.hasOwnProperty("begin")&&(typeof l.begin=="number"?d.begin=s.longs===String?String(l.begin):l.begin:d.begin=s.longs===String?n.Long.prototype.toString.call(l.begin):s.longs===Number?new n.LongBits(l.begin.low>>>0,l.begin.high>>>0).toNumber():l.begin),l.end!=null&&l.hasOwnProperty("end")&&(typeof l.end=="number"?d.end=s.longs===String?String(l.end):l.end:d.end=s.longs===String?n.Long.prototype.toString.call(l.end):s.longs===Number?new n.LongBits(l.end.low>>>0,l.end.high>>>0).toNumber():l.end),d},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TensorProto.Segment"},e})(),p.DataLocation=(function(){var e={},l=Object.create(e);return l[e[0]="DEFAULT"]=0,l[e[1]="EXTERNAL"]=1,l})(),p})(),c.SparseTensorProto=(function(){function p(e){if(this.dims=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.values=null,p.prototype.indices=null,p.prototype.dims=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.values!=null&&Object.hasOwnProperty.call(e,"values")&&a.onnx.TensorProto.encode(e.values,l.uint32(10).fork()).ldelim(),e.indices!=null&&Object.hasOwnProperty.call(e,"indices")&&a.onnx.TensorProto.encode(e.indices,l.uint32(18).fork()).ldelim(),e.dims!=null&&e.dims.length){l.uint32(26).fork();for(var s=0;s<e.dims.length;++s)l.int64(e.dims[s]);l.ldelim()}return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.SparseTensorProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.values=a.onnx.TensorProto.decode(e,e.uint32());break}case 2:{d.indices=a.onnx.TensorProto.decode(e,e.uint32());break}case 3:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var g=e.uint32()+e.pos;e.pos<g;)d.dims.push(e.int64());else d.dims.push(e.int64());break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.values!=null&&e.hasOwnProperty("values")){var l=a.onnx.TensorProto.verify(e.values);if(l)return"values."+l}if(e.indices!=null&&e.hasOwnProperty("indices")){var l=a.onnx.TensorProto.verify(e.indices);if(l)return"indices."+l}if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var s=0;s<e.dims.length;++s)if(!n.isInteger(e.dims[s])&&!(e.dims[s]&&n.isInteger(e.dims[s].low)&&n.isInteger(e.dims[s].high)))return"dims: integer|Long[] expected"}return null},p.fromObject=function(e){if(e instanceof a.onnx.SparseTensorProto)return e;var l=new a.onnx.SparseTensorProto;if(e.values!=null){if(typeof e.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");l.values=a.onnx.TensorProto.fromObject(e.values)}if(e.indices!=null){if(typeof e.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");l.indices=a.onnx.TensorProto.fromObject(e.indices)}if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");l.dims=[];for(var s=0;s<e.dims.length;++s)n.Long?(l.dims[s]=n.Long.fromValue(e.dims[s])).unsigned=!1:typeof e.dims[s]=="string"?l.dims[s]=parseInt(e.dims[s],10):typeof e.dims[s]=="number"?l.dims[s]=e.dims[s]:typeof e.dims[s]=="object"&&(l.dims[s]=new n.LongBits(e.dims[s].low>>>0,e.dims[s].high>>>0).toNumber())}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.dims=[]),l.defaults&&(s.values=null,s.indices=null),e.values!=null&&e.hasOwnProperty("values")&&(s.values=a.onnx.TensorProto.toObject(e.values,l)),e.indices!=null&&e.hasOwnProperty("indices")&&(s.indices=a.onnx.TensorProto.toObject(e.indices,l)),e.dims&&e.dims.length){s.dims=[];for(var d=0;d<e.dims.length;++d)typeof e.dims[d]=="number"?s.dims[d]=l.longs===String?String(e.dims[d]):e.dims[d]:s.dims[d]=l.longs===String?n.Long.prototype.toString.call(e.dims[d]):l.longs===Number?new n.LongBits(e.dims[d].low>>>0,e.dims[d].high>>>0).toNumber():e.dims[d]}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.SparseTensorProto"},p})(),c.TensorShapeProto=(function(){function p(e){if(this.dim=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.dim=n.emptyArray,p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.dim!=null&&e.dim.length)for(var s=0;s<e.dim.length;++s)a.onnx.TensorShapeProto.Dimension.encode(e.dim[s],l.uint32(10).fork()).ldelim();return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.TensorShapeProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.dim&&d.dim.length||(d.dim=[]),d.dim.push(a.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dim!=null&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var l=0;l<e.dim.length;++l){var s=a.onnx.TensorShapeProto.Dimension.verify(e.dim[l]);if(s)return"dim."+s}}return null},p.fromObject=function(e){if(e instanceof a.onnx.TensorShapeProto)return e;var l=new a.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");l.dim=[];for(var s=0;s<e.dim.length;++s){if(typeof e.dim[s]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");l.dim[s]=a.onnx.TensorShapeProto.Dimension.fromObject(e.dim[s])}}return l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.dim=[]),e.dim&&e.dim.length){s.dim=[];for(var d=0;d<e.dim.length;++d)s.dim[d]=a.onnx.TensorShapeProto.Dimension.toObject(e.dim[d],l)}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorShapeProto"},p.Dimension=(function(){function e(s){if(s)for(var d=Object.keys(s),h=0;h<d.length;++h)s[d[h]]!=null&&(this[d[h]]=s[d[h]])}e.prototype.dimValue=null,e.prototype.dimParam=null,e.prototype.denotation="";var l;return Object.defineProperty(e.prototype,"value",{get:n.oneOfGetter(l=["dimValue","dimParam"]),set:n.oneOfSetter(l)}),e.create=function(s){return new e(s)},e.encode=function(s,d){return d||(d=u.create()),s.dimValue!=null&&Object.hasOwnProperty.call(s,"dimValue")&&d.uint32(8).int64(s.dimValue),s.dimParam!=null&&Object.hasOwnProperty.call(s,"dimParam")&&d.uint32(18).string(s.dimParam),s.denotation!=null&&Object.hasOwnProperty.call(s,"denotation")&&d.uint32(26).string(s.denotation),d},e.encodeDelimited=function(s,d){return this.encode(s,d).ldelim()},e.decode=function(s,d){s instanceof o||(s=o.create(s));for(var h=d===void 0?s.len:s.pos+d,g=new a.onnx.TensorShapeProto.Dimension;s.pos<h;){var m=s.uint32();switch(m>>>3){case 1:{g.dimValue=s.int64();break}case 2:{g.dimParam=s.string();break}case 3:{g.denotation=s.string();break}default:s.skipType(m&7);break}}return g},e.decodeDelimited=function(s){return s instanceof o||(s=new o(s)),this.decode(s,s.uint32())},e.verify=function(s){if(typeof s!="object"||s===null)return"object expected";var d={};if(s.dimValue!=null&&s.hasOwnProperty("dimValue")&&(d.value=1,!n.isInteger(s.dimValue)&&!(s.dimValue&&n.isInteger(s.dimValue.low)&&n.isInteger(s.dimValue.high))))return"dimValue: integer|Long expected";if(s.dimParam!=null&&s.hasOwnProperty("dimParam")){if(d.value===1)return"value: multiple values";if(d.value=1,!n.isString(s.dimParam))return"dimParam: string expected"}return s.denotation!=null&&s.hasOwnProperty("denotation")&&!n.isString(s.denotation)?"denotation: string expected":null},e.fromObject=function(s){if(s instanceof a.onnx.TensorShapeProto.Dimension)return s;var d=new a.onnx.TensorShapeProto.Dimension;return s.dimValue!=null&&(n.Long?(d.dimValue=n.Long.fromValue(s.dimValue)).unsigned=!1:typeof s.dimValue=="string"?d.dimValue=parseInt(s.dimValue,10):typeof s.dimValue=="number"?d.dimValue=s.dimValue:typeof s.dimValue=="object"&&(d.dimValue=new n.LongBits(s.dimValue.low>>>0,s.dimValue.high>>>0).toNumber())),s.dimParam!=null&&(d.dimParam=String(s.dimParam)),s.denotation!=null&&(d.denotation=String(s.denotation)),d},e.toObject=function(s,d){d||(d={});var h={};return d.defaults&&(h.denotation=""),s.dimValue!=null&&s.hasOwnProperty("dimValue")&&(typeof s.dimValue=="number"?h.dimValue=d.longs===String?String(s.dimValue):s.dimValue:h.dimValue=d.longs===String?n.Long.prototype.toString.call(s.dimValue):d.longs===Number?new n.LongBits(s.dimValue.low>>>0,s.dimValue.high>>>0).toNumber():s.dimValue,d.oneofs&&(h.value="dimValue")),s.dimParam!=null&&s.hasOwnProperty("dimParam")&&(h.dimParam=s.dimParam,d.oneofs&&(h.value="dimParam")),s.denotation!=null&&s.hasOwnProperty("denotation")&&(h.denotation=s.denotation),h},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.getTypeUrl=function(s){return s===void 0&&(s="type.googleapis.com"),s+"/onnx.TensorShapeProto.Dimension"},e})(),p})(),c.TypeProto=(function(){function p(l){if(l)for(var s=Object.keys(l),d=0;d<s.length;++d)l[s[d]]!=null&&(this[s[d]]=l[s[d]])}p.prototype.tensorType=null,p.prototype.sequenceType=null,p.prototype.mapType=null,p.prototype.optionalType=null,p.prototype.sparseTensorType=null,p.prototype.denotation="";var e;return Object.defineProperty(p.prototype,"value",{get:n.oneOfGetter(e=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:n.oneOfSetter(e)}),p.create=function(l){return new p(l)},p.encode=function(l,s){return s||(s=u.create()),l.tensorType!=null&&Object.hasOwnProperty.call(l,"tensorType")&&a.onnx.TypeProto.Tensor.encode(l.tensorType,s.uint32(10).fork()).ldelim(),l.sequenceType!=null&&Object.hasOwnProperty.call(l,"sequenceType")&&a.onnx.TypeProto.Sequence.encode(l.sequenceType,s.uint32(34).fork()).ldelim(),l.mapType!=null&&Object.hasOwnProperty.call(l,"mapType")&&a.onnx.TypeProto.Map.encode(l.mapType,s.uint32(42).fork()).ldelim(),l.denotation!=null&&Object.hasOwnProperty.call(l,"denotation")&&s.uint32(50).string(l.denotation),l.sparseTensorType!=null&&Object.hasOwnProperty.call(l,"sparseTensorType")&&a.onnx.TypeProto.SparseTensor.encode(l.sparseTensorType,s.uint32(66).fork()).ldelim(),l.optionalType!=null&&Object.hasOwnProperty.call(l,"optionalType")&&a.onnx.TypeProto.Optional.encode(l.optionalType,s.uint32(74).fork()).ldelim(),s},p.encodeDelimited=function(l,s){return this.encode(l,s).ldelim()},p.decode=function(l,s){l instanceof o||(l=o.create(l));for(var d=s===void 0?l.len:l.pos+s,h=new a.onnx.TypeProto;l.pos<d;){var g=l.uint32();switch(g>>>3){case 1:{h.tensorType=a.onnx.TypeProto.Tensor.decode(l,l.uint32());break}case 4:{h.sequenceType=a.onnx.TypeProto.Sequence.decode(l,l.uint32());break}case 5:{h.mapType=a.onnx.TypeProto.Map.decode(l,l.uint32());break}case 9:{h.optionalType=a.onnx.TypeProto.Optional.decode(l,l.uint32());break}case 8:{h.sparseTensorType=a.onnx.TypeProto.SparseTensor.decode(l,l.uint32());break}case 6:{h.denotation=l.string();break}default:l.skipType(g&7);break}}return h},p.decodeDelimited=function(l){return l instanceof o||(l=new o(l)),this.decode(l,l.uint32())},p.verify=function(l){if(typeof l!="object"||l===null)return"object expected";var s={};if(l.tensorType!=null&&l.hasOwnProperty("tensorType")){s.value=1;{var d=a.onnx.TypeProto.Tensor.verify(l.tensorType);if(d)return"tensorType."+d}}if(l.sequenceType!=null&&l.hasOwnProperty("sequenceType")){if(s.value===1)return"value: multiple values";s.value=1;{var d=a.onnx.TypeProto.Sequence.verify(l.sequenceType);if(d)return"sequenceType."+d}}if(l.mapType!=null&&l.hasOwnProperty("mapType")){if(s.value===1)return"value: multiple values";s.value=1;{var d=a.onnx.TypeProto.Map.verify(l.mapType);if(d)return"mapType."+d}}if(l.optionalType!=null&&l.hasOwnProperty("optionalType")){if(s.value===1)return"value: multiple values";s.value=1;{var d=a.onnx.TypeProto.Optional.verify(l.optionalType);if(d)return"optionalType."+d}}if(l.sparseTensorType!=null&&l.hasOwnProperty("sparseTensorType")){if(s.value===1)return"value: multiple values";s.value=1;{var d=a.onnx.TypeProto.SparseTensor.verify(l.sparseTensorType);if(d)return"sparseTensorType."+d}}return l.denotation!=null&&l.hasOwnProperty("denotation")&&!n.isString(l.denotation)?"denotation: string expected":null},p.fromObject=function(l){if(l instanceof a.onnx.TypeProto)return l;var s=new a.onnx.TypeProto;if(l.tensorType!=null){if(typeof l.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");s.tensorType=a.onnx.TypeProto.Tensor.fromObject(l.tensorType)}if(l.sequenceType!=null){if(typeof l.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");s.sequenceType=a.onnx.TypeProto.Sequence.fromObject(l.sequenceType)}if(l.mapType!=null){if(typeof l.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");s.mapType=a.onnx.TypeProto.Map.fromObject(l.mapType)}if(l.optionalType!=null){if(typeof l.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");s.optionalType=a.onnx.TypeProto.Optional.fromObject(l.optionalType)}if(l.sparseTensorType!=null){if(typeof l.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");s.sparseTensorType=a.onnx.TypeProto.SparseTensor.fromObject(l.sparseTensorType)}return l.denotation!=null&&(s.denotation=String(l.denotation)),s},p.toObject=function(l,s){s||(s={});var d={};return s.defaults&&(d.denotation=""),l.tensorType!=null&&l.hasOwnProperty("tensorType")&&(d.tensorType=a.onnx.TypeProto.Tensor.toObject(l.tensorType,s),s.oneofs&&(d.value="tensorType")),l.sequenceType!=null&&l.hasOwnProperty("sequenceType")&&(d.sequenceType=a.onnx.TypeProto.Sequence.toObject(l.sequenceType,s),s.oneofs&&(d.value="sequenceType")),l.mapType!=null&&l.hasOwnProperty("mapType")&&(d.mapType=a.onnx.TypeProto.Map.toObject(l.mapType,s),s.oneofs&&(d.value="mapType")),l.denotation!=null&&l.hasOwnProperty("denotation")&&(d.denotation=l.denotation),l.sparseTensorType!=null&&l.hasOwnProperty("sparseTensorType")&&(d.sparseTensorType=a.onnx.TypeProto.SparseTensor.toObject(l.sparseTensorType,s),s.oneofs&&(d.value="sparseTensorType")),l.optionalType!=null&&l.hasOwnProperty("optionalType")&&(d.optionalType=a.onnx.TypeProto.Optional.toObject(l.optionalType,s),s.oneofs&&(d.value="optionalType")),d},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto"},p.Tensor=(function(){function l(s){if(s)for(var d=Object.keys(s),h=0;h<d.length;++h)s[d[h]]!=null&&(this[d[h]]=s[d[h]])}return l.prototype.elemType=0,l.prototype.shape=null,l.create=function(s){return new l(s)},l.encode=function(s,d){return d||(d=u.create()),s.elemType!=null&&Object.hasOwnProperty.call(s,"elemType")&&d.uint32(8).int32(s.elemType),s.shape!=null&&Object.hasOwnProperty.call(s,"shape")&&a.onnx.TensorShapeProto.encode(s.shape,d.uint32(18).fork()).ldelim(),d},l.encodeDelimited=function(s,d){return this.encode(s,d).ldelim()},l.decode=function(s,d){s instanceof o||(s=o.create(s));for(var h=d===void 0?s.len:s.pos+d,g=new a.onnx.TypeProto.Tensor;s.pos<h;){var m=s.uint32();switch(m>>>3){case 1:{g.elemType=s.int32();break}case 2:{g.shape=a.onnx.TensorShapeProto.decode(s,s.uint32());break}default:s.skipType(m&7);break}}return g},l.decodeDelimited=function(s){return s instanceof o||(s=new o(s)),this.decode(s,s.uint32())},l.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.elemType!=null&&s.hasOwnProperty("elemType")&&!n.isInteger(s.elemType))return"elemType: integer expected";if(s.shape!=null&&s.hasOwnProperty("shape")){var d=a.onnx.TensorShapeProto.verify(s.shape);if(d)return"shape."+d}return null},l.fromObject=function(s){if(s instanceof a.onnx.TypeProto.Tensor)return s;var d=new a.onnx.TypeProto.Tensor;if(s.elemType!=null&&(d.elemType=s.elemType|0),s.shape!=null){if(typeof s.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");d.shape=a.onnx.TensorShapeProto.fromObject(s.shape)}return d},l.toObject=function(s,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),s.elemType!=null&&s.hasOwnProperty("elemType")&&(h.elemType=s.elemType),s.shape!=null&&s.hasOwnProperty("shape")&&(h.shape=a.onnx.TensorShapeProto.toObject(s.shape,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(s){return s===void 0&&(s="type.googleapis.com"),s+"/onnx.TypeProto.Tensor"},l})(),p.Sequence=(function(){function l(s){if(s)for(var d=Object.keys(s),h=0;h<d.length;++h)s[d[h]]!=null&&(this[d[h]]=s[d[h]])}return l.prototype.elemType=null,l.create=function(s){return new l(s)},l.encode=function(s,d){return d||(d=u.create()),s.elemType!=null&&Object.hasOwnProperty.call(s,"elemType")&&a.onnx.TypeProto.encode(s.elemType,d.uint32(10).fork()).ldelim(),d},l.encodeDelimited=function(s,d){return this.encode(s,d).ldelim()},l.decode=function(s,d){s instanceof o||(s=o.create(s));for(var h=d===void 0?s.len:s.pos+d,g=new a.onnx.TypeProto.Sequence;s.pos<h;){var m=s.uint32();switch(m>>>3){case 1:{g.elemType=a.onnx.TypeProto.decode(s,s.uint32());break}default:s.skipType(m&7);break}}return g},l.decodeDelimited=function(s){return s instanceof o||(s=new o(s)),this.decode(s,s.uint32())},l.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.elemType!=null&&s.hasOwnProperty("elemType")){var d=a.onnx.TypeProto.verify(s.elemType);if(d)return"elemType."+d}return null},l.fromObject=function(s){if(s instanceof a.onnx.TypeProto.Sequence)return s;var d=new a.onnx.TypeProto.Sequence;if(s.elemType!=null){if(typeof s.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");d.elemType=a.onnx.TypeProto.fromObject(s.elemType)}return d},l.toObject=function(s,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),s.elemType!=null&&s.hasOwnProperty("elemType")&&(h.elemType=a.onnx.TypeProto.toObject(s.elemType,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(s){return s===void 0&&(s="type.googleapis.com"),s+"/onnx.TypeProto.Sequence"},l})(),p.Map=(function(){function l(s){if(s)for(var d=Object.keys(s),h=0;h<d.length;++h)s[d[h]]!=null&&(this[d[h]]=s[d[h]])}return l.prototype.keyType=0,l.prototype.valueType=null,l.create=function(s){return new l(s)},l.encode=function(s,d){return d||(d=u.create()),s.keyType!=null&&Object.hasOwnProperty.call(s,"keyType")&&d.uint32(8).int32(s.keyType),s.valueType!=null&&Object.hasOwnProperty.call(s,"valueType")&&a.onnx.TypeProto.encode(s.valueType,d.uint32(18).fork()).ldelim(),d},l.encodeDelimited=function(s,d){return this.encode(s,d).ldelim()},l.decode=function(s,d){s instanceof o||(s=o.create(s));for(var h=d===void 0?s.len:s.pos+d,g=new a.onnx.TypeProto.Map;s.pos<h;){var m=s.uint32();switch(m>>>3){case 1:{g.keyType=s.int32();break}case 2:{g.valueType=a.onnx.TypeProto.decode(s,s.uint32());break}default:s.skipType(m&7);break}}return g},l.decodeDelimited=function(s){return s instanceof o||(s=new o(s)),this.decode(s,s.uint32())},l.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.keyType!=null&&s.hasOwnProperty("keyType")&&!n.isInteger(s.keyType))return"keyType: integer expected";if(s.valueType!=null&&s.hasOwnProperty("valueType")){var d=a.onnx.TypeProto.verify(s.valueType);if(d)return"valueType."+d}return null},l.fromObject=function(s){if(s instanceof a.onnx.TypeProto.Map)return s;var d=new a.onnx.TypeProto.Map;if(s.keyType!=null&&(d.keyType=s.keyType|0),s.valueType!=null){if(typeof s.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");d.valueType=a.onnx.TypeProto.fromObject(s.valueType)}return d},l.toObject=function(s,d){d||(d={});var h={};return d.defaults&&(h.keyType=0,h.valueType=null),s.keyType!=null&&s.hasOwnProperty("keyType")&&(h.keyType=s.keyType),s.valueType!=null&&s.hasOwnProperty("valueType")&&(h.valueType=a.onnx.TypeProto.toObject(s.valueType,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(s){return s===void 0&&(s="type.googleapis.com"),s+"/onnx.TypeProto.Map"},l})(),p.Optional=(function(){function l(s){if(s)for(var d=Object.keys(s),h=0;h<d.length;++h)s[d[h]]!=null&&(this[d[h]]=s[d[h]])}return l.prototype.elemType=null,l.create=function(s){return new l(s)},l.encode=function(s,d){return d||(d=u.create()),s.elemType!=null&&Object.hasOwnProperty.call(s,"elemType")&&a.onnx.TypeProto.encode(s.elemType,d.uint32(10).fork()).ldelim(),d},l.encodeDelimited=function(s,d){return this.encode(s,d).ldelim()},l.decode=function(s,d){s instanceof o||(s=o.create(s));for(var h=d===void 0?s.len:s.pos+d,g=new a.onnx.TypeProto.Optional;s.pos<h;){var m=s.uint32();switch(m>>>3){case 1:{g.elemType=a.onnx.TypeProto.decode(s,s.uint32());break}default:s.skipType(m&7);break}}return g},l.decodeDelimited=function(s){return s instanceof o||(s=new o(s)),this.decode(s,s.uint32())},l.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.elemType!=null&&s.hasOwnProperty("elemType")){var d=a.onnx.TypeProto.verify(s.elemType);if(d)return"elemType."+d}return null},l.fromObject=function(s){if(s instanceof a.onnx.TypeProto.Optional)return s;var d=new a.onnx.TypeProto.Optional;if(s.elemType!=null){if(typeof s.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");d.elemType=a.onnx.TypeProto.fromObject(s.elemType)}return d},l.toObject=function(s,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),s.elemType!=null&&s.hasOwnProperty("elemType")&&(h.elemType=a.onnx.TypeProto.toObject(s.elemType,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(s){return s===void 0&&(s="type.googleapis.com"),s+"/onnx.TypeProto.Optional"},l})(),p.SparseTensor=(function(){function l(s){if(s)for(var d=Object.keys(s),h=0;h<d.length;++h)s[d[h]]!=null&&(this[d[h]]=s[d[h]])}return l.prototype.elemType=0,l.prototype.shape=null,l.create=function(s){return new l(s)},l.encode=function(s,d){return d||(d=u.create()),s.elemType!=null&&Object.hasOwnProperty.call(s,"elemType")&&d.uint32(8).int32(s.elemType),s.shape!=null&&Object.hasOwnProperty.call(s,"shape")&&a.onnx.TensorShapeProto.encode(s.shape,d.uint32(18).fork()).ldelim(),d},l.encodeDelimited=function(s,d){return this.encode(s,d).ldelim()},l.decode=function(s,d){s instanceof o||(s=o.create(s));for(var h=d===void 0?s.len:s.pos+d,g=new a.onnx.TypeProto.SparseTensor;s.pos<h;){var m=s.uint32();switch(m>>>3){case 1:{g.elemType=s.int32();break}case 2:{g.shape=a.onnx.TensorShapeProto.decode(s,s.uint32());break}default:s.skipType(m&7);break}}return g},l.decodeDelimited=function(s){return s instanceof o||(s=new o(s)),this.decode(s,s.uint32())},l.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.elemType!=null&&s.hasOwnProperty("elemType")&&!n.isInteger(s.elemType))return"elemType: integer expected";if(s.shape!=null&&s.hasOwnProperty("shape")){var d=a.onnx.TensorShapeProto.verify(s.shape);if(d)return"shape."+d}return null},l.fromObject=function(s){if(s instanceof a.onnx.TypeProto.SparseTensor)return s;var d=new a.onnx.TypeProto.SparseTensor;if(s.elemType!=null&&(d.elemType=s.elemType|0),s.shape!=null){if(typeof s.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");d.shape=a.onnx.TensorShapeProto.fromObject(s.shape)}return d},l.toObject=function(s,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),s.elemType!=null&&s.hasOwnProperty("elemType")&&(h.elemType=s.elemType),s.shape!=null&&s.hasOwnProperty("shape")&&(h.shape=a.onnx.TensorShapeProto.toObject(s.shape,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(s){return s===void 0&&(s="type.googleapis.com"),s+"/onnx.TypeProto.SparseTensor"},l})(),p})(),c.OperatorSetIdProto=(function(){function p(e){if(e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.domain="",p.prototype.version=n.Long?n.Long.fromBits(0,0,!1):0,p.create=function(e){return new p(e)},p.encode=function(e,l){return l||(l=u.create()),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&l.uint32(10).string(e.domain),e.version!=null&&Object.hasOwnProperty.call(e,"version")&&l.uint32(16).int64(e.version),l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.OperatorSetIdProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.domain=e.string();break}case 2:{d.version=e.int64();break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){return typeof e!="object"||e===null?"object expected":e.domain!=null&&e.hasOwnProperty("domain")&&!n.isString(e.domain)?"domain: string expected":e.version!=null&&e.hasOwnProperty("version")&&!n.isInteger(e.version)&&!(e.version&&n.isInteger(e.version.low)&&n.isInteger(e.version.high))?"version: integer|Long expected":null},p.fromObject=function(e){if(e instanceof a.onnx.OperatorSetIdProto)return e;var l=new a.onnx.OperatorSetIdProto;return e.domain!=null&&(l.domain=String(e.domain)),e.version!=null&&(n.Long?(l.version=n.Long.fromValue(e.version)).unsigned=!1:typeof e.version=="string"?l.version=parseInt(e.version,10):typeof e.version=="number"?l.version=e.version:typeof e.version=="object"&&(l.version=new n.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),l},p.toObject=function(e,l){l||(l={});var s={};if(l.defaults)if(s.domain="",n.Long){var d=new n.Long(0,0,!1);s.version=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else s.version=l.longs===String?"0":0;return e.domain!=null&&e.hasOwnProperty("domain")&&(s.domain=e.domain),e.version!=null&&e.hasOwnProperty("version")&&(typeof e.version=="number"?s.version=l.longs===String?String(e.version):e.version:s.version=l.longs===String?n.Long.prototype.toString.call(e.version):l.longs===Number?new n.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.OperatorSetIdProto"},p})(),c.OperatorStatus=(function(){var p={},e=Object.create(p);return e[p[0]="EXPERIMENTAL"]=0,e[p[1]="STABLE"]=1,e})(),c.FunctionProto=(function(){function p(e){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],e)for(var l=Object.keys(e),s=0;s<l.length;++s)e[l[s]]!=null&&(this[l[s]]=e[l[s]])}return p.prototype.name="",p.prototype.input=n.emptyArray,p.prototype.output=n.emptyArray,p.prototype.attribute=n.emptyArray,p.prototype.attributeProto=n.emptyArray,p.prototype.node=n.emptyArray,p.prototype.docString="",p.prototype.opsetImport=n.emptyArray,p.prototype.domain="",p.create=function(e){return new p(e)},p.encode=function(e,l){if(l||(l=u.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&l.uint32(10).string(e.name),e.input!=null&&e.input.length)for(var s=0;s<e.input.length;++s)l.uint32(34).string(e.input[s]);if(e.output!=null&&e.output.length)for(var s=0;s<e.output.length;++s)l.uint32(42).string(e.output[s]);if(e.attribute!=null&&e.attribute.length)for(var s=0;s<e.attribute.length;++s)l.uint32(50).string(e.attribute[s]);if(e.node!=null&&e.node.length)for(var s=0;s<e.node.length;++s)a.onnx.NodeProto.encode(e.node[s],l.uint32(58).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&l.uint32(66).string(e.docString),e.opsetImport!=null&&e.opsetImport.length)for(var s=0;s<e.opsetImport.length;++s)a.onnx.OperatorSetIdProto.encode(e.opsetImport[s],l.uint32(74).fork()).ldelim();if(e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&l.uint32(82).string(e.domain),e.attributeProto!=null&&e.attributeProto.length)for(var s=0;s<e.attributeProto.length;++s)a.onnx.AttributeProto.encode(e.attributeProto[s],l.uint32(90).fork()).ldelim();return l},p.encodeDelimited=function(e,l){return this.encode(e,l).ldelim()},p.decode=function(e,l){e instanceof o||(e=o.create(e));for(var s=l===void 0?e.len:e.pos+l,d=new a.onnx.FunctionProto;e.pos<s;){var h=e.uint32();switch(h>>>3){case 1:{d.name=e.string();break}case 4:{d.input&&d.input.length||(d.input=[]),d.input.push(e.string());break}case 5:{d.output&&d.output.length||(d.output=[]),d.output.push(e.string());break}case 6:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(e.string());break}case 11:{d.attributeProto&&d.attributeProto.length||(d.attributeProto=[]),d.attributeProto.push(a.onnx.AttributeProto.decode(e,e.uint32()));break}case 7:{d.node&&d.node.length||(d.node=[]),d.node.push(a.onnx.NodeProto.decode(e,e.uint32()));break}case 8:{d.docString=e.string();break}case 9:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(a.onnx.OperatorSetIdProto.decode(e,e.uint32()));break}case 10:{d.domain=e.string();break}default:e.skipType(h&7);break}}return d},p.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},p.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!n.isString(e.name))return"name: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var l=0;l<e.input.length;++l)if(!n.isString(e.input[l]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(var l=0;l<e.output.length;++l)if(!n.isString(e.output[l]))return"output: string[] expected"}if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(var l=0;l<e.attribute.length;++l)if(!n.isString(e.attribute[l]))return"attribute: string[] expected"}if(e.attributeProto!=null&&e.hasOwnProperty("attributeProto")){if(!Array.isArray(e.attributeProto))return"attributeProto: array expected";for(var l=0;l<e.attributeProto.length;++l){var s=a.onnx.AttributeProto.verify(e.attributeProto[l]);if(s)return"attributeProto."+s}}if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var l=0;l<e.node.length;++l){var s=a.onnx.NodeProto.verify(e.node[l]);if(s)return"node."+s}}if(e.docString!=null&&e.hasOwnProperty("docString")&&!n.isString(e.docString))return"docString: string expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var l=0;l<e.opsetImport.length;++l){var s=a.onnx.OperatorSetIdProto.verify(e.opsetImport[l]);if(s)return"opsetImport."+s}}return e.domain!=null&&e.hasOwnProperty("domain")&&!n.isString(e.domain)?"domain: string expected":null},p.fromObject=function(e){if(e instanceof a.onnx.FunctionProto)return e;var l=new a.onnx.FunctionProto;if(e.name!=null&&(l.name=String(e.name)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.FunctionProto.input: array expected");l.input=[];for(var s=0;s<e.input.length;++s)l.input[s]=String(e.input[s])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.FunctionProto.output: array expected");l.output=[];for(var s=0;s<e.output.length;++s)l.output[s]=String(e.output[s])}if(e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");l.attribute=[];for(var s=0;s<e.attribute.length;++s)l.attribute[s]=String(e.attribute[s])}if(e.attributeProto){if(!Array.isArray(e.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");l.attributeProto=[];for(var s=0;s<e.attributeProto.length;++s){if(typeof e.attributeProto[s]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");l.attributeProto[s]=a.onnx.AttributeProto.fromObject(e.attributeProto[s])}}if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.FunctionProto.node: array expected");l.node=[];for(var s=0;s<e.node.length;++s){if(typeof e.node[s]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");l.node[s]=a.onnx.NodeProto.fromObject(e.node[s])}}if(e.docString!=null&&(l.docString=String(e.docString)),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");l.opsetImport=[];for(var s=0;s<e.opsetImport.length;++s){if(typeof e.opsetImport[s]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");l.opsetImport[s]=a.onnx.OperatorSetIdProto.fromObject(e.opsetImport[s])}}return e.domain!=null&&(l.domain=String(e.domain)),l},p.toObject=function(e,l){l||(l={});var s={};if((l.arrays||l.defaults)&&(s.input=[],s.output=[],s.attribute=[],s.node=[],s.opsetImport=[],s.attributeProto=[]),l.defaults&&(s.name="",s.docString="",s.domain=""),e.name!=null&&e.hasOwnProperty("name")&&(s.name=e.name),e.input&&e.input.length){s.input=[];for(var d=0;d<e.input.length;++d)s.input[d]=e.input[d]}if(e.output&&e.output.length){s.output=[];for(var d=0;d<e.output.length;++d)s.output[d]=e.output[d]}if(e.attribute&&e.attribute.length){s.attribute=[];for(var d=0;d<e.attribute.length;++d)s.attribute[d]=e.attribute[d]}if(e.node&&e.node.length){s.node=[];for(var d=0;d<e.node.length;++d)s.node[d]=a.onnx.NodeProto.toObject(e.node[d],l)}if(e.docString!=null&&e.hasOwnProperty("docString")&&(s.docString=e.docString),e.opsetImport&&e.opsetImport.length){s.opsetImport=[];for(var d=0;d<e.opsetImport.length;++d)s.opsetImport[d]=a.onnx.OperatorSetIdProto.toObject(e.opsetImport[d],l)}if(e.domain!=null&&e.hasOwnProperty("domain")&&(s.domain=e.domain),e.attributeProto&&e.attributeProto.length){s.attributeProto=[];for(var d=0;d<e.attributeProto.length;++d)s.attributeProto[d]=a.onnx.AttributeProto.toObject(e.attributeProto[d],l)}return s},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.FunctionProto"},p})(),c})(),r.exports=a});function ur(t,r){if(!t)throw new Error(typeof r=="string"?r:r())}function kr(t){return new TextDecoder().decode(t)}var ot,Me,ai,kt,Sn,At,Rt,B,$r,Ue,Ve,ze,Y=O(()=>{wn(),qo(),ot=rr(sr()),We(),Me=class{static arraysEqual(t,r){if(t.length!==r.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==r[i])return!1;return!0}},ai=class{static preprocessInputShapes(t,r){let i=t.length===1?[1,t[0]]:t,o=r.length===1?[r[0],1]:r;return[i,o]}static postprocessOutputShape(t,r,i){r===1&&t.splice(t.length-2,1),i===1&&t.pop()}static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},kt=class ge{static calcShape(r,i,o=!1){let u=r.length,n=i.length;if(u===0)return i;if(n===0)return r;let a=Math.max(r.length,i.length),c=new Array(a);if(o){if(u<2||n<2)return;let p=ai.calcMatMulShape([r[u-2],r[u-1]],[i[n-2],i[n-1]]);if(p===void 0)return;[c[a-2],c[a-1]]=p}for(let p=o?3:1;p<=a;p++){let e=u-p<0?1:r[u-p],l=n-p<0?1:i[n-p];if(e!==l&&e>1&&l>1)return;c[a-p]=Math.max(e,l)}return c}static index(r,i){let o=new Array(i.length);return ge.fillIndex(r,i,o),o}static fillIndex(r,i,o){let u=r.length-i.length;for(let n=0;n<i.length;n++)o[n]=r[u+n]%i[n]}static calc(r,i,o,u,n){let a=ge.calcShape(r.dims,i.dims);if(a){if(u&&!B.areEqual(a,r.dims))return;let c=B.size(a),p=u?r:new bt(a,n||r.type);if(a.length===0)p.set([],o(r.get([]),i.get([])));else{let e=new Array(a.length),l=new Array(r.dims.length),s=new Array(i.dims.length),d=0,h=0,g=!1,m=!1;r.dims.length===0&&(d=r.get([]),g=!0),i.dims.length===0&&(h=i.get([]),m=!0);let I;for(let _=0;_<c;_++){I=_;for(let v=a.length-1;v>=0;v--)e[v]=I%a[v],I=Math.floor(I/a[v]);g||(ge.fillIndex(e,r.dims,l),d=r.get(l)),m||(ge.fillIndex(e,i.dims,s),h=i.get(s)),p.set(e,o(d,h))}}return p}}static isValidBroadcast(r,i){let o=r.length,u=i.length;if(o>u)return!1;for(let n=1;n<=o;n++)if(r[o-n]!==1&&r[o-n]!==i[u-n])return!1;return!0}static getBroadcastDims(r,i){let o=r.length,u=[];for(let n=0;n<o;n++){let a=o-1-n,c=r[a]||1;(i[i.length-1-n]||1)>1&&c===1&&u.unshift(a)}return u}},Sn=class{static getShapeOfGemmResult(t,r,i,o,u){if(t.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let n,a,c;r?(n=t[1],a=t[0]):(n=t[0],a=t[1]);let p=-1;if(o?(c=i[0],p=1):(c=i[1],p=0),i[p]!==a)throw new Error("dimension mismatch");if(n<=0||c<=0||a<=0)throw new Error("invalid shape specified");if(u&&!kt.isValidBroadcast(u,[n,c]))throw new Error("gemm: invalid bias shape for broadcast");return[n,c,a]}},At=class Jr{static tensorDataTypeFromProto(r){switch(r){case ot.onnx.TensorProto.DataType.INT8:return"int8";case ot.onnx.TensorProto.DataType.UINT8:return"uint8";case ot.onnx.TensorProto.DataType.BOOL:return"bool";case ot.onnx.TensorProto.DataType.INT16:return"int16";case ot.onnx.TensorProto.DataType.UINT16:return"uint16";case ot.onnx.TensorProto.DataType.INT32:return"int32";case ot.onnx.TensorProto.DataType.UINT32:return"uint32";case ot.onnx.TensorProto.DataType.FLOAT:return"float32";case ot.onnx.TensorProto.DataType.DOUBLE:return"float64";case ot.onnx.TensorProto.DataType.STRING:return"string";case ot.onnx.TensorProto.DataType.INT64:return"int32";case ot.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${ot.onnx.TensorProto.DataType[r]}`)}}static tensorDataTypeStringToEnum(r){switch(r){case"int8":return ot.onnx.TensorProto.DataType.INT8;case"uint8":return ot.onnx.TensorProto.DataType.UINT8;case"bool":return ot.onnx.TensorProto.DataType.BOOL;case"int16":return ot.onnx.TensorProto.DataType.INT16;case"uint16":return ot.onnx.TensorProto.DataType.UINT16;case"int32":return ot.onnx.TensorProto.DataType.INT32;case"uint32":return ot.onnx.TensorProto.DataType.UINT32;case"float32":return ot.onnx.TensorProto.DataType.FLOAT;case"float64":return ot.onnx.TensorProto.DataType.DOUBLE;case"string":return ot.onnx.TensorProto.DataType.STRING;case"int64":return ot.onnx.TensorProto.DataType.INT64;case"uint64":return ot.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${r}`)}}static tensorDimsFromProto(r){return r.map(i=>xe.isLong(i)?i.toNumber():i)}static tensorValueTypeFromProto(r){return{tensorType:Jr.tensorDataTypeFromProto(r.elemType),shape:{dims:Jr.tensorDimsFromProto(r.shape.dim.map(i=>i.dimValue))}}}static tensorDimsFromORTFormat(r){let i=[];for(let o=0;o<r.dimsLength();o++)i.push(Rt.longToNumber(r.dims(o)));return i}static tensorAttributesFromORTFormat(r){let i=[];for(let o=0;o<r.attributesLength();o++)i.push(r.attributes(o));return i}},Rt=class{static longToNumber(t,r){return xe.isLong(t)?t.toNumber():t instanceof w.Long?xe.fromValue({low:t.low,high:t.high,unsigned:r??!1}).toNumber():t}static isLong(t){return xe.isLong(t)||t instanceof w.Long}},B=class Wt{static size(r){return Wt.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,i){if(i<0||i>r.length)throw new Error(`invalid dimension of ${i} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return Wt.getSizeFromDimensionRange(r,i,r.length)}static sizeToDimension(r,i){if(i<0||i>r.length)throw new Error(`invalid dimension of ${i} for sizeToDimension as Tensor has ${r.length} dimensions.`);return Wt.getSizeFromDimensionRange(r,0,i)}static getSizeFromDimensionRange(r,i,o){let u=1;for(let n=i;n<o;n++){if(r[n]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");u*=r[n]}return u}static computeStrides(r){let i=r.length;if(i===0)return[];if(i===1)return[1];let o=new Array(i);o[i-1]=1,o[i-2]=r[i-1];for(let u=i-3;u>=0;--u)o[u]=o[u+1]*r[u+1];return o}static transpose(r){return r.slice().reverse()}static indicesToOffset(r,i,o){o===void 0&&(o=r.length);let u=0;for(let n=0;n<o;++n)u+=i[n]*r[n];return u}static offsetToIndices(r,i){let o=i.length;if(o===0)return[];if(o===1)return[r*i[0]];let u=new Array(i.length);for(let n=0;n<u.length-1;++n)u[n]=Math.floor(r/i[n]),r-=u[n]*i[n];return u[u.length-1]=r,u}static normalizeAxis(r,i){if(r<-i&&r>=i)throw new Error("unsupported axis for this operation.");return r<0?r+i:r}static normalizeAxes(r,i){return r.map(o=>this.normalizeAxis(o,i))}static incrementIndex(r,i,o){if(i.length===0||r.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(o===void 0)o=i.length;else if(o<=0||o>i.length)throw new Error("Incorrect axis to increment on");for(let u=o-1;u>=0&&(r[u]++,!(r[u]<i[u]));--u)r[u]=0}static calculateReshapedDims(r,i){if(i.length===0){if(r.length===0||Wt.size(r)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let o=i.length,u=new Array(o),n=-1,a=1;for(let p=0;p<o;p++){if(i[p]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(i[p]===-1){if(n!==-1)throw new Error("at most one dimension in shape hints can be -1");n=p}else{if(i[p]===0){if(p>=r.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");u[p]=r[p]}else u[p]=i[p];a*=u[p]}}let c=Wt.size(r);if(n!==-1){if(c%a!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${r}] Output shape: [${i}]`);u[n]=c/a}else if(a!==c)throw new Error("reshapedDims and originalDims don't have matching sizes");return u}static sortBasedOnPerm(r,i){return i?i.map(o=>r[o]):r.slice().reverse()}static padShape(r,i){let o=r.length;return r.map((u,n)=>u+i[n]+i[n+o])}static areEqual(r,i){return r.length!==i.length?!1:r.every((o,u)=>o===i[u])}static validateDimsAndCalcSize(r){if(r.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let i=1;for(let o of r){if(!Number.isInteger(o))throw new TypeError(`Invalid shape: ${o} is not an integer`);if(o<0||o>2147483647)throw new TypeError(`Invalid shape: length ${o} is not allowed`);i*=o}return i}static flattenShape(r,i){i<0&&(i+=r.length);let o=r.reduce((n,a)=>n*a,1),u=r.slice(i).reduce((n,a)=>n*a,1);return[o/u,u]}static squeezeShape(r,i){let o=new Array;i=Wt.normalizeAxes(i,r.length);for(let u=0;u<r.length;u++){let n=i.indexOf(u)>=0;if(n&&r[u]!==1)throw new Error("squeeze an axis of size different than 1");(i.length===0&&r[u]>1||i.length>0&&!n)&&o.push(r[u])}return o}static unsqueezeShape(r,i){let o=new Array(r.length+i.length);o.fill(0);for(let n=0;n<i.length;n++){let a=Wt.normalizeAxis(i[n],o.length);if(a>=o.length)throw new Error("'axes' has an out of range axis");if(o[a]!==0)throw new Error("'axes' has a duplicate axis");o[a]=1}let u=0;for(let n=0;n<o.length;n++)o[n]===0&&(o[n]=r[u++]);if(u!==r.length)throw new Error("the unsqueezed dimension could not be established");return o}},$r=class Ia{static splitShape(r,i,o,u){if(o.length===0){if(!u)throw new Error("need to know number of outputs when the 'split' attribute is not specified");Ia.determineSplit(r[i],u,o)}let n=[],a=[0];for(let c=0;c<o.length;++c){c!==0&&a.push(a[c-1]+o[c-1]);let p=r.slice();p[i]=o[c],n.push(p)}return[n,a]}static determineSplit(r,i,o){if(r%i!==0)throw new Error("cannot split tensor to equal sized parts");for(let u=0;u<i;++u)o.push(r/i)}},Ue=class be{static adjustPoolAttributes(r,i,o,u,n,a){if(!r&&o.length!==i.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let c=0;c<i.length-2;c++)c>=o.length?o.push(i[c+2]):o[c]=i[c+2];for(let c=0;c<o.length;c++)if(c<u.length){if(u[c]<0)throw new Error("strides should be greater than or equal to 1")}else u.push(1);for(let c=0;c<o.length;c++)if(c<n.length){if(n[c]<0)throw new Error("dilations should be greater than or equal to 1")}else n.push(1);for(let c=0;c<o.length*2;c++)if(c<a.length){if(a[c]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let c=0;c<o.length;c++){if(o[c]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[c]>=o[c]||a[c+o.length]>=o[c])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,i,o,u,n,a){if(a){if(n.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(i.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(u.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let c=0;c<r.length-2;c++)be.adjustPadAndReturnShape(r[c+2],i[c],o[c],u[c],n,c,c+r.length-2,a)}}static computePoolOutputShape(r,i,o,u,n,a,c){if(i.length<=0)throw new Error("input shape must be of size greater than 0");let p=[i[0],i[1]];return be.computeShapeHelper(r,i,p,o,u,n,a,c),p}static computeConvOutputShape(r,i,o,u,n,a,c){if(r.length<=0||i.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let p=[r[0],i[0]];return be.computeShapeHelper(!1,r,p,o,u,n,a,c),p}static computeShapeHelper(r,i,o,u,n,a,c,p){if(r)for(let e=0;e<i.length-2;e++)o.push(1);else for(let e=0;e<i.length-2;e++)o.push(be.adjustPadAndReturnShape(i[e+2],u[e],n[e],a[e],c,e,e+i.length-2,p))}static adjustPadAndReturnShape(r,i,o,u,n,a,c,p){let e=o*(u-1)+1;if(p&&p!=="NOTSET")switch(p){case"VALID":return n[a]=0,n[c]=0,Math.floor((r-e)/i+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let l=((r+i-1)/i-1)*i+u-r;return n[a]=Math.floor(p==="SAME_LOWER"?(l+1)/2:l/2),n[c]=l-n[a],Math.floor((r+l-u)/i+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+n[a]+n[c]-e)/i+1)}},Ve=-34028234663852886e22,ze=34028234663852886e22});function hh(t){switch(t){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${t}`)}}function Wu(t){switch(t){case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.BOOL:return 1;case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT16:return 2;case H.onnx.TensorProto.DataType.FLOAT:case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.UINT32:return 4;case H.onnx.TensorProto.DataType.INT64:case H.onnx.TensorProto.DataType.DOUBLE:case H.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${H.onnx.TensorProto.DataType[t]}`)}}function mh(t,r){return new(ju(r))(t)}function ju(t){switch(t){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ui(t,r){if(r===H.onnx.TensorProto.DataType.INT64||r===si.TensorDataType.INT64){if(t.greaterThanOrEqual(2147483648)||t.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(r===H.onnx.TensorProto.DataType.UINT32||r===si.TensorDataType.UINT32||r===H.onnx.TensorProto.DataType.UINT64||r===si.TensorDataType.UINT64){if(t.greaterThanOrEqual(4294967296)||t.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${H.onnx.TensorProto.DataType[r]}`);return t.toNumber()}function Hu(t,r,i){switch(r){case H.onnx.TensorProto.DataType.BOOL:case H.onnx.TensorProto.DataType.UINT8:return t.getUint8(i);case H.onnx.TensorProto.DataType.INT8:return t.getInt8(i);case H.onnx.TensorProto.DataType.UINT16:return t.getUint16(i,!0);case H.onnx.TensorProto.DataType.INT16:return t.getInt16(i,!0);case H.onnx.TensorProto.DataType.FLOAT:return t.getFloat32(i,!0);case H.onnx.TensorProto.DataType.INT32:return t.getInt32(i,!0);case H.onnx.TensorProto.DataType.UINT32:return t.getUint32(i,!0);case H.onnx.TensorProto.DataType.INT64:return ui(xe.fromBits(t.getUint32(i,!0),t.getUint32(i+4,!0),!1),r);case H.onnx.TensorProto.DataType.DOUBLE:return t.getFloat64(i,!0);case H.onnx.TensorProto.DataType.UINT64:return ui(xe.fromBits(t.getUint32(i,!0),t.getUint32(i+4,!0),!0),r);default:throw new Error(`cannot read from DataView for type ${H.onnx.TensorProto.DataType[r]}`)}}var qu,H,si,bt,We=O(()=>{qu=rr(Fs()),qo(),Pr(),H=rr(sr()),Y(),si=F.experimental.fbs,bt=class Qe{constructor(r,i,o,u,n,a=qu.Guid.create()){this.dims=r,this.type=i,this.dataProvider=o,this.asyncDataProvider=u,this.cache=n,this.dataId=a,this.size=B.validateDimsAndCalcSize(r);let c=this.size,p=o===void 0&&u===void 0&&n===void 0;if(n!==void 0&&n.length!==c)throw new RangeError("Input dims doesn't match data length.");if(i==="string"){if(n!==void 0&&(!Array.isArray(n)||!n.every(e=>typeof e=="string")))throw new TypeError("cache should be a string array");p&&(this.cache=new Array(c))}else{if(n!==void 0){let e=ju(i);if(!(n instanceof e))throw new TypeError(`cache should be type ${e.name}`)}if(p){let e=new ArrayBuffer(c*hh(i));this.cache=mh(e,i)}}}get data(){if(this.cache===void 0){let r=this.dataProvider(this.dataId);if(r.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=r}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(r){return this.data[B.indicesToOffset(r,this.strides)]}set(r,i){this.data[B.indicesToOffset(r,this.strides)]=i}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=B.computeStrides(this.dims)),this._strides}static fromProto(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let i=At.tensorDataTypeFromProto(r.dataType),o=At.tensorDimsFromProto(r.dims),u=new Qe(o,i);if(i==="string")r.stringData.forEach((n,a)=>{u.data[a]=kr(n)});else if(r.rawData&&typeof r.rawData.byteLength=="number"&&r.rawData.byteLength>0){let n=u.data,a=new DataView(r.rawData.buffer,r.rawData.byteOffset,r.rawData.byteLength),c=Wu(r.dataType),p=r.rawData.byteLength/c;if(r.rawData.byteLength%c!==0)throw new Error("invalid buffer length");if(n.length!==p)throw new Error("buffer length mismatch");for(let e=0;e<p;e++){let l=Hu(a,r.dataType,e*c);n[e]=l}}else{let n;switch(r.dataType){case H.onnx.TensorProto.DataType.FLOAT:n=r.floatData;break;case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.INT16:case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.BOOL:n=r.int32Data;break;case H.onnx.TensorProto.DataType.INT64:n=r.int64Data;break;case H.onnx.TensorProto.DataType.DOUBLE:n=r.doubleData;break;case H.onnx.TensorProto.DataType.UINT32:case H.onnx.TensorProto.DataType.UINT64:n=r.uint64Data;break;default:throw new Error("unspecific error")}if(n==null)throw new Error("failed to populate data from a tensorproto value");let a=u.data;if(a.length!==n.length)throw new Error("array length mismatch");for(let c=0;c<n.length;c++){let p=n[c];xe.isLong(p)?a[c]=ui(p,r.dataType):a[c]=p}}return u}static fromData(r,i,o){return new Qe(i,o,void 0,void 0,r)}static fromOrtTensor(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let i=At.tensorDimsFromORTFormat(r),o=At.tensorDataTypeFromProto(r.dataType()),u=new Qe(i,o);if(o==="string")for(let n=0;n<r.stringDataLength();n++)u.data[n]=r.stringData(n);else if(r.rawDataArray()&&typeof r.rawDataLength()=="number"&&r.rawDataLength()>0){let n=u.data,a=new DataView(r.rawDataArray().buffer,r.rawDataArray().byteOffset,r.rawDataLength()),c=Wu(r.dataType()),p=r.rawDataLength()/c;if(r.rawDataLength()%c!==0)throw new Error("invalid buffer length");if(n.length!==p)throw new Error("buffer length mismatch");for(let e=0;e<p;e++){let l=Hu(a,r.dataType(),e*c);n[e]=l}}return u}}});function G(t){return t===1?bh:gh}function Xu(t){let r=G(t);return`${r.version}
      precision highp float;
      ${r.attribute} vec3 position;
      ${r.attribute} vec2 textureCoord;

      ${r.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Ku(t){let r=G(t);return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFrag} vec2 TexCoords;
    ${r.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Ju(t,r){let i=G(t);return`
  void main() {
    int indices[${r}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i.output} = result;
  }
  `}var bh,gh,ut=O(()=>{bh={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},gh={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),j=O(()=>{});async function li(t,r=o=>0,i){return new Promise((o,u)=>{let n=0,a=()=>{if(t()){o();return}n++;let c=r(n);setTimeout(a,c)};a()})}function An(t){return ur(typeof t<"u"&&t.length!==0,()=>"empty string found for sampler name"),"get"+t.charAt(0).toUpperCase()+t.slice(1)}function Yu(t){return ur(typeof t<"u"&&t.length!==0,()=>"empty string found for sampler name"),"get"+t.charAt(0).toUpperCase()+t.slice(1)+"AtOutCoords"}function lr(t,r){let i=JSON.parse(JSON.stringify(t));return i=r,i}function fr(t,r){return r.map(i=>t[i]).join(", ")}function Bt(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function ne(t=6){return["x","y","z","w","u","v"].slice(0,t)}var pe=O(()=>{Y()});function yh(t,r){return ne(r).map(i=>`${t}.${i}`)}function cr(t,r){return r===1?[t]:yh(t,r)}function de(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var He=O(()=>{pe()});function Th(t,r,i){if(t===0)return"false";if(t===1)return`rc > ${r[0]}`;let o="";for(let u=t-2;u<t;u++)o+=`${i[u]} >= ${r[u-t+2]}`,u<t-1&&(o+="||");return o}function wh(t,r){let i=t.length;if(i===0)return"getA(), 0, 0, 0";if(i===1)return`getA(rc),
            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),
            0, 0`;let o="r, c",u="r, cp1",n="rp1, c",a="rp1, cp1",c="";if(i>2)for(let p=0;p<i-2;++p)c=c+`${r[p]},`;return`getA(${c}${o}),
          rEdge ? 0. : getA(${c}${n}),
          cEdge ? 0. : getA(${c}${u}),
          rEdge || cEdge ? 0. : getA(${c}${a})`}function vh(t,r,i,o){return t===0||t===1?"":`
    int r = ${r[t-2]};
    int c = ${r[t-1]};
    int rp1 = ${r[t-2]} + 1;
    int cp1 = ${r[t-1]} + 1;
    bool rEdge = rp1 >= ${o};
    bool cEdge = cp1 >= ${i};
    `}var Zu,xh,Qu,tl=O(()=>{ut(),j(),pe(),He(),Zu={name:"pack",inputNames:["A"],inputTypes:[1]},xh=(t,r)=>{let i=G(t.session.backend.glContext.version),o=r.dims,u=o.length,n=r.dims.length,a=Bt(n),c=cr("rc",n),p=vh(n,c,o[o.length-2],o[o.length-1]),e;u===0?e=[1,1]:u===1?e=[o[0],1]:e=[o[n-1],o[n-2]];let l=Th(n,e,c),s=wh(o,c),d=`
        void main() {
          ${a} rc = getOutputCoords();

          if(${l}) {
            ${i.output} = vec4(0);
          } else {
            ${p}

            ${i.output} = vec4(${s});
          }
        }
      `;return{...Zu,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:2},shaderSource:d}},Qu=(t,r)=>({...Zu,get:()=>xh(t,r)})});function fi(t){if(t.length===0)return[1,1,1];let r=1;for(let i=0;i<t.length-2;++i)r*=t[i];return[r,t.length>1?t[t.length-2]:1,t[t.length-1]]}function rl(t,r){let i=!1;return t.length===0||r.length===0?i=!0:t.length<2||r.length<2?i=t[t.length-1]===r[r.length-1]:i=t[t.length-1]===r[r.length-1]&&t[t.length-2]===r[r.length-2],i}function Oh(t){let r=B.computeStrides(t),i=["b","r","c"],o="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r.map((u,n)=>{let a=`int ${i[n]} = ${o} / ${u}`,c=n===r.length-1?`int ${i[n+1]} = ${o} - ${i[n]} * ${u}`:`index -= ${i[n]} * ${u}`;return`${a}; ${c};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function Sh(t){let r=B.computeStrides(t);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${r[0]} + coords.z * ${r[1]} + coords.y;
  }
`}var Ih,_h,el,nl=O(()=>{Y(),ut(),j(),He(),Ih=t=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${t}`}),_h=(t,r,i,o)=>{let u=r.dims,n=o,a="";for(let e=0;e<4;e++){let l="";switch(e){case 0:l="outputCoords = rc;";break;case 1:l="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:l="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:l="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}a+=`
        ${l}
        ${e>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${e>0?"}":""}
      `}let c=G(t.session.backend.glContext.version),p=`
      ${Oh(u)}
      ${Sh(n)}
      ${de()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${n[2]};
        int cols = ${n[1]};

        ${a}
        ${c.output} = result;
      }
    `;return{...i,output:{dims:n,type:r.type,textureType:2},shaderSource:p,hasMain:!0}},el=(t,r,i)=>{let o=Ih(i);return{...o,get:()=>_h(t,r,o,i)}}}),ci,ol=O(()=>{ut(),j(),ci=(t,r)=>{let i=r.shape,o=G(t.session.backend.glContext.version),u=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`,n={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:i,type:r.tensor.type,textureType:3},shaderSource:u,hasMain:!0};return t.executeProgram(n,[r.tensor])}});function Ph(t,r){if(t===1)return"rc";let i="";for(let o=0;o<t;o++)i+=r[o],o<t-1&&(i+=",");return i}var il,Ah,al,sl=O(()=>{ut(),j(),pe(),He(),il={name:"unpack",inputNames:["A"],inputTypes:[2]},Ah=(t,r)=>{let i=r.dims.length,o=cr("rc",i),u=o.slice(-2),n=Bt(i),a=de(),c=r.dims.length===0?"":Ph(i,o),p=i<=1?"rc":`vec2(${u.join(",")})`,e=G(t.session.backend.glContext.version),l=`
    ${a}
    void main() {
      ${n} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${c});

       ${e.output} = vec4(getChannel(packedInput, ${p}), 0, 0, 0);
     }
   `;return{...il,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:l}},al=(t,r)=>({...il,get:()=>Ah(t,r)})}),Pn,Br,En,Fr=O(()=>{Ut(),Pn=class{constructor(t,r=1){if(r===1)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=r;else if(r===4)this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(t,r){let i,o;return t.constructor!==Float32Array&&(tt.warning("Encoder","data was not of type Float32; creating new Float32Array"),o=new Float32Array(t)),r*this.channelSize>t.length?(tt.warning("Encoder","Source data too small. Allocating larger array"),o=t,i=this.allocate(r*this.channelSize),o.forEach((u,n)=>i[n]=u)):(o=t,i=o),i}allocate(t){return new Float32Array(t*4)}decode(t,r){return this.channelSize===1?t.filter((i,o)=>o%4===0).subarray(0,r):t.subarray(0,r)}},Br=class{constructor(t,r=1,i){if(r!==1&&r!==4)throw new Error(`Invalid number of channels: ${r}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=r,this.textureType=i||t.FLOAT}encode(t,r){let i=t;return this.channelSize===1&&(tt.verbose("Encoder","Exploding into a larger array"),i=this.allocate(r),t.forEach((o,u)=>i[u*4]=o)),i}allocate(t){return new Float32Array(t*4)}decode(t,r){return this.channelSize===1?t.filter((i,o)=>o%4===0).subarray(0,r):t.subarray(0,r)}},En=class{constructor(t,r=1){if(this.channelSize=4,r===1)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=r;else if(r===4)this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(t,r){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,r){if(t instanceof Uint8Array)return t.subarray(0,r);throw new Error(`Invalid array type: ${t.constructor}`)}}}),Cr,ul,pi,ll=O(()=>{Y(),j(),Cr=(t,r,i)=>{let o=i===0||i===1?1:4,u=i===2,n=i===1||i===2,a=i===4?r.length-1:void 0,c=i===4?r.map((p,e)=>e===r.length-1?p*4:p):void 0;return pi(t,r,o,c,{isPacked:u,reverseWH:n,breakAxis:a})},ul=(t,r,i)=>{let o=Cr(t,r,i);return[o.width,o.height]},pi=(t,r,i=1,o,u)=>{let n=!!(u&&u.isPacked),[a,c]=t.computeTextureWH(n&&o||r,u),p=r.length,e=r.slice(0);if(p===0&&(e=[1]),i===1)o=r;else if(n){if(i!==4)throw new Error("a packed texture must be 4-channel");o=r,p>0&&(e[p-1]=Math.ceil(e[p-1]/2)),p>1&&(e[p-2]=Math.ceil(e[p-2]/2))}else if(!o)throw new Error("Unpacked shape is needed when using channels > 1");return{width:a,height:c,channels:i,isPacked:n,shape:e,strides:B.computeStrides(e),unpackedShape:o,reversedWH:u&&u.reverseWH}}}),Dh,Dn,cl=O(()=>{Ut(),We(),Y(),tl(),nl(),ol(),sl(),Fr(),ll(),j(),Dh=(t,r)=>{let i=r.map(u=>`${u.unpackedShape.join(",")};${u.width}x${u.height}`).join("_"),o=t.name;return t.cacheHint&&(o+="["+t.cacheHint+"]"),o+=":"+i,o},Dn=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,r){return ul(this.session.layoutStrategy,t,r)}executeProgram(t,r){if(r.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error("input names size does not match input types");let i=[];for(let p=0;p<t.inputNames.length;++p)i[p]=this.getOrCreateTextureData(r[p],t.inputTypes[p]);let o=Dh(t,i),u=this.session.programManager.getArtifact(o),n=u?u.programInfo:typeof t.get=="function"?t.get():t,a=Cr(this.session.layoutStrategy,n.output.dims,n.output.textureType),c=this.createTextureData(a,n.output.type);return u||(u=this.session.programManager.build(n,i,c),this.session.programManager.setArtifact(o,u)),this.runProgram(u,i,c),c}run(t,r){return this.executeProgram(t,r).tensor}runProgram(t,r,i){for(let o=0;o<r.length;++o)if(!!r[o].isPacked!=(t.programInfo.inputTypes[o]===2))throw new Error(`input[${o}] property packed inconsistent`);if(!!i.isPacked!=(t.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(t,r,i)}getOrCreateTextureData(t,r){let i=this.getTextureData(t.dataId,r===2);if(!i&&(i=this.getTextureData(t.dataId,r!==2),i))return r===2?this.pack(i):this.unpack(i);if(!i){let o=Cr(this.session.layoutStrategy,t.dims,r);if(r===4){let u=t.dims;if(u.length===4){let n=[u[0],Math.ceil(u[1]*u[2]*u[3]/4)],a=Cr(this.session.layoutStrategy,n,r),c=t.numberData;if(u[1]*u[2]*u[3]%4!==0){let p=u[0],e=u[1]*u[2]*u[3],l=Math.ceil(e*1/4)*4,s=p*l;c=new Float32Array(s);for(let d=0;d<p;++d){let h=d*e,g=d*l+d%1*e;c.set(t.numberData.subarray(h,h+e),g)}}return this.createTextureData(a,t.type,c,t,1)}}if(r===2){let u=pi(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),n=this.createTextureData(u,t.type,t.numberData,t,1);i=this.pack(n)}else i=this.createTextureData(o,t.type,t.numberData,t,1)}return i}createTextureDataFromLayoutBindTensor(t,r,i,o){return this.createTextureData(t,r,i,o,1)}createTextureData(t,r,i,o,u){tt.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(t)}]`);let n=this.session.textureManager.createTextureFromLayout(r,t,i,u);return this.createTextureDataFromTexture(t,r,n,o)}reshapeUnpacked(t,r){let i=this.getOrCreateTextureData(t,0),o={channels:i.channels,height:i.height,width:i.width,shape:r.length!==0?r:[1],strides:B.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(o,t.type,i.texture).tensor}reshapePacked(t,r){let i=this.getOrCreateTextureData(t,2);if(rl(t.dims,r)){let c={channels:i.channels,height:i.height,width:i.width,shape:r.length!==0?r:[1],strides:B.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(c,t.type,i.texture).tensor}let o=fi(t.dims),u=fi(r),n=this.reshapePacked(t,o),a=this.run(el(this,n,u),[n]);return this.reshapePacked(a,r)}cast(t,r){let i=this.getOrCreateTextureData(t,0);return this.createTextureDataFromTexture(i,r,i.texture).tensor}createTextureDataFromTexture(t,r,i,o,u){let n={...t,tensor:o||new bt(t.unpackedShape,r,a=>this.readTexture(n),async a=>this.readTextureAsync(n),void 0,u),texture:i};return this.setTextureData(n.tensor.dataId,n,t.isPacked),n}getTextureData(t,r=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,r):r?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,r,i=!1){this.session.isInitializer(t)?this.session.setTextureData(t,r,i):(i?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,r)}isTextureLayoutCached(t,r=!1){return!!this.getTextureData(t.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(ci(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(ci(this,t))}pack(t){return this.executeProgram(Qu(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram(al(this,t.tensor),[t.tensor])}}}),di,W,It=O(()=>{di=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},W=t=>new di(t)}),pl,dl,hl,Lh,$h,ml=O(()=>{It(),ut(),j(),pl={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},dl=(t,r,i)=>($h(r),[t.run({...pl,cacheHint:i.cacheKey,get:()=>Lh(t,r,i)},r)]),hl=t=>{let r=t.attributes.getFloat("epsilon",1e-5),i=t.attributes.getFloat("momentum",.9),o=t.attributes.getInt("spatial",1);return W({epsilon:r,momentum:i,spatial:o})},Lh=(t,r,i)=>{let o=G(t.session.backend.glContext.version),u=r[0].dims.length,[n,a]=t.calculateTextureWidthAndHeight(r[1].dims,0),c=`
  float process(int[${u}] indices) {
    vec2 position = offsetToCoords(indices[1], ${n}, ${a});
    float scale = getColorAsFloat(${o.texture2D}(Scale, position));
    float mean = getColorAsFloat(${o.texture2D}(Mean, position));
    float variance = getColorAsFloat(${o.texture2D}(Variance, position));
    float b = getColorAsFloat(${o.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${i.epsilon})) ) + b;
  }`;return{...pl,output:{dims:r[0].dims,type:r[0].type,textureType:0},shaderSource:c}},$h=t=>{if(!t||t.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let r=t[0],i=t[1],o=t[2],u=t[3],n=t[4];if(r.dims.length<3||i.dims.length!==1||o.dims.length!==1||u.dims.length!==1||n.dims.length!==1)throw new Error("invalid input shape.");if(i.dims[0]!==r.dims[1]||o.dims[0]!==r.dims[1]||u.dims[0]!==r.dims[1]||n.dims[0]!==r.dims[1])throw new Error("invalid input shape.");if(r.type!=="float32"&&r.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||u.type!=="float32"&&u.type!=="float64"||n.type!=="float32"&&n.type!=="float64")throw new Error("invalid input tensor types.")}}),Ln,Ht,k,Nr,$n,Te=O(()=>{Ln=class{constructor(t,r,i,o){this.glContext=t,this.programInfo=r,this.inputTextureLayouts=i,this.outputTextureLayout=o}},Ht=class{constructor(t){this.context=t}},k=class{constructor(t,r){this.routineBody=t,this.dependencies=r}},Nr=class{constructor(t,r,i){this.name=t,i?this.dependencies=i:this.dependencies=[],r&&(this.routineBody=r)}addDependency(t){t&&this.dependencies.push(t)}},$n=class{static returnOrderedNodes(t){if(!t||t.length===0)return[];if(t.length===1)return t;let r=new Set,i=new Set,o=new Array;return this.createOrderedNodes(t,r,i,o),o}static createOrderedNodes(t,r,i,o){for(let u=0;u<t.length;++u)this.dfsTraverse(t[u],r,i,o)}static dfsTraverse(t,r,i,o){if(!t||i.has(t.name))return;if(r.has(t.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(t.name);let u=t.dependencies;if(u&&u.length>0)for(let n=0;n<u.length;++n)this.dfsTraverse(u[n],r,i,o);o.push(t),i.add(t.name),r.delete(t.name)}}});function Bh(){let t="add_";return{body:`
  float ${t}(float a, float b) {
    return a + b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:t,type:0}}function Fh(){let t="div_";return{body:`
  float ${t}(float a, float b) {
    return a / b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:t,type:0}}function Ch(){let t="mul_";return{body:`
  float ${t}(float a, float b) {
    return a * b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:t,type:0}}function Nh(){let t="sub_";return{body:`
  float ${t}(float a, float b) {
    return a - b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:t,type:0}}function Rh(){let t="equal_";return{body:`
  float ${t}(float a, float b) {
    return float(a == b);
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:t,type:0}}function Gh(){let t="greater_";return{body:`
  float ${t}(float a, float b) {
    return float(a > b);
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:t,type:0}}function Mh(){let t="less_";return{body:`
  float ${t}(float a, float b) {
    return float(a < b);
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:t,type:0}}function Uh(){let t="and_";return{body:`
  float ${t}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:t,type:0}}function Vh(){let t="or_";return{body:`
  float ${t}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:t,type:0}}function zh(){let t="xor_";return{body:`
  float ${t}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:t,type:0}}function Wh(){return qh("pow")}function Hh(){let t="prelu_";return{body:`
  float ${t}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:t,type:0}}function qh(t){let r=`${t}_`;return{body:`
  float ${r}(float a, float b) {
    return ${t}(a, b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return ${t}(v1, v2);
  }
  `,name:r,type:0}}var qt,jh,bl,gl,yl,xl,Tl,wl,vl,Il,_l,Ol,Sl,Al,Pl=O(()=>{Y(),Te(),ut(),j(),qt=(t,r,i,o=r[0].type,u)=>{let n=t.session.pack?2:0;return{name:i.name,inputNames:["A","B"],inputTypes:[n,n],cacheHint:u,get:()=>jh(t,r,i,o)}},jh=(t,r,i,o=r[0].type)=>{let u=t.session.pack?2:0,n=!B.areEqual(r[0].dims,r[1].dims),a=r[0].dims,c=t.session.pack;if(n){let l=kt.calcShape(r[0].dims,r[1].dims,!1);if(!l)throw new Error("Can't perform binary op on the given tensors");a=l;let s=a.length,d=r[0].dims.length!==0?r[0].dims.length:1,h=r[1].dims.length!==0?r[1].dims.length:1,g=r[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",m=r[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",I=G(t.session.backend.glContext.version),_=c?`
      ${i.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${i.name}(a, b);
        ${I.output} = result;
      }`:`
      ${i.body}
      float process(int indices[${s}]) {
        int aindices[${d}];
        int bindices[${h}];
        ${g}
        ${m}
        return ${i.name}(_A(aindices), _B(bindices));
      }`;return{name:i.name,inputNames:["A","B"],inputTypes:[u,u],output:{dims:a,type:o,textureType:u},shaderSource:_,hasMain:c}}let p=G(t.session.backend.glContext.version),e=`
    ${i.body}
    void main() {
      vec4 v1 = ${p.texture2D}(A, TexCoords);
      vec4 v2 = ${p.texture2D}(B, TexCoords);
      vec4 result = ${i.name}(v1, v2);
      ${p.output} = result;
    }
    `;return{name:i.name,inputNames:["A","B"],inputTypes:[u,u],output:{dims:r[0].dims,type:o,textureType:u},shaderSource:e,hasMain:!0}},bl=(t,r)=>[t.run(qt(t,r,Bh()),r)],gl=(t,r)=>[t.run(qt(t,r,Uh(),"bool"),r)],yl=(t,r)=>[t.run(qt(t,r,Fh()),r)],xl=(t,r)=>[t.run(qt(t,r,Rh(),"bool"),r)],Tl=(t,r)=>[t.run(qt(t,r,Gh(),"bool"),r)],wl=(t,r)=>[t.run(qt(t,r,Mh(),"bool"),r)],vl=(t,r)=>[t.run(qt(t,r,Ch()),r)],Il=(t,r)=>[t.run(qt(t,r,Vh(),"bool"),r)],_l=(t,r)=>[t.run(qt(t,r,Wh()),r)],Ol=(t,r)=>[t.run(qt(t,r,Hh()),r)],Sl=(t,r)=>[t.run(qt(t,r,Nh()),r)],Al=(t,r)=>[t.run(qt(t,r,zh(),"bool"),r)]}),El,Dl,Kh,Ll=O(()=>{Y(),El=(t,r,i)=>(Kh(r),[t.cast(r[0],i)]),Dl=t=>At.tensorDataTypeFromProto(t.attributes.getInt("to")),Kh=t=>{if(!t||t.length!==1)throw new Error("Cast requires 1 input.");if(t[0].type==="string")throw new Error("Invalid input type.")}}),Jh,Yh,$l,kn,kl=O(()=>{ut(),j(),pe(),He(),Jh=(t,r)=>({name:"Concat (packed)",inputNames:Array.from({length:t},(i,o)=>`X${o}`),inputTypes:Array(t).fill(2),cacheHint:r}),Yh=(t,r,i,o)=>{let u=i[0].dims.slice();if(o>=u.length||o<-1*u.length)throw new Error("axis specified for concat doesn't match input dimensionality");o<0&&(o=u.length+o);let n=u.slice(0);for(let $=1;$<i.length;$++){let Q=i[$].dims.slice();for(let Z=0;Z<u.length;Z++)if(Z===o)n[o]+=Q[Z];else if(u[Z]!==Q[Z])throw new Error("non concat dimensions must match")}let a=n.length,c=cr("coords",a),p=Bt(a),e=de(),l=i.map($=>$.dims),s=ne(a),d=new Array(l.length-1);d[0]=l[0][o];for(let $=1;$<d.length;$++)d[$]=d[$-1]+l[$][o];let h=s[o],g=s.slice(-2),m=s.join(),I=`if (${h} < ${d[0]}) {
        return getChannel(
            getX0(${m}), vec2(${g.join()}));
        }`;for(let $=1;$<d.length;$++){let Q=d[$-1];I+=`
            if (${h} < ${d[$]}  && ${h} >= ${d[$-1]}) {
              return getChannel(
                getX${$}(${kn(s,h,Q)}),
                vec2(${kn(g,h,Q)}));
            }`}let _=d.length,v=d[d.length-1];I+=`
            return getChannel(
              getX${_}(${kn(s,h,v)}),
              vec2(${kn(g,h,v)}));`;let S=G(t.session.backend.glContext.version),E=`
          ${e}
          float getValue(${s.map($=>"int "+$)}) {
            ${I}
          }

          void main() {
            ${p} coords = getOutputCoords();
            int lastDim = coords.${s[a-1]};
            coords.${s[a-1]} = coords.${s[a-2]};
            coords.${s[a-2]} = lastDim;

            vec4 result = vec4(getValue(${c}), 0., 0., 0.);

            ${c[a-1]} = ${c[a-1]} + 1;
            if (${c[a-1]} < ${n[a-1]}) {
              result.g = getValue(${c});
            }

            ${c[a-2]} = ${c[a-2]} + 1;
            if (${c[a-2]} < ${n[a-2]}) {
              result.a = getValue(${c});
            }

            ${c[a-1]} = ${c[a-1]} - 1;
            if (${c[a-2]} < ${n[a-2]} &&
                ${c[a-1]} < ${n[a-1]}) {
              result.b = getValue(${c});
            }
            ${S.output} = result;
          }
        `;return{...r,output:{dims:n,type:i[0].type,textureType:2},shaderSource:E,hasMain:!0}},$l=(t,r,i)=>{let o=Jh(r.length,i.cacheKey);return{...o,get:()=>Yh(t,o,r,i.axis)}},kn=(t,r,i)=>{let o=t.indexOf(r);return t.map((u,n)=>n===o?`${u} - ${i}`:u).join()}}),Bl,Zh,Qh,tm,Fl,em,rm,nm,Cl,om,Nl=O(()=>{It(),j(),kl(),Bl=(t,r,i)=>(om(r),t.session.pack&&r[0].dims.length>1?[t.run($l(t,r,i),r)]:[t.run(tm(t,r,i),r)]),Zh=(t,r)=>({name:"Concat",inputNames:Array.from({length:t},(i,o)=>`X${o}`),inputTypes:Array(t).fill(0),cacheHint:r}),Qh=(t,r,i,o)=>{let u=i[0].dims.slice();if(o>=u.length||o<-1*u.length)throw new Error("axis specified for concat doesn't match input dimensionality");o<0&&(o=u.length+o);let n=u.slice(0);for(let h=1;h<i.length;h++){let g=i[h].dims.slice();for(let m=0;m<u.length;m++)if(m===o)n[o]+=g[m];else if(u[m]!==g[m])throw new Error("non concat dimensions must match")}let a=n.length,c=new Array(i.length),p=0;for(let h=0;h<c.length;++h)p+=i[h].dims[o],c[h]=p;let e="";i.length<5?e=Fl(c):e=em(c);let l=rm(i.length,a),s=nm(c),d=`
        ${l}
        ${s}
        ${e}
        float process(int indices[${a}]) {
          int textureIndex = getTextureWhereDataResides (indices[${o}]);

          if(textureIndex != 0) {
            indices[${o}] = indices[${o}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...r,output:{dims:n,type:i[0].type,textureType:0},shaderSource:d}},tm=(t,r,i)=>{let o=Zh(r.length,i.cacheKey);return{...o,get:()=>Qh(t,o,r,i.axis)}},Fl=t=>`int getTextureWhereDataResides(int index) {
      ${t.map((r,i)=>`if(index<${r}) {return ${i};}
`).join("")}
    }`,em=t=>Fl(t),rm=(t,r)=>{let i=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${r}]) {`];for(let o=0;o<t;++o)o===0?i.push(`	if (textureIndex == ${o}) { return _X${o}(indices); }`):o===t-1?i.push(`	else { return _X${o}(indices); }`):i.push(`	else if (textureIndex == ${o}) { return _X${o}(indices); }`);return i.push("	}"),i.join(`
`)},nm=t=>{let r=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let i=0;i<t.length;++i)i===0?r.push(`	if (index == ${i}) { return ${t[i]}; }`):i===t.length-1?r.push(`	else { return ${t[i]}; }`):r.push(`	else if (index == ${i}) { return ${t[i]}; }`);return r.push("	}"),r.join(`
`)},Cl=t=>W({axis:t.attributes.getInt("axis")}),om=t=>{if(!t||t.length<1)throw new Error("too few inputs");let r=t[0].type,i=t[0].dims.length;if(r==="string")throw new Error("string tensor is not supported yet");for(let o of t){if(o.type!==r)throw new Error("input tensors should be one type");if(o.dims.length!==i)throw new Error("input tensors should have the same shape")}}});function im(){return jt("abs")}function am(){return jt("acos")}function sm(){return jt("asin")}function um(){return jt("atan")}function lm(){return jt("ceil")}function fm(){return jt("cos")}function cm(t){let r="elu";return{body:`
  const float alpha = float(${t});

  float ${r}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function pm(){return jt("exp")}function dm(){return jt("floor")}function hi(t,r){let i="clip";return{body:`
  const float min = float(${t});
  const float max = float(${r});

  float ${i}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${i}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:i,type:0}}function hm(){let t="indentity";return{body:`
  float ${t}_(float a) {
    return a;
  }
  vec4 ${t}_(vec4 v) {
    return v;
  }
  `,name:t,type:0}}function mm(t){let r="leakyRelu";return{body:`
  const float alpha = float(${t});

  float ${r}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function bm(){return jt("log")}function gm(){let t="neg";return{body:`
  float ${t}_(float a) {
    return -a;
  }
  vec4 ${t}_(vec4 v) {
    return -v;
  }
  `,name:t,type:0}}function ym(){let t="not";return{body:`
  float ${t}_(float a) {
    return float( ! bool(a) );
  }
  bool ${t}_(bool a) {
    return !a;
  }
  vec4 ${t}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${t}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:t,type:0}}function xm(){return jt("sin")}function mi(){let t="relu";return{body:`
  float ${t}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${t}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:t,type:0}}function bi(){let t="sigmoid";return{body:`
  float ${t}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${t}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:t,type:0}}function Tm(){return jt("sqrt")}function wm(){return jt("tan")}function vm(){let t="tanh";return{body:`
  float ${t}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${t}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:t,type:0}}function jt(t){return{body:`
  float ${t}_(float a) {
    return ${t}(a);
  }
  vec4 ${t}_(vec4 v) {
    return ${t}(v);
  }
  `,name:t,type:0}}var Im,dt,Rl,Gl,Ml,Ul,gi,Vl,zl,_m,Wl,Hl,ql,jl,Xl,Kl,yi,Jl,Yl,Zl,Ql,tf,ef,rf,nf,of,af,sf,xi=O(()=>{It(),Y(),Te(),ut(),j(),Im=(t,r,i,o)=>{let u=t.session.pack?2:0,n=G(t.session.backend.glContext.version);return{...r,output:{dims:i.dims,type:i.type,textureType:u},shaderSource:`
     ${o.body}
     void main() {
       vec4 v = ${n.texture2D}(A, TexCoords);
       v = ${o.name}_(v);
       ${n.output} = v;
     }
     `,hasMain:!0}},dt=(t,r,i,o)=>{let u=t.session.pack?2:0,n={name:i.name,inputTypes:[u],inputNames:["A"],cacheHint:o};return{...n,get:()=>Im(t,n,r,i)}},Rl=(t,r)=>[t.run(dt(t,r[0],im()),r)],Gl=(t,r)=>[t.run(dt(t,r[0],am()),r)],Ml=(t,r)=>[t.run(dt(t,r[0],sm()),r)],Ul=(t,r)=>[t.run(dt(t,r[0],um()),r)],gi=(t,r,i)=>[t.run(dt(t,r[0],hi(i.min,i.max),i.cacheKey),r)],Vl=t=>W({min:t.attributes.getFloat("min",Ve),max:t.attributes.getFloat("max",ze)}),zl=(t,r)=>{let i=_m(t,r);return gi(t,[r[0]],i)},_m=(t,r)=>{if(r.length>=3&&(!t.session.isInitializer(r[1].dataId)||!t.session.isInitializer(r[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let i=r.length>=3?r[1].numberData[0]:Ve,o=r.length>=3?r[2].numberData[0]:ze;return W({min:i,max:o})},Wl=(t,r)=>[t.run(dt(t,r[0],lm()),r)],Hl=(t,r)=>[t.run(dt(t,r[0],fm()),r)],ql=(t,r,i)=>[t.run(dt(t,r[0],cm(i.alpha),i.cacheKey),r)],jl=t=>W({alpha:t.attributes.getFloat("alpha",1)}),Xl=(t,r)=>[t.run(dt(t,r[0],pm()),r)],Kl=(t,r)=>[t.run(dt(t,r[0],dm()),r)],yi=(t,r)=>[t.run(dt(t,r[0],hm()),r)],Jl=(t,r,i)=>[t.run(dt(t,r[0],mm(i.alpha),i.cacheKey),r)],Yl=t=>W({alpha:t.attributes.getFloat("alpha",.01)}),Zl=(t,r)=>[t.run(dt(t,r[0],bm()),r)],Ql=(t,r)=>[t.run(dt(t,r[0],gm()),r)],tf=(t,r)=>[t.run(dt(t,r[0],ym()),r)],ef=(t,r)=>[t.run(dt(t,r[0],mi()),r)],rf=(t,r)=>[t.run(dt(t,r[0],bi()),r)],nf=(t,r)=>[t.run(dt(t,r[0],xm()),r)],of=(t,r)=>[t.run(dt(t,r[0],Tm()),r)],af=(t,r)=>[t.run(dt(t,r[0],wm()),r)],sf=(t,r)=>[t.run(dt(t,r[0],vm()),r)]});function he(t){let r;switch(t.activation){case"Relu":r=mi();break;case"Sigmoid":r=bi();break;case"Clip":r=hi(t.clipMin,t.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let i=r.name,o=r.body,u=`value = ${i}_(value);`;return{activationFunction:o,applyActivation:u}}var pr,qe=O(()=>{Y(),xi(),pr=t=>{let r=t.getString("activation","");if(r==="Clip"){let[i,o]=t.getFloats("activation_params",[Ve,ze]);return{activation:r,clipMax:o,clipMin:i,activationCacheKey:`${r}:${i},${o}`}}return{activation:r,activationCacheKey:r}}}),Sm,Am,uf,lf=O(()=>{Ut(),ut(),j(),Bn(),qe(),Sm=(t,r)=>({name:"GroupedConv",inputNames:t?["X","W","Bias"]:["X","W"],inputTypes:t?[0,0,0]:[0,0],cacheHint:r}),Am=(t,r,i,o)=>{let u=r.length>2?"value += getBias(output_channel);":"",n=r[0].dims.slice(),a=r[1].dims.slice(),c=a[0]/o.group;tt.verbose("GroupedConv",`autpPad:${o.autoPad}, dilations:${o.dilations}, group:${o.group}, kernelShape:${o.kernelShape}, pads:${o.pads}, strides:${o.strides}`);let p=dr(n,a,o.dilations,o.pads,o.strides),e=G(t.session.backend.glContext.version),{activationFunction:l,applyActivation:s}=he(o),d=`
  const ivec2 strides = ivec2(${o.strides[0]}, ${o.strides[1]});
  const ivec2 pads = ivec2(${o.pads[0]}, ${o.pads[1]});
  ${l}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${c};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {
      int input_channel = group_id * ${a[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${o.dilations[0]};

        if (xHeight < 0 || xHeight >= ${n[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${o.dilations[1]};
          if (xWidth < 0 || xWidth >= ${n[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${u}
    ${s}
    ${e.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:p,type:r[0].type,textureType:0},shaderSource:d,hasMain:!0}},uf=(t,r,i)=>{let o=Sm(r.length>2,i.cacheKey);return{...o,get:()=>Am(t,r,o,i)}}}),Pm,Em,ff,cf=O(()=>{ut(),j(),He(),Pm=t=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:t}),Em=(t,r,i,o,u,n)=>{let a=i.dims,c=o.dims,p=2,e=3,l=u.length,s=[c[1]*c[2]*c[3],u[2]*u[3]],d=c[2]*c[3],h=de(),g=G(t.session.backend.glContext.version),m="";for(let _=0;_<=1;_++)for(let v=0;v<=1;v++)m+=`
            blockIndex = rc.x + ${v};
            pos = rc.y + ${_};

            if(blockIndex < ${s[1]} && pos < ${s[0]}) {
              offsetY = int(blockIndex / (${u[l-1]})) * ${n.strides[0]} -
                ${n.pads[0]};
              d0 = offsetY + ${n.dilations[0]} * (imod(pos, ${d}) / ${c[2]});

              if(d0 < ${a[p]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${u[l-1]}) * ${n.strides[1]} -
                  ${n.pads[1]};
                d1 = offsetX + ${n.dilations[1]} * imod(imod(pos, ${d}), ${c[2]});

                if(d1 < ${a[e]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${_*2+v}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let I=`
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${m}
          ${g.output} = result;
      }
            `;return{...r,output:{dims:s,type:i.type,textureType:2},shaderSource:I,hasMain:!0}},ff=(t,r,i,o,u)=>{let n=Pm(u.cacheKey);return{...n,get:()=>Em(t,n,r,i,o,u)}}});function Lm(t,r,i){let o=r[0].dims,u=r[1].dims,n=kt.calcShape(o,u,!0);if(!n)throw new Error("Can't use matmul on the given tensors");let a=Bt(n.length),c=ne(),{activationFunction:p,applyActivation:e}=he(i),l=r.length>2,s=l?"value += getBiasForMatmul();":"",d=l?`${wi(a,c,r[2].dims,n,!1)}`:"",h=n.length,g=o.length,m=u.length,I=o[o.length-1],_=`
    ${p}
    ${d}
    float process(int indices[${h}]) {
        int a[${g}];
        int b[${m}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${I}; ++k) {
            a[${g-1}] = k;
            b[${m-2}] = k;
            value += _A(a) * _B(b);
        }
        ${s}
        ${e}
        return value;
    }`;return{...t,output:{dims:n,type:r[0].type,textureType:0},shaderSource:_}}function Ti(t,r){let i=Dm(t.length>2,r.activationCacheKey);return{...i,get:()=>Lm(i,t,r)}}function wi(t,r,i,o,u){let n="",a=i.length,c=o.length,p=c-a;c<2&&a>0?n="coords":n=i.map((d,h)=>`coords.${r[h+p]}`).join(", ");let e=kt.getBroadcastDims(i,o).map(d=>`coords.${r[d+p]} = 0;`).join(`
`),l=B.size(i)===1,s="vec4(outputValue.xx, outputValue.yy)";return l&&(s="vec4(outputValue.x)"),u?`
vec4 getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${e}
  vec4 outputValue = getBias(${n});
  return ${s};
}`:`
float getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${e}
  return getBias(coords.x);
}`}var pf,df,Dm,$m,Fn=O(()=>{Y(),j(),pe(),qe(),vi(),pf=(t,r,i)=>($m(r),t.session.pack?[t.run(Cn(t,r,i),r)]:[t.run(Ti(r,i),r)]),df=t=>pr(t.attributes),Dm=(t,r)=>({name:"MatMul",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[0,0,0]:[0,0],cacheHint:r}),$m=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.");if(t[0].type!=="float32"&&t[0].type!=="float64"||t[1].type!=="float32"&&t[1].type!=="float64")throw new Error("inputs should be float type");if(t[0].type!==t[1].type)throw new Error("inputs types should match")}});function Fm(t,r,i,o){let u=[],n=[],a=i[0].dims,c=i[1].dims,p=a.length,e=c.length,l=o.length,s=l-p,d=l-e;u=a.map((v,S)=>`coords.${r[S+s]}`),u[p-1]="i*2",u.join(", "),n=c.map((v,S)=>`coords.${r[S+d]}`),n[e-2]="i*2",n.join(", ");let h=kt.getBroadcastDims(a,o),g=kt.getBroadcastDims(c,o),m=h.map(v=>`coords.${r[v+s]} = 0;`).join(`
`),I=g.map(v=>`coords.${r[v+d]} = 0;`).join(`
`),_=`int lastDim = coords.${r[l-1]};
  coords.${r[l-1]} = coords.${r[l-2]};
  coords.${r[l-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${t} coords = getOutputCoords();
  ${_}
  ${m}
  vec4 outputValue = getA(${u});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${t} coords = getOutputCoords();
  ${_}
  ${I}
  vec4 outputValue = getB(${n});
  return outputValue;
}`}function Cm(t,r){let i="";for(let o=0;o<r-2;o++)i+=`rc.${t[o]}, `;return i+=`rc.${t[r-2]}, i*2`,i}function Nm(t,r){let i="";for(let o=0;o<r-2;o++)i+=`rc.${t[o]}, `;return i+=`i*2, rc.${t[r-1]}`,i}var km,Bm,Cn,vi=O(()=>{Y(),ut(),j(),pe(),qe(),Fn(),km=(t,r)=>({name:"MatMul (packed)",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[2,2,2]:[2,2],cacheHint:r}),Bm=(t,r,i,o)=>{let u=i.length>2,n=u?"value += getBiasForMatmul();":"",a=i[0].dims,c=i[1].dims,p=kt.calcShape(a,c,!0),e=!B.areEqual(i[0].dims,i[1].dims);if(!p)throw new Error("Can't use matmul on the given tensors");let l=a[a.length-1],s=Math.ceil(l/2),d=a.length,h=c.length,g=G(t.session.backend.glContext.version),m=Bt(p.length),I=p.length,_=ne(),{activationFunction:v,applyActivation:S}=he(o),E=u?`${wi(m,_,i[2].dims,p,!0)}`:"",$=e?`${Fm(m,_,i,p)}`:"",Q=e?"getAAtOutCoordsMatmul(i)":`getA(${Cm(_,d)})`,Z=e?"getBAtOutCoordsMatmul(i)":`getB(${Nm(_,h)})`,R=e?"":`${m} rc =
          getOutputCoords(); int lastDim = rc.${_[I-1]}; rc.${_[I-1]} =
          rc.${_[I-2]}; rc.${_[I-2]} = lastDim;
      `,at=`
            ${$}
            ${E}
            ${v}
            void main() {
              ${R}

              vec4 value = vec4(0);
              for (int i = 0; i < ${s}; i++) {
                vec4 a = ${Q};
                vec4 b = ${Z};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${n}
              ${S}
              ${g.output} = value;
            }`;return{...r,output:{dims:p,type:i[0].type,textureType:2},shaderSource:at,hasMain:!0}},Cn=(t,r,i)=>{let o=km(r.length>2,i.activationCacheKey);return{...o,get:()=>Bm(t,o,r,i)}}}),hf,mf=O(()=>{Bn(),cf(),vi(),hf=(t,r,i)=>{let o=r[0].dims,u=r[1].dims,n=dr(o,u,i.dilations,i.pads,i.strides),a=t.run(ff(t,r[0],r[1],n,i),[r[0]]),c=t.reshapePacked(r[1],[u[0],u[1]*u[2]*u[3]]),p=r.length===3?[c,a,r[2]]:[c,a],e=t.run(Cn(t,p,i),p);return t.reshapePacked(e,n)}}),Rm,Gm,bf,Ii,_i=O(()=>{j(),Rm=t=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:t}),Gm=(t,r,i,o,u,n)=>{let a=i.dims,c=o.dims,p=u.length,e=Ii(a,c,u,4),l=`
        const int XC = ${a[1]};
        const int XH = ${a[2]};
        const int XW = ${a[3]};
        const int KH = ${n.kernelShape[0]};
        const int KW = ${n.kernelShape[1]};
        const int dilationH = ${n.dilations[0]};
        const int dilationW = ${n.dilations[1]};
        const int strideH = ${n.strides[0]};
        const int strideW = ${n.strides[1]};
        const int padH = ${n.pads[0]};
        const int padW = ${n.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${p}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${a.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...r,output:{dims:e,type:i.type,textureType:4},shaderSource:l}},bf=(t,r,i,o,u)=>{let n=Rm(u.cacheKey);return{...n,get:()=>Gm(t,n,r,i,o,u)}},Ii=(t,r,i,o=4)=>[i[0],i[2],i[3],Math.ceil(t[1]*r[2]*r[3]/o)]}),Mm,Um,gf,yf=O(()=>{Y(),ut(),j(),qe(),_i(),Mm=(t,r)=>({name:"ConvDotProduct",inputNames:t?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:t?[0,4,0]:[0,4],cacheKey:r.activationCacheKey}),Um=(t,r,i,o,u)=>{let n=i[0].dims,a=i[1].dims,c=[a[0],Math.ceil(n[1]*a[2]*a[3]/4)],p=Ii(n,a,o),[e,l]=t.calculateTextureWidthAndHeight(c,4),s=B.computeStrides(p),[d,h]=t.calculateTextureWidthAndHeight(p,4),g=o.length,m=i.length<3?"0.0":"_B(b)",I=Math.ceil(n[1]*a[2]*a[3]/4),{activationFunction:_,applyActivation:v}=he(u),S=G(t.session.backend.glContext.version),E=`
${_}
float process(int indices[${g}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${s[0]} + im2col[1] * ${s[1]} + im2col[2] * ${s[2]};
  int kernelOffset = indices[1] * ${c[1]};
  float value = ${m};
  for (int i = 0; i < ${I}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${h});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${e}, ${l});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${v}
  return value;
}`;return{...r,output:{dims:o,type:i[0].type,textureType:0},shaderSource:E}},gf=(t,r,i,o)=>{let u=Mm(r.length>2,o);return{...u,get:()=>Um(t,u,r,i,o)}}}),dr,Oi,Vm,zm,Wm,Hm,Si,qm,Bn=O(()=>{It(),Y(),lf(),mf(),yf(),qe(),_i(),Fn(),dr=(t,r,i,o,u)=>{let n=t[0],a=t.slice(2),c=a.length,p=r[0],e=r.slice(2).map((s,d)=>s+(s-1)*(i[d]-1)),l=a.map((s,d)=>s+o[d]+o[d+c]).map((s,d)=>Math.floor((s-e[d]+u[d])/u[d]));return[n,p].concat(...l)},Oi=(t,r,i)=>(qm(r,i),Vm(t,r,i)),Vm=(t,r,i)=>{let o=Hm(i,r),u=t.session.pack,n=o.kernelShape[0]===1&&o.kernelShape[1]===1;return o.group>1?[t.run(uf(t,r,o),r)]:n&&u?[zm(t,r,o)]:u&&r[0].dims.length===4&&r[0].dims[0]===1&&!n?[hf(t,r,o)]:[Wm(t,r,o)]},zm=(t,r,i)=>{let o=r[0].dims,u=r[1].dims,n=dr(o,u,i.dilations,i.pads,i.strides),a=t.reshapeUnpacked(r[0],[o[1],o[2]*o[3]]),c=t.reshapeUnpacked(r[1],[u[0],u[1]]),p=r.length>2?[c,a,r[2]]:[c,a],e=t.run(Ti(p,i),p);return t.reshapeUnpacked(e,n)},Wm=(t,r,i)=>{let o=r[0].dims,u=r[1].dims,n=dr(o,u,i.dilations,i.pads,i.strides),a=t.run(bf(t,r[0],r[1],n,i),[r[0]]),c=r.length===3?[a,r[1],r[2]]:[a,r[1]];return t.run(gf(t,r,n,i),c)},Hm=(t,r)=>{let i=t.kernelShape.slice();if(t.kernelShape.length===0)for(let n=2;n<r[1].dims.length;++n)i.push(r[1].dims[n]);let o=t.pads.slice();Ue.adjustPadsBasedOnAutoPad(r[0].dims,t.strides,t.dilations,i,o,t.autoPad);let u=Object.assign({},t);return Object.assign(u,{kernelShape:i,pads:o,cacheKey:t.cacheKey}),u},Si=t=>{let r=t.attributes,i=pr(r),o=r.getString("auto_pad","NOTSET"),u=r.getInts("dilations",[1,1]),n=r.getInt("group",1),a=r.getInts("kernel_shape",[]),c=r.getInts("pads",[0,0,0,0]),p=r.getInts("strides",[1,1]);return W({autoPad:o,dilations:u,group:n,kernelShape:a,pads:c,strides:p,...i})},qm=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4||t[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=t[0].dims[1],o=t[1].dims[1]*r.group;if(i!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let u=t[0].dims.length-2;if(r.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(r.strides.length!==u)throw new Error(`strides should be ${u}D`);if(r.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(t[0].type!=="float32"||t[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(t.length===3&&t[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),jm,Xm,Km,xf,Jm,Ym,Zm,Qm,tb,eb,Tf,rb,wf=O(()=>{It(),ut(),j(),qe(),jm=(t,r,i,o,u,n)=>(t-1)*r+i+(o-1)*u+1-n,Xm=(t,r,i,o,u)=>{let n=Math.floor(t/2);r==="SAME_UPPER"?(i[o]=n,i[u]=t-n):r==="SAME_LOWER"&&(i[o]=t-n,i[u]=n)},Km=(t,r,i,o,u,n,a,c)=>{let p=t.length-2,e=c.length===0;for(let l=0;l<p;++l){let s=e?t[l+2]*n[l]:c[l],d=jm(t[l+2],n[l],u[l],r[l],i[l],s);Xm(d,o,u,l,l+p),e&&c.push(n[l]*(t[l+2]-1)+a[l]+(r[l]-1)*i[l]+1-u[l]-u[l+p])}},xf=(t,r,i)=>(rb(r,i),Jm(t,r,i)),Jm=(t,r,i)=>{let o=eb(i,r);return[tb(t,r,o)]},Ym=(t,r)=>({name:"ConvTranspose",inputNames:t?["X","W","B"]:["X","W"],inputTypes:t?[0,0,0]:[0,0],cacheHint:r}),Zm=(t,r,i,o)=>{let u=r.length>2?"getB(output_channel)":"0.0",n=r[0].dims,a=r[1].dims,c=a[1],p=a[0]/o.group,e=[r[0].dims[0],r[1].dims[1]*o.group,...o.outputShape],l=G(t.session.backend.glContext.version),{activationFunction:s,applyActivation:d}=he(o),h=`
  const ivec2 strides = ivec2(${o.strides[0]}, ${o.strides[1]});
  const ivec2 pads = ivec2(${o.pads[0]}, ${o.pads[1]});
  ${s}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${c};
    int wOutChannel = output_channel - group_id * ${c};

    float value = ${u};
    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {
      int input_channel = group_id * ${p} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${o.dilations[0]}, wHOff * ${o.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${n[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${n[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${d}
    ${l.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:e,type:r[0].type,textureType:0},shaderSource:h,hasMain:!0}},Qm=(t,r,i)=>{let o=Ym(r.length>2,i.cacheKey);return{...o,get:()=>Zm(t,r,o,i)}},tb=(t,r,i)=>t.run(Qm(t,r,i),r),eb=(t,r)=>{let i=t.kernelShape.slice();if(t.kernelShape.length===0)for(let c=2;c<r[1].dims.length;++c)i.push(r[1].dims[c]);let o=t.pads.slice(),u=t.outputShape.slice(),n=r[0].dims;Km(n,i,t.dilations,t.autoPad,o,t.strides,t.outputPadding,u);let a=Object.assign({},t);return Object.assign(a,{kernelShape:i,pads:o,outputShape:u,cacheKey:t.cacheKey}),a},Tf=t=>{let r=t.attributes,i=pr(r),o=r.getString("auto_pad","NOTSET"),u=r.getInts("dilations",[1,1]),n=r.getInt("group",1),a=r.getInts("kernel_shape",[]),c=r.getInts("output_padding",[0,0]),p=r.getInts("output_shape",[]),e=r.getInts("pads",[0,0,0,0]),l=r.getInts("strides",[1,1]);return W({autoPad:o,dilations:u,group:n,kernelShape:a,outputPadding:c,outputShape:p,pads:e,strides:l,...i})},rb=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4||t[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=t[0].dims[1],o=t[1].dims[0];if(i!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let u=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==u))throw new Error("invalid bias");let n=t[0].dims.length-2;if(r.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(r.strides.length!==n)throw new Error(`strides should be ${n}D`);if(r.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(r.outputPadding.length!==n)throw new Error(`output_padding should be ${n}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if(t[0].type!=="float32"||t[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(t.length===3&&t[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),vf,je,If,nb,_f,ob,ib,ab,Nn=O(()=>{It(),Y(),j(),vf={name:"Transpose",inputNames:["A"],inputTypes:[0]},je=(t,r,i)=>(ab(r),[t.run({...vf,cacheHint:i.cacheKey,get:()=>nb(t,r[0],i.perm)},r)]),If=t=>W({perm:t.attributes.getInts("perm",[])}),nb=(t,r,i)=>{let o=r.dims;i=_f(o,i);let u=ob(o,i),n=o.length,a=`
      ${ib("perm",i,n)}
      float process(int indices[${n}]) {
        int a[${n}];
        perm(a, indices);
        return _A(a);
      }`;return{...vf,output:{dims:u,type:r.type,textureType:0},shaderSource:a}},_f=(t,r)=>(r&&r.length!==t.length&&(r=[...t.keys()].reverse()),r),ob=(t,r)=>(r=_f(t,r),B.sortBasedOnPerm(t,r)),ib=(t,r,i)=>{let o=[];o.push(`void ${t}(out int a[${i}], int src[${i}]) {`);for(let u=0;u<i;++u)o.push(`	a[${r[u]}]=src[${u}];`);return o.push("	}"),o.join(`
`)},ab=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("input should be float tensor")}}),Of,Sf,sb,Af=O(()=>{Nn(),Of=(t,r,i)=>{sb(r);let o=i.blocksize,u=o*o,n=i.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],a=i.mode==="DCR"?[r[0].dims[0],o,o,r[0].dims[1]/u,r[0].dims[2],r[0].dims[3]]:[r[0].dims[0],r[0].dims[1]/u,o,o,r[0].dims[2],r[0].dims[3]],c=t.reshapeUnpacked(r[0],a),p={perm:n,cacheKey:`${n}`},[e]=je(t,[c],p),l=[r[0].dims[0],r[0].dims[1]/u,r[0].dims[2]*o,r[0].dims[3]*o];return[t.reshapeUnpacked(e,l)]},Sf=t=>{let r=t.attributes.getInt("blocksize");if(r<1)throw new Error(`blocksize must be >= 1, but got : ${r} for DepthToSpace`);let i=t.attributes.getString("mode","DCR");if(i!=="DCR"&&i!=="CRD")throw new Error(`unrecognized mode: ${i} for DepthToSpace`);return{mode:i,blocksize:r}},sb=t=>{if(t.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);if(t[0].type==="string"||t[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Pf,Ef,ub,Df=O(()=>{Y(),Pf=(t,r,i)=>{ub(r,i);let o=B.flattenShape(r[0].dims,i);return[t.reshapeUnpacked(r[0],o)]},Ef=t=>t.attributes.getInt("axis",1),ub=(t,r)=>{if(!t||t.length!==1)throw new Error("Flatten requires 1 input.");let i=t[0].dims.length;if(i===0)throw new Error("scalar tensor is not supported.");if(r<-i||r>i)throw new Error("Invalid axis");if(t[0].type==="string")throw new Error("string tensor is not supported.")}}),Pe,Rr=O(()=>{Pe=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),Lf,$f,lb,fb,cb,pb,kf=O(()=>{It(),Rr(),Y(),j(),Lf=(t,r,i)=>(pb(r,i.axis),[t.run(cb(t,r,i),r)]),$f=t=>W({axis:t.attributes.getInt("axis",0)}),lb={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},fb=(t,r,i,o)=>{let u=i[0].dims.slice(),n=i[1].dims.slice(),a=new Array(u.length+n.length-1);o=B.normalizeAxis(o,u.length);let c=[];for(let d=0;d<a.length;d++)d<o?(a[d]=u[d],c.push(`inputIdx[${d}] = outputIdx[${d}];`)):d<o+n.length?(a[d]=n[d-o],c.push(`indexDataIdx[${d-o}] = outputIdx[${d}];`)):(a[d]=u[d-n.length+1],c.push(`inputIdx[${d-n.length+1}] = outputIdx[${d}];`));let p=a.length||1,e=u.length,l=n.length||1,s=`
      float process(int outputIdx[${p}]) {
        int inputIdx[${e}];
        int indexDataIdx[${l}];
        indexDataIdx[0] = 0;
        ${c.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${o}] = idx < 0 ? idx + ${u[o]} : idx;
        return _A(inputIdx);
      }`;return{...r,output:{dims:a,type:i[0].type,textureType:0},shaderSource:s}},cb=(t,r,i)=>{let o={...lb,cacheHint:i.cacheKey};return{...o,get:()=>fb(t,o,r,i.axis)}},pb=(t,r)=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.");let i=t[0].dims.length;if(i<1)throw new Error("Invalid input shape.");if(r<-i||r>i-1)throw new Error("Invalid axis.");if(Pe.indexOf(t[0].type)===-1)throw new Error("Invaid input type.");if(t[1].type!=="int32"&&t[1].type!=="int16")throw new Error("Invaid input type.")}}),Ai,Bf,Ff,Cf,db,hb,mb,Nf=O(()=>{It(),Y(),j(),Ai=(t,r,i)=>(mb(r,i),[t.run(db(r,i),r)]),Bf=(t,r)=>{let i=t.attributes.getInt("transA",0)!==0,o=t.attributes.getInt("transB",0)!==0,u=t.attributes.getFloat("alpha",1),n=t.attributes.getFloat("beta",1);return W({transA:i,transB:o,alpha:u,beta:n,isOptionalC:r})},Ff=t=>Bf(t,!1),Cf=t=>Bf(t,!0),db=(t,r)=>{let i={name:"Gemm",inputNames:t.length===3?["A","B","C"]:["A","B"],inputTypes:t.length===3?[0,0,0]:[0,0],key:r.cacheKey};return{...i,get:()=>hb(i,t,r)}},hb=(t,r,i)=>{let o=r[0].dims.slice(),u=r[1].dims.slice(),[n,a]=Sn.getShapeOfGemmResult(o,i.transA,u,i.transB,r.length===3?r[2].dims:void 0),c=[n,a];if(!c)throw new Error("Can't use gemm on the given tensors");let p=o[o.length-1],e="";i.transA&&(p=o[0]),i.transA&&i.transB?e="value += _A_T(a) * _B_T(b);":i.transA&&!i.transB?e="value += _A_T(a) * _B(b);":!i.transA&&i.transB?e="value += _A(a) * _B_T(b);":!i.transA&&!i.transB&&(e="value += _A(a) * _B(b);");let l=c.length,s=r.length===3?`int c[${r[2].dims.length}];`:"",d=r.length===3?"bcastIndices_C(indices, c);":"",h=r.length===3?"value += beta * _C(c);":"",g=`
      float process(int indices[${l}]) {
          int a[${l}];
          int b[${l}];
          ${s}

          copyVec(indices, a);
          copyVec(indices, b);
          ${d}

          float value = 0.0;
          for (int k=0; k<${p}; ++k) {
              a[${l-1}] = k;
              b[${l-2}] = k;
              ${e}
          }

          value = value * alpha;
          ${h}
          return value;
      }`;return{...t,output:{dims:c,type:r[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:i.alpha},{name:"beta",type:"float",data:i.beta}],shaderSource:g}},mb=(t,r)=>{if(!t)throw new Error("Input is missing");if(r.isOptionalC&&(t.length<2||t.length>3))throw new Error("Invaid input shape.");if(!r.isOptionalC&&t.length!==3)throw new Error("Gemm requires 3 inputs");if(t.length===3&&t[2].dims.length!==1&&t[2].dims.length!==2)throw new Error("Invalid input shape of C");if(t[0].type!=="float32"&&t[0].type!=="float64"||t[1].type!=="float32"&&t[1].type!=="float64"||t.length===3&&t[2].type!=="float32"&&t[2].type!=="float64")throw new Error("Invalid input type.");if(t[0].type!==t[1].type||t.length===3&&t[0].type!==t[2].type)throw new Error("Input types are mismatched")}}),Rf,Gf,bb,gb,yb,xb,Tb,Mf=O(()=>{It(),j(),Rf=(t,r,i)=>(Tb(r),[t.run(yb(t,r,i),r)]),Gf=t=>{let r=t.attributes.getFloat("scale"),i=t.attributes.getFloats("bias");return W({scale:r,bias:i})},bb={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},gb=(t,r,i,o)=>{let u=i[0].dims.slice(),n=u.length,a=`
      ${xb(o.bias.length)}
      float process(int indices[${n}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...r,output:{dims:u,type:i[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:o.bias.length,data:o.bias},{name:"scale",type:"float",data:o.scale}],shaderSource:a}},yb=(t,r,i)=>{let o={...bb,cacheHint:i.cacheKey};return{...o,get:()=>gb(t,o,r,i)}},xb=t=>{let r=[`float getBias(float bias[${t}], int channel) {`];for(let i=0;i<t;++i)i===0?r.push(`	if (channel == ${i}) { return bias[${i}]; }`):i===t-1?r.push(`	else { return bias[${i}]; }`):r.push(`	else if (channel == ${i}) { return bias[${i}]; }`);return r.push("	}"),r.join(`
`)},Tb=t=>{if(!t||t.length!==1)throw new Error("ImageScaler requires 1 input.");if(t[0].dims.length!==4)throw new Error("Invalid input shape.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.")}}),Vf,zf,Uf,wb,vb,Ib,_b,Ob,Sb,Wf=O(()=>{ut(),j(),Vf=(t,r,i)=>{Sb(r);let o=t.run(vb(r[0]),r);return[t.run(Ob(t,r[0],i,o.dims),[r[0],o,r[1],r[2]])]},zf=t=>t.attributes.getFloat("epsilon",1e-5),Uf={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},wb=(t,r)=>{let i=r.dims.slice(),o=i[1],u=i[2]*i[3],n=[i[0],o],a=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${u});
        temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${u});

        return v;
      }`;return{...t,output:{dims:n,type:r.type,textureType:4},shaderSource:a}},vb=t=>({...Uf,get:()=>wb(Uf,t)}),Ib={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},_b=(t,r,i,o,u)=>{let n=G(t.session.backend.glContext.version),[a,c]=t.calculateTextureWidthAndHeight(u,4),[p,e]=[a/4,c],l=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${p}, ${e});
        return ${n.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...r,output:{dims:i.dims,type:i.type,textureType:0},variables:[{name:"epsilon",type:"float",data:o}],shaderSource:l}},Ob=(t,r,i,o)=>{let u={...Ib,cacheHint:`${i}`};return{...u,get:()=>_b(t,u,r,i,o)}},Sb=t=>{if(!t||t.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let r=t[0],i=t[1],o=t[2];if(r.dims.length<3||i.dims.length!==1||o.dims.length!==1)throw new Error("Invalid input shape.");if(i.dims[0]!==r.dims[1]||o.dims[0]!==r.dims[1])throw new Error("Input shapes are mismatched.");if(r.type!=="float32"&&r.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||o.type!=="float32"&&o.type!=="float64")throw new Error("Invalid input type.");if(t[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function Ab(t,r){let i=t[0].dims[1],o=t[0].dims.length,u=-Math.floor((r.size-1)/2),n=Math.ceil((r.size-1)/2),a=`float(${r.alpha}) / float(${r.size})`,c=`float(${r.bias})`,p=`float(${r.beta})`,e=`
    float process(int indices[${o}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${u}; i <= ${n}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${i}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${c} + ${a} * square_sum, ${p});
    }`;return{...jf,cacheHint:r.cacheKey,output:{dims:t[0].dims,type:t[0].type,textureType:0},shaderSource:e}}function Pb(t,r){return{...jf,cacheHint:r.cacheKey,get:()=>Ab(t,r)}}var Hf,qf,jf,Eb,Xf=O(()=>{It(),j(),Hf=(t,r,i)=>(Eb(r),[t.run(Pb(r,i),r)]),qf=t=>{let r=t.attributes.getFloat("alpha",1e-4),i=t.attributes.getFloat("beta",.75),o=t.attributes.getFloat("bias",1),u=t.attributes.getInt("size");return W({alpha:r,beta:i,bias:o,size:u})},jf={name:"LRN",inputNames:["X"],inputTypes:[0]},Eb=t=>{if(!t||t.length!==1)throw new Error("LRN requires 1 input.");if(t[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(t[0].type!=="float32")throw new Error("input should be float type")}}),Db,Pi,Kf,Jf,Yf,Lb,$b,kb,Bb,Fb,Cb,Nb,Rb,Zf=O(()=>{It(),Y(),ut(),j(),Db={name:"Pad",inputNames:["A"],inputTypes:[0]},Pi=(t,r,i)=>(kb(r),[t.run({...Db,cacheHint:i.cacheKey,get:()=>$b(t,r[0],i)},r)]),Kf=t=>{let r=t.attributes.getString("mode","constant"),i=t.attributes.getFloat("value",0),o=t.attributes.getInts("pads");return W({mode:r,value:i,pads:o})},Jf=(t,r,i)=>{Bb(r);let o=Lb(t,r,i);return Pi(t,[r[0]],o)},Yf=t=>t.attributes.getString("mode","constant"),Lb=(t,r,i)=>{if(!t.session.isInitializer(r[1].dataId)||r.length>=3&&!t.session.isInitializer(r[2].dataId))throw new Error("dynamic pad attributes are not allowed");let o=Array.from(r[1].integerData),u=r.length>=3?r[2].floatData[0]:0;return W({mode:i,pads:o,value:u})},$b=(t,r,i)=>{let o=B.padShape(r.dims.slice(),i.pads),u=o.length,n=`
      ${Fb(t,r,i)}
      float process(int[${u}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:o,type:r.type,textureType:0},shaderSource:n}},kb=t=>{if(!t||t.length!==1)throw new Error("Pad requires 1 input");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.")},Bb=t=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(t[1].type!=="int32")throw new Error("Invalid input type.");if(t.length>=3&&t[2].type==="string")throw new Error("Invalid input type.")},Fb=(t,r,i)=>{let o=G(t.session.backend.glContext.version),[u,n]=t.calculateTextureWidthAndHeight(r.dims,0),a=B.computeStrides(r.dims);switch(i.mode){case"constant":return Cb(o,r.dims,a,u,n,i.pads,i.value);case"reflect":return Nb(o,r.dims,a,u,n,i.pads);case"edge":return Rb(o,r.dims,a,u,n,i.pads);default:throw new Error("Invalid mode")}},Cb=(t,r,i,o,u,n,a)=>{let c=r.length,p="";for(let e=c-1;e>=0;--e)p+=`
        k = m[${e}] - ${n[e]};
        if (k < 0)  return constant;
        if (k >= ${r[e]}) return constant;
        offset += k * ${i[e]};
        `;return`
      float padA(int m[${c}]) {
        const float constant = float(${a});
        int offset = 0;
        int k = 0;
        ${p}
        vec2 coords = offsetToCoords(offset, ${o}, ${u});
        float value = getColorAsFloat(${t.texture2D}(A, coords));
        return value;
      }
      `},Nb=(t,r,i,o,u,n)=>{let a=r.length,c="";for(let p=a-1;p>=0;--p)c+=`
        k = m[${p}] - ${n[p]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(r[p]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${r[p]}) { k = _2n_1 - k; }
        }
        offset += k * ${i[p]};
        `;return`
      float padA(int m[${a}]) {
        int offset = 0;
        int k = 0;
        ${c}
        vec2 coords = offsetToCoords(offset, ${o}, ${u});
        float value = getColorAsFloat(${t.texture2D}(A, coords));
        return value;
      }
      `},Rb=(t,r,i,o,u,n)=>{let a=r.length,c="";for(let p=a-1;p>=0;--p)c+=`
        k = m[${p}] - ${n[p]};
        if (k < 0)  k = 0;
        if (k >= ${r[p]}) k = ${r[p]-1};
        offset += k * ${i[p]};
      `;return`
      float padA(int m[${a}]) {
        int offset = 0;
        int k = 0;
        ${c}
        vec2 coords = offsetToCoords(offset, ${o}, ${u});
        float value = getColorAsFloat(${t.texture2D}(A, coords));
        return value;
      }
      `}}),tc,ec,rc,nc,oc,ic,ac,sc,uc,Gb,Qf,lc,Gn,fc,Rn,Mb,cc=O(()=>{It(),Y(),j(),tc=(t,r,i)=>{Gn(r);let o={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[t.run({...o,get:()=>rc(r,o,!1,i)},r)]},ec=t=>{let r=t.attributes.getString("auto_pad","NOTSET"),i=t.attributes.getInt("ceil_mode",0),o=t.attributes.getInt("count_include_pad",0)!==0,u=t.attributes.getInts("kernel_shape"),n=t.attributes.getInts("strides",[]),a=t.attributes.getInts("pads",[]);if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return W({autoPad:r,ceilMode:i,countIncludePad:o,kernelShape:u,strides:n,pads:a})},rc=(t,r,i,o)=>{let[u,n]=uc(t,o,i),a=B.size(u.kernelShape),c="value += _X(x);",p="";u.countIncludePad?p+=`value /= float(${a});`:p+=`value /= float(${a} - pad);`;let e=`
        ${fc(t[0].dims,u,c,p,"0.0")}
      `;return{...r,output:{dims:n,type:t[0].type,textureType:0},shaderSource:e}},nc=(t,r,i)=>{Gn(r);let o={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${i.countIncludePad}`};return[t.run({...o,get:()=>rc(r,o,!0,i)},r)]},oc=t=>{let r=t.attributes.getInt("count_include_pad",0)!==0;return W({autoPad:"",ceilMode:0,countIncludePad:r,kernelShape:[],strides:[],pads:[]})},ic=(t,r,i)=>{Gn(r);let o={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[t.run({...o,get:()=>sc(r,o,!1,i)},r)]},ac=t=>{let r=t.attributes.getString("auto_pad","NOTSET"),i=t.attributes.getInt("ceil_mode",0),o=t.attributes.getInts("kernel_shape"),u=t.attributes.getInts("strides",[]),n=t.attributes.getInts("pads",[]),a=t.attributes.getInt("storage_order",0),c=t.attributes.getInts("dilations",[]);if(a!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return W({autoPad:r,ceilMode:i,countIncludePad:!1,kernelShape:o,strides:u,pads:n,storageOrder:a,dilations:c})},sc=(t,r,i,o)=>{let[u,n]=uc(t,o,i),a=`
      value = max(_X(x), value);
    `,c="",p=`
      ${fc(t[0].dims,u,a,c,"-1e5")}
    `;return{...r,output:{dims:n,type:t[0].type,textureType:0},shaderSource:p}},uc=(t,r,i)=>{let o=t[0].dims.slice(),u=Object.hasOwnProperty.call(r,"dilations"),n=r.kernelShape.slice(),a=r.strides.slice(),c=u?r.dilations.slice():[],p=r.pads.slice();Ue.adjustPoolAttributes(i,o,n,a,c,p);let e=Ue.computePoolOutputShape(i,o,a,c,n,p,r.autoPad),l=Object.assign({},r);return u?Object.assign(l,{kernelShape:n,strides:a,pads:p,dilations:c,cacheKey:r.cacheKey}):Object.assign(l,{kernelShape:n,strides:a,pads:p,cacheKey:r.cacheKey}),[l,e]},Gb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Qf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},lc=(t,r)=>(Gn(r),[t.run({...Qf,get:()=>sc(r,Qf,!0,Gb)},r)]),Gn=t=>{if(!t||t.length!==1)throw new Error("Pool ops requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.")},fc=(t,r,i,o,u)=>{let n=t.length;if(r.kernelShape.length<=2){let a=r.kernelShape[r.kernelShape.length-1],c=r.strides[r.strides.length-1],p=r.pads[r.pads.length/2-1],e=r.pads[r.pads.length-1],l=t[n-1],s="",d="",h="";if(p+e!==0?s=`
          for (int i = 0; i < ${a}; i++) {
            x[${n} - 1] = indices[${n} - 1] * ${c} - ${p} + i;
            if (x[${n} - 1] < 0 || x[${n} - 1] >= ${l}) {
              pad++;
              continue;
            }
            ${i}
          }`:s=`
          for (int i = 0; i < ${a}; i++) {
            x[${n} - 1] = indices[${n} - 1] * ${c} - ${p} + i;
            ${i}
          }`,r.kernelShape.length===2){let g=r.kernelShape[r.kernelShape.length-2],m=r.strides[r.strides.length-2],I=r.pads[r.pads.length/2-2],_=r.pads[r.pads.length-2],v=t[n-2];I+_!==0?d=`
            for (int j = 0; j < ${g}; j++) {
              x[${n} - 2] = indices[${n} - 2] * ${m} - ${I} + j;
              if (x[${n} - 2] < 0 || x[${n} - 2] >= ${v}) {
                pad+= ${a};
                continue;
              }
          `:d=`
            for (int j = 0; j < ${g}; j++) {
              x[${n} - 2] = indices[${n} - 2] * ${m} - ${I} + j;
            `,h=`
          }
        `}return`
        float process(int indices[${n}]) {
          int x[${n}];
          copyVec(indices, x);

          float value = ${u};
          int pad = 0;
          ${d}
          ${s}
          ${h}
          ${o}
          return value;
        }
      `}else{let a=B.size(r.kernelShape),c=B.computeStrides(r.kernelShape),p=c.length,e=r.pads.length,l=Mb(p),s=Rn(t,"inputDims"),d=Rn(r.pads,"pads"),h=Rn(c,"kernelStrides"),g=Rn(r.strides,"strides"),m=r.pads.reduce((_,v)=>_+v),I="";return m?I=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${i}
          }`:I=`
          }
          ${i}
        `,`
        ${l}
        float process(int indices[${n}]) {
          int x[${n}];
          copyVec(indices, x);
          int offset[${p}];
          int pads[${e}];
          int inputDims[${n}];
          int kernelStrides[${p}];
          int strides[${p}];
          ${d}
          ${s}
          ${g}
          ${h}

          float value = ${u};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${a}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${n} - ${p}; j < ${n}; j++) {
              x[j] = indices[j] * strides[j - ${n} + ${p}]
                + offset[j - ${n} + ${p}] - pads[j - 2];
              ${I}
          }
          ${o}

          return value;
        }
      `}},Rn=(t,r)=>{let i="";for(let o=0;o<t.length;o++)i+=`
      ${r}[${o}] = ${t[o]};
    `;return i},Mb=t=>`
  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {
    if (${t} == 0) {
      return;
    }
    for (int i = 0; i < ${t} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${t} - 1] = offset;
  }`}),Xe,Ee,Ub,Vb,pc,dc,hc,mc,bc,gc,yc,xc=O(()=>{It(),Rr(),Y(),j(),Xe=(t,r,i,o,u)=>{Vb(r);let n={name:o,inputNames:["A"],inputTypes:[0]};return[t.run({...n,cacheHint:i.cacheKey,get:()=>Ub(t,r,i,o,u,n)},r)]},Ee=t=>{let r=t.attributes.getInts("axes",[]),i=t.attributes.getInt("keepdims",1)===1;return W({axes:r,keepDims:i})},Ub=(t,r,i,o,u,n)=>{let a=[],c=r[0].dims.length||1,p=[],e=B.normalizeAxes(i.axes,r[0].dims.length),l=u(r,e),s=l[1];for(let h=0;h<r[0].dims.length;h++)e.indexOf(h)>=0||e.length===0?(i.keepDims&&a.push(1),s=`
          for(int j${h} = 0; j${h} < ${r[0].dims[h]}; j${h}++) {
            inputIdx[${h}] = j${h};
            ${s}
          }`):(p.push(`inputIdx[${h}] = outputIdx[${a.length}];`),a.push(r[0].dims[h]));let d=`
      float process(int outputIdx[${a.length||1}]) {
        float value;                 // final result
        int inputIdx[${c}];      // addressing input data
        ${p.join(`
`)}
        ${l[0]}       // init ops for reduce max/min
        ${s}
        ${l[2]}       // final computation for reduce mean
        return value;
      }`;return{...n,output:{dims:a,type:r[0].type,textureType:0},shaderSource:d}},Vb=t=>{if(!t||t.length!==1)throw new Error("Reduce op requires 1 input.");if(Pe.indexOf(t[0].type)===-1)throw new Error("Invalid input type.")},pc=(t,r,i)=>Xe(t,r,i,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),dc=(t,r,i)=>Xe(t,r,i,"ReduceMean",(o,u)=>{let n=1;for(let a=0;a<o[0].dims.length;a++)(u.indexOf(a)>=0||u.length===0)&&(n*=o[0].dims[a]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]}),hc=(t,r,i)=>Xe(t,r,i,"ReduceMax",(o,u)=>{let n=[];for(let a=0;a<o[0].dims.length;a++)(u.indexOf(a)>=0||u.length===0)&&n.push(`inputIdx[${a}] = 0;`);return[`${n.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),mc=(t,r,i)=>Xe(t,r,i,"ReduceMin",(o,u)=>{let n=[];for(let a=0;a<o[0].dims.length;a++)(u.indexOf(a)>=0||u.length===0)&&n.push(`inputIdx[${a}] = 0;`);return[`${n.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),bc=(t,r,i)=>Xe(t,r,i,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),gc=(t,r,i)=>Xe(t,r,i,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),yc=(t,r,i)=>Xe(t,r,i,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),Tc,wc=O(()=>{Y(),Tc=(t,r)=>{let i=B.calculateReshapedDims(r[0].dims,r[1].integerData);return t.session.pack?[t.reshapePacked(r[0],i)]:[t.reshapeUnpacked(r[0],i)]}}),vc,Ei,Ic,_c,Gr,zb,Di,Mn,Li=O(()=>{It(),ut(),j(),vc={name:"Upsample",inputNames:["X"],inputTypes:[0]},Ei=(t,r,i)=>(Di(r,i),[t.run({...vc,cacheHint:i.cacheKey,get:()=>zb(t,r,i)},r)]),Ic=t=>Gr(t,7),_c=t=>Gr(t,9),Gr=(t,r)=>{let i=r>=10,o=t.attributes.getString("mode","nearest");if(o!=="nearest"&&o!=="linear"&&(r<11||o!=="cubic"))throw new Error(`unrecognized mode: ${o}`);let u=[];r<9&&(u=t.attributes.getFloats("scales"),Mn(u,o,i));let n=t.attributes.getFloat("extrapolation_value",0),a=r>10?t.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(a)===-1)throw new Error(`coordinate_transform_mode '${a}' is not supported`);let c=a==="tf_crop_and_resize",p=c,e=o==="nearest"&&r>=11?t.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(e)===-1)throw new Error(`nearest_mode '${e}' is not supported`);let l=t.attributes.getFloat("cubic_coeff_a",-.75),s=t.attributes.getInt("exclude_outside",0)!==0;if(s&&o!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let d=r<11?!0:o==="nearest"&&a==="asymmetric"&&e==="floor",h=0,g=0,m=0;return r>10?t.inputs.length>2?(h=1,g=2,m=3):(g=1,m=2):r===9&&(g=1),W({opset:r,isResize:i,mode:o,scales:u,extrapolationValue:n,coordinateTransformMode:a,useExtrapolation:p,needRoiInput:c,nearestMode:e,cubicCoefficientA:l,excludeOutside:s,useNearest2xOptimization:d,roiInputIdx:h,scalesInputIdx:g,sizesInputIdx:m})},zb=(t,r,i)=>{let o=G(t.session.backend.glContext.version),[u,n]=t.calculateTextureWidthAndHeight(r[0].dims,0),a=r[0].dims.map((m,I)=>Math.floor(m*i.scales[I])),[c,p]=t.calculateTextureWidthAndHeight(a,0),e=a.length,l=new Array(e),s=new Array(e),d=`
      int output_pitches[${e}];
      int input_pitches[${e}];
      `;for(let m=e-1;m>=0;m--)l[m]=m===e-1?1:l[m+1]*a[m+1],s[m]=m===e-1?1:s[m+1]*r[0].dims[m+1],d+=`
        output_pitches[${m}] = ${l[m]};
        input_pitches[${m}] = ${s[m]};
        `;let h=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${u}, ${n});
        float value = getColorAsFloat(${o.texture2D}(X, coords));
        return value;
      }
      `,g=i.mode==="nearest"?`
    ${h}
    float process(int indices[${e}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${d}

      int d, m;
      for (int dim = 0; dim < ${e}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:e===4?`
    ${h}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${r[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${h}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${r[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...vc,output:{dims:a,type:r[0].type,textureType:0},shaderSource:g,variables:[{name:"scales",type:"int",arrayLength:i.scales.length,data:i.scales.map(m=>Math.ceil(m))}]}},Di=(t,r)=>{if(!t||r.opset<9&&t.length!==1||r.opset>=9&&r.opset<11&&t.length!==2||r.opset>=11&&t.length<2)throw new Error("invalid inputs.");if(r.scales.length>0&&t[0].dims.length!==r.scales.length)throw new Error("Invalid input shape.");if(t[0].type==="string")throw new Error("Invalid input tensor types.")},Mn=(t,r,i)=>{if(i){for(let o of t)if(o<=0)throw new Error("Scale value should be greater than 0.")}else for(let o of t)if(o<1)throw new Error("Scale value should be greater than or equal to 1.");if((r==="linear"||r==="cubic")&&t.length!==2&&(t.length!==4||t[0]!==1||t[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${i?"Resize":"Upsample"} opeartor.`)}}),$i,ki,Oc,Sc,Wb,Hb,qb,jb,Ac=O(()=>{ut(),j(),pe(),He(),Li(),$i={name:"Resize",inputNames:["A"],inputTypes:[2]},ki=(t,r,i)=>(Di(r,i),[t.run({...$i,cacheHint:i.cacheKey,get:()=>Wb(t,r,i)},r)]),Oc=t=>Gr(t,10),Sc=t=>Gr(t,11),Wb=(t,r,i)=>{let o=G(t.session.backend.glContext.version),[u,n]=Hb(r,i);if(u.every(v=>v===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return{...$i,output:{dims:n,type:r[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${o.texture2D}(X, TexCoords);
                    ${o.output} = v;
                }`};let a=n.length;if(a<2)throw new Error(`output dimension should be at least 2, but got ${a}`);let c=n[a-2],p=n[a-1],e=r[0].dims;if(a!==e.length)throw new Error(`output dimension should match input ${e.length}, but got ${a}`);let l=e[a-2],s=e[a-1],d=u[a-2],h=u[a-1],g="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":g=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":g=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":g=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${p}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${c}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${p}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${c}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":g=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${p}.0 - 1.0, ${c}.0 - 1.0, ${p}.0 - 1.0,
                            ${c}.0 - 1.0);
                        vec4 original = vec4(${s}.0 - 1.0, ${l}.0 - 1.0, ${s}.0 - 1.0,
                            ${l}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let m=Bt(a),I=de(),_=`
            const vec2 inputWH = vec2(${l}.0, ${s}.0);
            const vec4 scaleWHWH = vec4(float(${d}), float(${h}), float(${d}), float(${h}));
            ${I}
            ${g}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${m} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${c-1};
                bool hasNextCol = rc.z < ${p-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${o.output} = vec4(newValue);
            }
        `;return{...$i,output:{dims:n,type:r[0].type,textureType:2},hasMain:!0,shaderSource:_}},Hb=(t,r)=>{let i=t[0].dims,o=r.scales,u;if(o.length===0){let a=t[r.scalesInputIdx];if(a&&a.size!==0){if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");o=qb(a,r.mode,r.isResize)}else{let c=t[r.sizesInputIdx];if(!c||c.size===0)throw new Error("Either scales or sizes MUST be provided as input.");u=Array.from(c.integerData),o=jb(u,i,r.mode,r.isResize)}}else if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let n=u||i.map((a,c)=>Math.floor(a*o[c]));return[o,n]},qb=(t,r,i)=>{let o=Array.from(t.floatData);return Mn(o,r,i),o},jb=(t,r,i,o)=>{let u=r.length,n=new Array(u);for(let a=0,c=u;a<c;a++)if(r[a]===0){if(t[a]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");n[a]=1}else n[a]=t[a]/r[a];return Mn(n,i,o),n}}),Pc,Xb,Ec=O(()=>{We(),Pc=(t,r)=>(Xb(r),[new bt([r[0].dims.length],"int32",void 0,void 0,new Int32Array(r[0].dims))]),Xb=t=>{if(!t||t.length!==1)throw new Error("Shape requires 1 input.")}}),Bi,Dc,Lc,$c,Kb,kc,Jb,Yb,Bc=O(()=>{It(),Rr(),Y(),j(),Bi={name:"Slice",inputNames:["A"],inputTypes:[0]},Dc=(t,r,i)=>(Kb(r),[t.run({...Bi,cacheHint:i.cacheKey,get:()=>$c(t,r[0],i)},r)]),Lc=t=>{let r=t.attributes.getInts("starts"),i=t.attributes.getInts("ends"),o=t.attributes.getInts("axes",[]);return W({starts:r,ends:i,axes:o})},$c=(t,r,i)=>{let o=i.axes.length===0?r.dims.slice(0).map((l,s)=>s):i.axes,u=B.normalizeAxes(o,r.dims.length),n=i.starts.map((l,s)=>l>r.dims[u[s]]-1?r.dims[u[s]]:B.normalizeAxis(l,r.dims[u[s]])),a=i.ends.map((l,s)=>l>r.dims[u[s]]-1?r.dims[u[s]]:B.normalizeAxis(l,r.dims[u[s]])),c=r.dims.slice(),p=[];for(let l=0;l<u.length;l++)c[u[l]]=a[l]-n[l],n[l]>0&&p.push(`outputIdx[${u[l]}] += ${n[l]};`);let e=`
      float process(int outputIdx[${c.length}]) {
        ${p.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Bi,output:{dims:c,type:r.type,textureType:0},shaderSource:e}},Kb=t=>{if(!t||t.length!==1)throw new Error("Slice requires 1 input.");if(Pe.indexOf(t[0].type)===-1)throw new Error("Invalid input type.")},kc=(t,r)=>{Yb(r);let i=Jb(t,r);return[t.run({...Bi,cacheHint:i.cacheKey,get:()=>$c(t,r[0],i)},[r[0]])]},Jb=(t,r)=>{if(!t.session.isInitializer(r[1].dataId)||!t.session.isInitializer(r[2].dataId)||r.length>=4&&!t.session.isInitializer(r[3].dataId)||r.length>=5&&!t.session.isInitializer(r[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(r.length>=5&&r[4].integerData.some(a=>a!==1))throw new Error("currently non-1 steps is not supported for Slice");let i=Array.from(r[1].integerData),o=Array.from(r[2].integerData),u=r.length>=4?Array.from(r[3].integerData):[],n=`${u};${i};${o}`;return{starts:i,ends:o,axes:u,cacheKey:n}},Yb=t=>{if(!t||t.length<3||t.length>5)throw new Error("Invalid input number.");if(t[1].type!=="int32"||t[1].dims.length!==1)throw new Error("Invalid input type.");if(t[2].type!=="int32"||t[2].dims.length!==1)throw new Error("Invalid input type.");if(t.length>=4&&(t[3].type!=="int32"||t[3].dims.length!==1))throw new Error("Invalid input type.");if(t.length>=5&&(t[4].type!=="int32"||t[4].dims.length!==1))throw new Error("Invalid input type.")}}),Fc,Cc,Nc,Rc,Gc,Mc,Uc,Vc,Zb,Qb,tg,zc,Wc=O(()=>{It(),Y(),ut(),j(),Nn(),Fc={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Cc={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Nc={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Rc=(t,r,i)=>{zc(r);let o=r[0].dims.slice(),u=B.normalizeAxis(i.axis,o.length),n=B.sizeToDimension(o,u),a=B.sizeFromDimension(o,u);return Vc(t,r,i,n,a)},Gc=t=>W({axis:t.attributes.getInt("axis",1)}),Mc=t=>W({axis:t.attributes.getInt("axis",-1)}),Uc=(t,r,i)=>{zc(r);let o=r[0].dims.slice(),u=B.normalizeAxis(i.axis,o.length),n=o.length,a=u!==n-1,c=[],p=[],e=[],l;a&&(p=Array.from({length:n}).map((g,m)=>m),p[u]=n-1,p[n-1]=u,p.map(g=>c.push(o[g])),l=W({perm:p}),e=je(t,r,l));let s=a?B.sizeToDimension(c,n-1):B.sizeToDimension(o,n-1),d=a?B.sizeFromDimension(c,n-1):B.sizeFromDimension(o,n-1),h=Vc(t,a?e:r,i,s,d);return a?je(t,h,l):h},Vc=(t,r,i,o,u)=>{let n=Zb(t,r[0],o,u,[o]),a=t.run({...Fc,cacheHint:i.cacheKey,get:()=>n},r),c=Qb(t,r[0],o,u,n.output.dims,[o]),p=t.run({...Cc,cacheHint:i.cacheKey,get:()=>c},[r[0],a]),e=tg(t,r[0],o,u,n.output.dims,c.output.dims);return[t.run({...Nc,cacheHint:i.cacheKey,get:()=>e},[r[0],a,p])]},Zb=(t,r,i,o,u)=>{let[n,a]=t.calculateTextureWidthAndHeight(r.dims,0),c=u.length;if(i<1||o<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(u.length!==1)throw new Error("Dimensionality of the output should be 1");if(u[0]!==i)throw new Error("Shape of the output should be equal to logical row count");let p=G(t.session.backend.glContext.version),e=`
      float process(int[${c}] indices) {
        int logical_row_start_offset = indices[0] * ${o};

        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${n},
        ${a} )));
        for(int i=1; i<${o}; ++i)
        {
          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${n}, ${a})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Fc,output:{dims:u,type:r.type,textureType:0},shaderSource:e}},Qb=(t,r,i,o,u,n)=>{let[a,c]=t.calculateTextureWidthAndHeight(r.dims,0),p=n.length;if(i<1||o<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(n.length!==1)throw new Error("Dimensionality of the output should be 1");if(n[0]!==i)throw new Error("Shape of the output should be equal to logical row count");if(u.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(u[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let e=G(t.session.backend.glContext.version),l=`
      float process(int[${p}] indices) {
        int logical_row_start_offset = indices[0] * ${o};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${o}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${e.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${a}, ${c}))) - max);
        }

        return norm_factor;
      }`;return{...Cc,output:{dims:n,type:r.type,textureType:0},shaderSource:l}},tg=(t,r,i,o,u,n)=>{let[a,c]=t.calculateTextureWidthAndHeight(r.dims,0),p=r.dims.length;if(i<1||o<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(u.length!==1||n.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(u[0]!==i||n[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let e=`
      float process(int[${p}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${a}, ${c});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${o};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Nc,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:e}},zc=t=>{if(!t||t.length!==1)throw new Error("Softmax requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type")}}),Hc,qc,jc,eg,rg,ng,Xc=O(()=>{It(),Y(),j(),Hc={name:"Split",inputNames:["A"],inputTypes:[0]},qc=(t,r,i)=>{ng(r);let o=B.normalizeAxis(i.axis,r[0].dims.length),u=eg(t,r,o,i),n=[];for(let a=0;a<u;++a)n.push(t.run({...Hc,cacheHint:`${i.cacheKey};${a}`,get:()=>rg(t,r[0],i,o,a)},r));return n},jc=t=>{let r=t.attributes.getInt("axis",0),i=t.attributes.getInts("split",[]),o=t.outputs.length;return W({axis:r,split:i,numOutputs:o})},eg=(t,r,i,o)=>{let[,u]=$r.splitShape(r[0].dims,i,o.split,o.numOutputs);return u.length},rg=(t,r,i,o,u)=>{let[n,a]=$r.splitShape(r.dims,o,i.split,i.numOutputs),c=a[u],p=n[u],e=`
      float process(int indices[${p.length}]) {
        indices[${o}] += ${c};
        return _A(indices);
      }
    `;return{...Hc,cacheHint:`${i.cacheKey}:${u}`,output:{dims:p,type:r.type,textureType:0},shaderSource:e}},ng=t=>{if(!t||t.length!==1)throw new Error("Split requires one input.");if(t[0].type!=="int8"&&t[0].type!=="uint8"&&t[0].type!=="int16"&&t[0].type!=="uint16"&&t[0].type!=="int32"&&t[0].type!=="uint32"&&t[0].type!=="float32"&&t[0].type!=="float64"&&t[0].type!=="bool")throw new Error("Invalid input type.")}}),Fi,Kc,Jc,og,ig,Yc=O(()=>{Y(),Fi=(t,r,i)=>{og(r);let o=B.squeezeShape(r[0].dims,i);return[t.reshapeUnpacked(r[0],o)]},Kc=(t,r)=>(ig(r),Fi(t,[r[0]],Array.from(r[1].integerData))),Jc=t=>t.attributes.getInts("axes"),og=t=>{if(!t||t.length!==1)throw new Error("Squeeze requires 1 input.");if(t[0].type==="string")throw new Error("invalid input tensor types.")},ig=t=>{if(!t||t.length!==2)throw new Error("Squeeze requires 2 inputs.");if(t[1].type!=="int32")throw new Error("Invalid input type.")}}),Zc,ag,sg,Qc=O(()=>{ut(),j(),Zc=(t,r)=>{sg(r);let i={name:"Sum",inputNames:r.map((o,u)=>`X${u}`),inputTypes:new Array(r.length).fill(0)};return[t.run({...i,get:()=>ag(t,r,i)},r)]},ag=(t,r,i)=>{let o=G(t.session.backend.glContext.version),u=r[0].dims.slice(),n=`
      void main() {
        vec4 result = ${r.map((a,c)=>`${o.texture2D}(X${c},TexCoords)`).join(" + ")};
        ${o.output} = result;
      }
    `;return{...i,output:{dims:u,type:r[0].type,textureType:0},hasMain:!0,shaderSource:n}},sg=t=>{if(!t||t.length===0)throw new Error("Sum requires inputs.");let r=t[0].dims.length;for(let i=1;i<t.length;i++){if(r!==t[i].dims.length)throw new Error("Input shapes are mismatched.");for(let o=0;o<r;o++)if(t[0].dims[o]!==t[i].dims[o])throw new Error("Input shapes are not matched.")}if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.");for(let i=1;i<t.length;i++)if(t[0].type!==t[i].type)throw new Error("Input types are not matched.")}}),tp,ug,lg,ep=O(()=>{Rr(),j(),tp=(t,r)=>{lg(r);let i={name:"Tile",inputNames:["A"],inputTypes:[0]};return[t.run({...i,get:()=>ug(t,r,i)},r)]},ug=(t,r,i)=>{let o=r[0].dims.slice(),u=new Array(o.length),n=[];for(let p=0;p<o.length;p++)u[p]=o[p]*r[1].numberData[p],n.push(`inputIdx[${p}] = int(mod(float(outputIdx[${p}]), ${o[p]}.));`);let a=u.length,c=`
      float process(int outputIdx[${a}]) {
        int inputIdx[${a}];
        ${n.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...i,output:{dims:u,type:r[0].type,textureType:0},shaderSource:c}},lg=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 input.");if(t[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(t[1].dims[0]!==t[0].dims.length)throw new Error("Invalid input shape.");if(Pe.indexOf(t[0].type)===-1)throw new Error("Invalid input type.");if(t[1].type!=="int32"&&t[1].type!=="int16")throw new Error("Invalid repeat type.")}}),Ci,rp,np,fg,cg,op=O(()=>{Y(),Ci=(t,r,i)=>{fg(r);let o=B.unsqueezeShape(r[0].dims,i);return[t.reshapeUnpacked(r[0],o)]},rp=(t,r)=>(cg(r),Ci(t,[r[0]],Array.from(r[1].integerData))),np=t=>t.attributes.getInts("axes"),fg=t=>{if(!t||t.length!==1)throw new Error("Unsqueeze requires 1 input.");if(t[0].type==="string")throw new Error("invalid input tensor types.")},cg=t=>{if(!t||t.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(t[1].type!=="int32")throw new Error("Invalid input type.")}}),ip,ap=O(()=>{ml(),Pl(),Ll(),Nl(),Bn(),wf(),Af(),Df(),kf(),Nf(),Mf(),Wf(),Xf(),Fn(),Zf(),cc(),xc(),wc(),Ac(),Ec(),Bc(),Wc(),Xc(),Yc(),Qc(),ep(),Nn(),xi(),op(),Li(),ip=[["Abs","","6+",Rl],["Acos","","7+",Gl],["Add","","7+",bl],["And","","7+",gl],["Asin","","7+",Ml],["Atan","","7+",Ul],["AveragePool","","7+",tc,ec],["BatchNormalization","","7+",dl,hl],["Cast","","6+",El,Dl],["Ceil","","6+",Wl],["Clip","","6-10",gi,Vl],["Clip","","11+",zl],["Concat","","4+",Bl,Cl],["Conv","","1+",Oi,Si],["ConvTranspose","","1+",xf,Tf],["Cos","","7+",Hl],["Div","","7+",yl],["Dropout","","7+",yi],["DepthToSpace","","1+",Of,Sf],["Equal","","7+",xl],["Elu","","6+",ql,jl],["Exp","","6+",Xl],["Flatten","","1+",Pf,Ef],["Floor","","6+",Kl],["FusedConv","com.microsoft","1+",Oi,Si],["Gather","","1+",Lf,$f],["Gemm","","7-10",Ai,Ff],["Gemm","","11+",Ai,Cf],["GlobalAveragePool","","1+",nc,oc],["GlobalMaxPool","","1+",lc],["Greater","","7+",Tl],["Identity","","1+",yi],["ImageScaler","","1+",Rf,Gf],["InstanceNormalization","","6+",Vf,zf],["LeakyRelu","","6+",Jl,Yl],["Less","","7+",wl],["LRN","","1+",Hf,qf],["Log","","6+",Zl],["MatMul","","1+",pf,df],["MaxPool","","1+",ic,ac],["Mul","","7+",vl],["Neg","","6+",Ql],["Not","","1+",tf],["Or","","7+",Il],["Pad","","2-10",Pi,Kf],["Pad","","11+",Jf,Yf],["Pow","","7+",_l],["PRelu","","7+",Ol],["ReduceLogSum","","1+",gc,Ee],["ReduceMax","","1+",hc,Ee],["ReduceMean","","1+",dc,Ee],["ReduceMin","","1+",mc,Ee],["ReduceProd","","1+",bc,Ee],["ReduceSum","","1-12",pc,Ee],["ReduceSumSquare","","1+",yc,Ee],["Relu","","6+",ef],["Reshape","","5+",Tc],["Resize","","10",ki,Oc],["Resize","","11+",ki,Sc],["Shape","","1+",Pc],["Sigmoid","","6+",rf],["Sin","","7+",nf],["Slice","","10+",kc],["Slice","","1-9",Dc,Lc],["Softmax","","1-12",Rc,Gc],["Softmax","","13+",Uc,Mc],["Split","","2-12",qc,jc],["Sqrt","","6+",of],["Squeeze","","1-12",Fi,Jc],["Squeeze","","13+",Kc],["Sub","","7+",Sl],["Sum","","6+",Zc],["Tan","","7+",af],["Tanh","","6+",sf],["Tile","","6+",tp],["Transpose","","1+",je,If],["Upsample","","7-8",Ei,Ic],["Upsample","","9",Ei,_c],["Unsqueeze","","1-12",Ci,np],["Unsqueeze","","13+",rp],["Xor","","7+",Al]]});function up(t){let r={},i;for(;(i=sp.exec(t))!==null;){let o=i[3].split(",").map(u=>{let n=u.trim().split(" ");return n&&n.length===2?{type:n[0],name:n[1]}:null}).filter(u=>u!==null);r[i[2]]={params:o,body:i[4]}}for(let o in r){let u=pg.replace("__FUNC__",o),n=new RegExp(u,"gm");for(;(i=n.exec(t))!==null;){let a=i[1],c=i[2],p=i[3].split(","),e=a?`${a} ${c};`:"",l=r[o].body,s="";r[o].params.forEach((h,g)=>{h&&(s+=`${h.type} ${h.name} = ${p[g]};
`)}),l=`${s}
 ${l}`,l=l.replace("return",`${c} = `);let d=`
      ${e}
      {
        ${l}
      }
      `;t=t.replace(i[0],d)}}return t=t.replace(sp,""),t}var sp,pg,lp=O(()=>{sp=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,pg="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function hr(t,r){let i=[],o=[];for(let u=0;u<t.length;++u)t[u]!==1&&(i.push(t[u]),o.push(u));return{newShape:i,keptDims:o}}function mg(t){if(t.length===0)return 1;let r=t[0];for(let i=1;i<t.length;i++)r*=t[i];return r}function fp(t){let r=Math.ceil(Math.sqrt(t));return[r,Math.ceil(t/r)]}var Un,Ni=O(()=>{Ut(),Y(),Un=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,r){let i=this.computeTexture(t,r);return r&&r.isPacked&&(i[0]/=2,i[1]/=2),r&&r.reverseWH?[i[1],i[0]]:i}computeTexture(t,r){let i=r&&r.isPacked;if(t.length===0)return i?[2,2]:[1,1];let o=this.maxTextureSize;if(r&&r.breakAxis!==void 0){let a=r.breakAxis>=t.length?1:t.slice(r.breakAxis).reduce((p,e)=>p*e),c=r.breakAxis<=0?1:t.slice(0,r.breakAxis).reduce((p,e)=>p*e);if(a>o||c>o)tt.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${r.breakAxis}`);else return[a,c]}let u=t.slice(0);i&&(o=o*2,u=u.map((a,c)=>c>=u.length-2?u[c]%2===0?u[c]:u[c]+1:u[c]),u.length===1&&(u=[2,u[0]])),u.length!==2&&(u=hr(u).newShape);let n=mg(u);return u.length<=1&&n<=o?[1,n]:u.length===2&&u[0]<=o&&u[1]<=o?u:u.length===3&&u[0]*u[1]<=o&&u[2]<=o?[u[0]*u[1],u[2]]:u.length===3&&u[0]<=o&&u[1]*u[2]<=o?[u[0],u[1]*u[2]]:u.length===4&&u[0]*u[1]*u[2]<=o&&u[3]<=o?[u[0]*u[1]*u[2],u[3]]:u.length===4&&u[0]<=o&&u[1]*u[2]*u[3]<=o?[u[0],u[1]*u[2]*u[3]]:i?fp(n/4).map(a=>a*2):fp(n)}}}),Vn,cp=O(()=>{Y(),Te(),ut(),Ni(),pe(),Vn=class extends Ht{constructor(t){super(t)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let t="offsetToCoords";return{offsetToCoords:new k(`
      vec2 ${t}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let t="coordsToOffset";return{coordsToOffset:new k(`
      int ${t}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let t=this.context.outputTextureLayout;return t.isPacked?this.getPackedOutputSamplingSnippet(t):this.getUnpackedOutputSamplingSnippet(t)}getPackedOutputSamplingSnippet(t){let r=t.unpackedShape,i=[t.width,t.height],o={},u="getOutputCoords";switch(r.length){case 0:o[u]=this.getOutputScalarCoords();break;case 1:o[u]=this.getOutputPacked1DCoords(r,i);break;case 2:o[u]=this.getOutputPacked2DCoords(r,i);break;case 3:o[u]=this.getOutputPacked3DCoords(r,i);break;default:o[u]=this.getOutputPackedNDCoords(r,i)}let n=`
      void setOutput(vec4 val) {
        ${G(this.context.glContext.version).output} = val;
      }
    `,a="floatTextureSetRGBA";return o[a]=new k(n),o}getUnpackedOutputSamplingSnippet(t){let r=t.unpackedShape,i=[t.width,t.height],o={},u="getOutputCoords";switch(r.length){case 0:o[u]=this.getOutputScalarCoords();break;case 1:o[u]=this.getOutputUnpacked1DCoords(r,i);break;case 2:o[u]=this.getOutputUnpacked2DCoords(r,i);break;case 3:o[u]=this.getOutputUnpacked3DCoords(r,i);break;case 4:o[u]=this.getOutputUnpacked4DCoords(r,i);break;case 5:o[u]=this.getOutputUnpacked5DCoords(r,i);break;case 6:o[u]=this.getOutputUnpacked6DCoords(r,i);break;default:throw new Error(`Unsupported output dimensionality: ${r.length}`)}let n=`
        void setOutput(float val) {
          ${G(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,a="floatTextureSetR";return o[a]=new k(n),o}getOutputScalarCoords(){return new k(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(t,r){let i=r,o="";return i[0]===1?(o=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${i[1]}.0);
          }
        `,new k(o)):i[1]===1?(o=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${i[0]}.0);
          }
        `,new k(o)):(o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${i[0]}, ${i[1]}));
          return 2 * (resTexRC.y * ${i[0]} + resTexRC.x);
        }
      `,new k(o))}getOutputPacked2DCoords(t,r){let i="";if(Me.arraysEqual(t,r))return i=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${r[0]}, ${r[1]}));
        }
      `,new k(i);let o=r,u=Math.ceil(t[1]/2);return i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));

          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${u}) * 2;
          int c = 2 * (index / ${u});

          return ivec2(r, c);
        }
      `,new k(i)}getOutputPacked3DCoords(t,r){let i=[r[0],r[1]],o=Math.ceil(t[2]/2),u=o*Math.ceil(t[1]/2),n=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          int b = index / ${u};
          index -= b * ${u};

          // reverse r and c order for packed texture
          int r = imod(index, ${o}) * 2;
          int c = 2 * (index / ${o});

          return ivec3(b, r, c);
        }
      `;return new k(n)}getOutputPackedNDCoords(t,r){let i=[r[0],r[1]],o=Math.ceil(t[t.length-1]/2),u=o*Math.ceil(t[t.length-2]/2),n=u,a="",c="b, r, c";for(let e=2;e<t.length-1;e++)n*=t[t.length-e-1],a=`
      int b${e} = index / ${n};
      index -= b${e} * ${n};
    `+a,c=`b${e}, `+c;let p=`
      ivec${t.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.y * ${i[0]} + resTexRC.x;

        ${a}

        int b = index / ${u};
        index -= b * ${u};

        // reverse r and c order for packed texture
        int r = imod(index, ${o}) * 2;
        int c = 2 * (index / ${o});

        return ivec${t.length}(${c});
      }
    `;return new k(p)}getOutputUnpacked1DCoords(t,r){let i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          return resTexRC.y * ${r[0]} + resTexRC.x;
        }
      `;return new k(i)}getOutputUnpacked2DCoords(t,r){let i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          int r = index / ${t[1]};
          int c = index - r * ${t[1]};
          return ivec2(r, c);
        }
      `;return new k(i)}getOutputUnpacked3DCoords(t,r){let i="",o=t.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=t[o-1];for(let c=o-3;c>=0;--c)u[c]=u[c+1]*t[c+1];let n=["r","c","d"],a=u.map((c,p)=>{let e=`int ${n[p]} = index / ${c}`,l=p===u.length-1?`int ${n[p+1]} = index - ${n[p]} * ${c}`:`index -= ${n[p]} * ${c}`;return`${e}; ${l};`}).join("");return i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${a}
          return ivec3(r, c, d);
        }
      `,new k(i)}getOutputUnpacked4DCoords(t,r){let i="",o=t.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=t[o-1];for(let c=o-3;c>=0;--c)u[c]=u[c+1]*t[c+1];let n=["r","c","d","d2"],a=u.map((c,p)=>{let e=`int ${n[p]} = index / ${c}`,l=p===u.length-1?`int ${n[p+1]} = index - ${n[p]} * ${c}`:`index -= ${n[p]} * ${c}`;return`${e}; ${l};`}).join("");return i=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${a}
          return ivec4(r, c, d, d2);
        }
      `,new k(i)}getOutputUnpacked5DCoords(t,r){let i="",o=t.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=t[o-1];for(let c=o-3;c>=0;--c)u[c]=u[c+1]*t[c+1];let n=["r","c","d","d2","d3"],a=u.map((c,p)=>{let e=`int ${n[p]} = index / ${c}`,l=p===u.length-1?`int ${n[p+1]} = index - ${n[p]} * ${c}`:`index -= ${n[p]} * ${c}`;return`${e}; ${l};`}).join("");return i=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${a}
          return ivec5(r, c, d, d2, d3);
        }
      `,new k(i)}getOutputUnpacked6DCoords(t,r){let i="",o=t.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=t[o-1];for(let c=o-3;c>=0;--c)u[c]=u[c+1]*t[c+1];let n=["r","c","d","d2","d3","d4"],a=u.map((c,p)=>{let e=`int ${n[p]} = index / ${c}`,l=p===u.length-1?`int ${n[p+1]} = index - ${n[p]} * ${c}`:`index -= ${n[p]} * ${c}`;return`${e}; ${l};`}).join("");return i=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${r[0]}, ${r[1]}));
         int index = resTexRC.y * ${r[0]} + resTexRC.x;
         ${a}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new k(i)}getCommonUtilFuncs(){let t={},r="uvFromFlat";t[r]=new k(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),r="packedUVfrom1D",t[r]=new k(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom2D",t[r]=new k(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom3D",t[r]=new k(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="sampleTexture";let i=G(this.context.glContext.version);return t[r]=new k(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${i.texture2D}(textureSampler, uv).r;
        }`),t}getInputsSamplingSnippets(){let t={},r=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o],n=An(i);u.isPacked?t[n]=this.getPackedSamplerFromInput(n,i,u):t[n]=this.getUnpackedSamplerFromInput(n,i,u);let a=Yu(i);u.unpackedShape.length<=r.unpackedShape.length&&(u.isPacked?t[a]=this.getPackedSamplerAtOutputCoords(a,u,r,i):t[a]=this.getUnpackedSamplerAtOutputCoords(a,u,r,i))}),t}getPackedSamplerAtOutputCoords(t,r,i,o){let u=r.unpackedShape,n=i.unpackedShape,a=An(o),c=u.length,p=n.length,e=kt.getBroadcastDims(u,n),l=Bt(p),s=p-c,d,h=ne();c===0?d="":p<2&&e.length>=1?d="coords = 0;":d=e.map(E=>`coords.${h[E+s]} = 0;`).join(`
`);let g="";p<2&&c>0?g="coords":g=u.map((E,$)=>`coords.${h[$+s]}`).join(", ");let m="return outputValue;",I=B.size(u)===1,_=B.size(n)===1;if(c===1&&!I&&!_)m=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(I&&!_)p===1?m=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:m=`
          return vec4(outputValue.x);
        `;else if(e.length){let E=c-2,$=c-1;e.indexOf(E)>-1&&e.indexOf($)>-1?m="return vec4(outputValue.x);":e.indexOf(E)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":e.indexOf($)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}let v=`
        int lastDim = coords.${h[p-1]};
        coords.${h[p-1]} = coords.${h[p-2]};
        coords.${h[p-2]} = lastDim;
      `,S=`
      vec4 ${t}() {
        ${l} coords = getOutputCoords();
        ${v}
        ${d}
        vec4 outputValue = ${a}(${g});
        ${m}
      }
    `;return new k(S,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(t,r,i,o){let u=[i.width,i.height],n=[r.width,r.height],a=r.unpackedShape.length,c=i.unpackedShape.length,p=r.unpackedShape,e=i.unpackedShape,l=An(o);if(a===c&&Me.arraysEqual(n,u)){let v=`
          float ${t}() {
            return sampleTexture(${o}, TexCoords);
          }
        `;return new k(v,["coordinates.sampleTexture"])}let s=Bt(c),d=kt.getBroadcastDims(p,e),h=c-a,g,m=ne();a===0?g="":c<2&&d.length>=1?g="coords = 0;":g=d.map(v=>`coords.${m[v+h]} = 0;`).join(`
`);let I="";c<2&&a>0?I="coords":I=r.unpackedShape.map((v,S)=>`coords.${m[S+h]}`).join(", ");let _=`
        float ${t}() {
          ${s} coords = getOutputCoords();
          ${g}
          return ${l}(${I});
        }
      `;return new k(_,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(t,r,i){switch(i.unpackedShape.length){case 0:return this.getPackedSamplerScalar(t,r);case 1:return this.getPackedSampler1D(t,r,i);case 2:return this.getPackedSampler2D(t,r,i);case 3:return this.getPackedSampler3D(t,r,i);default:return this.getPackedSamplerND(t,r,i)}}getUnpackedSamplerFromInput(t,r,i){let o=i.unpackedShape;switch(o.length){case 0:return this.getUnpackedSamplerScalar(t,r,i);case 1:return this.getUnpackedSampler1D(t,r,i);case 2:return this.getUnpackedSampler2D(t,r,i);case 3:return this.getUnpackedSampler3D(t,r,i);case 4:return this.getUnpackedSampler4D(t,r,i);case 5:return this.getUnpackedSampler5D(t,r,i);case 6:return this.getUnpackedSampler6D(t,r,i);default:throw new Error(`Unsupported dimension ${o.length}-D`)}}getPackedSamplerScalar(t,r){let i=G(this.context.glContext.version),o=`
          vec4 ${t}() {
            return ${i.texture2D}(${r}, halfCR);
          }
        `;return new k(o)}getPackedSampler1D(t,r,i){let o=[i.width,i.height],u=[o[1],o[0]],n=G(this.context.glContext.version),a=`vec4 ${t}(int index) {
      vec2 uv = packedUVfrom1D(
      ${u[0]}, ${u[1]}, index);
      return ${n.texture2D}(${r}, uv);
    }`;return new k(a,["coordinates.packedUVfrom1D"])}getPackedSampler2D(t,r,i){let o=i.unpackedShape,u=[i.width,i.height],n=G(this.context.glContext.version),a=u[0],c=u[1];if(u!=null&&Me.arraysEqual(o,u)){let s=`vec4 ${t}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${a}.0);
        return ${n.texture2D}(${r}, uv);
      }`;return new k(s)}let p=u,e=Math.ceil(o[1]/2),l=`vec4 ${t}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${e}, row, col);
      return ${n.texture2D}(${r}, uv);
    }`;return new k(l,["coordinates.packedUVfrom2D"])}getPackedSampler3D(t,r,i){let o=i.unpackedShape,u=[i.width,i.height],n=[u[0],u[1]],a=G(this.context.glContext.version);if(o[0]===1){let d=o.slice(1),h=[1,2],g=lr(o,d),m=["b","row","col"],I=JSON.parse(JSON.stringify(i));I.unpackedShape=g;let _=this.getPackedSamplerFromInput(t,r,I),v=`${_.routineBody}
      vec4 ${t}(int b, int row, int col) {
        return ${t}(${fr(m,h)});
      } `;return new k(v,_.dependencies)}let c=n[0],p=n[1],e=Math.ceil(o[2]/2),l=e*Math.ceil(o[1]/2),s=`vec4 ${t}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${c}, ${l}, ${e}, b, row, col);
      return ${a.texture2D}(${r}, uv);}`;return new k(s,["coordinates.packedUVfrom3D"])}getPackedSamplerND(t,r,i){let o=i.unpackedShape,u=o.length,n=[i.width,i.height],a=G(this.context.glContext.version),c=[n[0],n[1]],p=c[1],e=c[0],l=Math.ceil(o[u-1]/2),s=l*Math.ceil(o[u-2]/2),d="int b, int row, int col",h=`b * ${s} + (row / 2) * ${l} + (col / 2)`;for(let m=2;m<u-1;m++)d=`int b${m}, `+d,s*=o[u-m-1],h=`b${m} * ${s} + `+h;let g=`vec4 ${t}(${d}) {
      int index = ${h};
      int texR = index / ${e};
      int texC = index - texR * ${e};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${e}, ${p});
      return ${a.texture2D}(${r}, uv);
    }`;return new k(g)}getUnpackedSamplerScalar(t,r,i){let[o,u]=[i.width,i.height];if(o===1&&u===1){let a=`
          float ${t}() {
            return sampleTexture(${r}, halfCR);
          }
        `;return new k(a,["coordinates.sampleTexture"])}let n=`
        float ${t}() {
          int offset_${r} = coordsToOffset(TexCoords, ${o}, ${u});
          vec2 uv = uvFromFlat(${o}, ${u}, offset_${r});
          return sampleTexture(${r}, uv);
        }
      `;return new k(n,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(t,r,i){let o=i.width,u=i.height;if(u===1&&o===1){let a=`
        float ${t}(int index) {
          return sampleTexture(${r}, halfCR);
        }
      `;return new k(a,["coordinates.sampleTexture"])}if(u===1){let a=`
          float ${t}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${o}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new k(a,["coordinates.sampleTexture"])}if(o===1){let a=`
          float ${t}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${u}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new k(a,["coordinates.sampleTexture"])}let n=`
        float ${t}(int index) {
          vec2 uv = uvFromFlat(${o}, ${u}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(n,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(t,r,i){let o=i.unpackedShape,u=[i.height,i.width];if(u!=null&&Me.arraysEqual(o,u)){let s=u[1],d=u[0],h=`
          float ${t}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${s}.0, ${d}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new k(h,["coordinates.sampleTexture"])}let{newShape:n,keptDims:a}=hr(o),c=n;if(c.length<o.length){let s=lr(o,c),d=JSON.parse(JSON.stringify(i));d.unpackedShape=s;let h=["col","row"],g=`
          ${this.getUnpackedSamplerFromInput(t,r,d).routineBody}
          float ${t}(int row, int col) {
            return ${t}(${fr(h,a)});
          }
        `;return new k(g,["coordinates.sampleTexture"])}let p=u[1],e=u[0];if(e===1){let s=`
          float ${t}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${p}, ${e});
            float index = dot(vec3(row, col, offset_${r}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new k(s,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(p===1){let s=`
          float ${t}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${p}, ${e});
            float index = dot(vec3(row, col, offset_${r}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${e}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new k(s,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let l=`
        float ${t}(int row, int col) {
          int index = col * ${o[1]} + row;
          vec2 uv = uvFromFlat(${p}, ${e}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(t,r,i){let o=i.unpackedShape,u=o[1]*o[2],n=o[2],{newShape:a,keptDims:c}=hr(o),p=a;if(p.length<o.length){let d=lr(o,p),h=["batch","col","row"],g=JSON.parse(JSON.stringify(i));g.unpackedShape=d;let m=this.getUnpackedSamplerFromInput(t,r,g),I=c.reverse(),_=`
          ${m.routineBody}
          float ${t}(int batch, int row, int col) {
            return ${t}(${fr(h,I)});
          }
        `;return new k(_,m.dependencies)}let e=i.width,l=i.height,s=`
          float ${t}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${u} + col * ${n} + row;
            vec2 uv = uvFromFlat(${e}, ${l}, index);
            return sampleTexture(${r}, uv);
          }
      `;return new k(s,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(t,r,i){let o=i.unpackedShape,u=o[3],n=o[2]*u,a=o[1]*n,c=i.width,p=i.height,e=`
        float ${t}(int row, int col, int depth, int depth2) {
          int index = row * ${a} + col * ${n} +
              depth2 * ${u} + depth;
          vec2 uv = uvFromFlat(${c}, ${p}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(e,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(t,r,i){let o=i.unpackedShape,u=o[4],n=o[3]*u,a=o[2]*n,c=o[1]*a,{newShape:p,keptDims:e}=hr(o);if(p.length<o.length){let h=lr(o,p),g=["row","col","depth","depth2","depth3"],m=JSON.parse(JSON.stringify(i));m.unpackedShape=h;let I=`
          ${this.getUnpackedSamplerFromInput(t,r,m).routineBody}
          float ${t}(int row, int col, int depth, int depth2, int depth3) {
            return ${t}(${fr(g,e)});
          }
        `;return new k(I,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let l=i.width,s=i.height,d=`
        float ${t}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${c} + col * ${a} + depth * ${n} +
          depth3 * ${u} + depth2;
          vec2 uv = uvFromFlat(${l}, ${s}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(t,r,i){let o=i.unpackedShape,u=o[5],n=o[4]*u,a=o[3]*n,c=o[2]*a,p=o[1]*c,{newShape:e,keptDims:l}=hr(o);if(e.length<o.length){let g=lr(o,e),m=["row","col","depth","depth2","depth3","depth4"],I=JSON.parse(JSON.stringify(i));I.unpackedShape=g;let _=`
            ${this.getUnpackedSamplerFromInput(t,r,I).routineBody}
            float ${t}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${t}(${fr(m,l)});
            }
          `;return new k(_,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let s=i.width,d=i.height,h=`
          float ${t}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${c} + depth * ${a} +
            depth2 * ${n} + depth3 * ${u} + depth4;
            vec2 uv = uvFromFlat(${s}, ${d}, index);
            return sampleTexture(${r}, uv);
          }
        `;return new k(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let t=this.context.outputTextureLayout,r=t.shape.length,i=t.strides,o=t.width,u=t.height,n=[];for(let c=0;c<r-1;++c)n.push(`
        c[${c}] = offset / ${i[c]};`),n.push(`
        offset -= c[${c}] * ${i[c]};`);n.push(`
        c[${r-1}] = offset;`);let a=`
      void toVec(vec2 texCoords, out int c[${r}]) {
        int offset = coordsToOffset(texCoords, ${o}, ${u});
        ${n.join("")}
      }
      void toVec(int offset, out int c[${r}]) {
        ${n.join("")}
      }
    `;return{toVec:new k(a,["coordinates.coordsToOffset"])}}valueFrom(){let t={};return this.context.programInfo.inputNames.forEach((r,i)=>{let o=this.context.inputTextureLayouts[i],u=(o.unpackedShape.length>0?o.unpackedShape:o.shape).length,n=`_${r}`;t[n]=new k(this.getValueFromSingle(r,u,o.width,o.height,!1),[`shapeUtils.indicesToOffset${n}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),n=n+"_T",t[n]=new k(this.getValueFromSingle(r,u,o.width,o.height,!0),[`shapeUtils.indicesToOffset${n}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),t}getValueFromSingle(t,r,i,o,u){let n=`_${t}`;u&&(n=n+"_T");let a=G(this.context.glContext.version);return`
        float ${n}(int m[${r}]) {
          int offset = indicesToOffset${n}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${o});
          float value = getColorAsFloat(${a.texture2D}(${t}, coords));
          return value;
        }
        `}getPackedValueFrom(t,r,i,o,u){let n=`_${t}_Pack`;u&&(n=n+"_T");let a=G(this.context.glContext.version);return`
        vec4 ${n}(int m[${r}]) {
          int offset = indicesToOffset_${t}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${o});
          return ${a.texture2D}(${t}, coords);
        }
        `}}}),zn,pp=O(()=>{Te(),zn=class Yr extends Ht{constructor(r){super(r)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new k(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new k(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let r=Yr.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new k(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${r}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let r=Yr.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new k(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${r}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let r=new ArrayBuffer(4),i=new Uint32Array(r),o=new Uint8Array(r);if(i[0]=3735928559,o[0]===239)return!0;if(o[0]===222)return!1;throw new Error("unknown endianness")}}}),Wn,dp=O(()=>{Te(),ut(),Wn=class extends Ht{constructor(t){super(t)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let t=G(this.context.glContext.version);return{setFragColor:new k(`
        void setFragColor(float value) {
            ${t.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new k(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),Hn,hp=O(()=>{Te(),Hn=class we extends Ht{constructor(r){super(r)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let r=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((o,u)=>{let n=this.context.inputTextureLayouts[u].unpackedShape;if(n.length<=r){let a=n.length,c=r-a,p=`bcastIndices_${o}`,e="";for(let s=0;s<a;++s)e+=`
          realIndices[${s}] = int( mod(float(bcastedIndices[${c+s}]), ${n[s]}.0) );
          `;let l=`
        void ${p} (int bcastedIndices[${r}], out int realIndices[${a}]) {
          ${e}
        }
        `;i[p]=new k(l)}}),i}bcastMatmulIndex(){let r=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((o,u)=>{let n=this.context.inputTextureLayouts[u].shape;if(!(n.length<2||n.length>r)){let a=n.length,c=r-a,p=`bcastMatmulIndices_${o}`,e="";for(let s=0;s<a-2;++s)e+=`
          realIndices[${s}] = int( mod(float(bcastedIndices[${c+s}]), ${n[s]}.0) );
          `;let l=`
        void ${p}(int bcastedIndices[${r}], out int realIndices[${a}]) {
          ${e}
          realIndices[${a-1}] = bcastedIndices[${r-1}];
          realIndices[${a-2}] = bcastedIndices[${r-2}];
        }
        `;i[p]=new k(l)}}),i}indicesToOffset(){let r={};return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o].shape,n=this.context.inputTextureLayouts[o].strides,a=u.length,c=`indicesToOffset_${i}`;r[c]=new k(we.indexToOffsetSingle(c,a,n)),c=`indicesToOffset_${i}_T`,r[c]=new k(we.indexToOffsetSingle(c,a,n.slice().reverse()))}),r}static indexToOffsetSingle(r,i,o){let u="";for(let n=i-1;n>=0;--n)u+=`
        offset += indices[${n}] * ${o[n]};
        `;return`
      int ${r}(int indices[${i}]) {
        int offset = 0;
        ${u}
        return offset;
      }
      `}offsetToIndices(){let r={};return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o].shape,n=this.context.inputTextureLayouts[o].strides,a=u.length,c=`offsetToIndices_${i}`;r[c]=new k(we.offsetToIndicesSingle(c,a,n)),c=`offsetToIndices_${i}_T`,r[c]=new k(we.offsetToIndicesSingle(c,a,n.slice().reverse()))}),r}static offsetToIndicesSingle(r,i,o){let u=[];for(let n=0;n<i-1;++n)u.push(`
      indices[${n}] = offset / ${o[n]};`),u.push(`
        offset -= indices[${n}] * ${o[n]};`);return u.push(`
      indices[${i-1}] = offset;`),`
      void ${r}(int offset, out int indices[${i}]) {
        ${u.join("")}
      }
      `}incrementIndices(){let r={};return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o].shape,n=u.length,a=`incrementIndices_${i}`,c="";for(let e=0;e<n;++e)c+=`
        shape[${e}] = ${u[e]};`;let p=`
        void ${a}(int axis, out int indices[${n}]) {
          int shape[${n}];
          ${c};
          for(int i = ${n} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;r[a]=new k(p)}),r}}}),qn,mp=O(()=>{Te(),qn=class extends Ht{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let t=this.context.outputTextureLayout.shape.length,r={add:"+=",sub:"-=",mul:"*=",div:"/="},i={};for(let o in r){let u=`${o}Vec`,n="";for(let c=0;c<t;++c)n+=`
          dest[${c}] ${r[o]} src[${c}];
          `;let a=`
        void ${u}(int src[${t}], out int dest[${t}]) {
          ${n}
        }
        `;i[u]=new k(a)}return i}copyVec(){let t=this.context.outputTextureLayout.shape.length,r="";for(let o=0;o<t;++o)r+=`
        dest[${o}] = src[${o}];
        `;let i=`
      void copyVec(int src[${t}], out int dest[${t}]) {
        ${r}
      }
      `;return{copyVec:new k(i)}}setVecItem(){let t=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index =${t} + index;
        if (index == 0)
            m[0] = value;
        `;for(let o=1;o<t-1;++o)r+=`
        else if (index == ${o})
            m[${o}] = value;
            `;r+=`
        else
            m[${t-1}] = value;
        `;let i=`
      void setVecItem(out int m[${t}], int index, int value) {
        ${r}
      }
        `;return{setVecItem:new k(i)}}getVecItem(){let t=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index = ${t} + index;
        if (index == 0)
            return m[0];
      `;for(let o=1;o<t-1;++o)r+=`
        else if (index == ${o})
            return m[${o}];
      `;r+=`
        else
            return m[${t-1}];
        `;let i=`
      int getVecItem(int m[${t}], int index) {
        ${r}
      }
    `;return{getVecItem:new k(i)}}}}),Ri,bp=O(()=>{cp(),pp(),dp(),hp(),mp(),Ri={encoding:zn,fragcolor:Wn,vec:qn,shapeUtils:Hn,coordinates:Vn}}),jn,gp=O(()=>{Te(),lp(),bp(),ut(),jn=class{constructor(t,r,i,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new Ln(t,r,i,o),Object.keys(Ri).forEach(n=>{let a=new Ri[n](this.context);this.libs[n]=a});let u=this.glslLibRoutineDependencyGraph;for(let n in this.libs){let a=this.libs[n].getFunctions();for(let c in a){let p=n+"."+c,e;u[p]?(e=u[p],e.routineBody=a[c].routineBody):(e=new Nr(p,a[c].routineBody),u[p]=e);let l=a[c].dependencies;if(l)for(let s=0;s<l.length;++s)if(u[l[s]])e.addDependency(u[l[s]]);else{let d=new Nr(l[s]);u[l[s]]=d,e.addDependency(d)}}}}preprocess(){let t=this.context.programInfo,r=t.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${Ju(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=up(r),`${Ku(this.context.glContext.version)}
    ${this.getUniforms(t.inputNames,t.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(t){let r=this.selectGlslLibRoutinesToBeIncluded(t);if(r.length===0)return"";let i="";for(let o=0;o<r.length;++o)if(r[o].routineBody)i+=r[o].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${r[o].name}`);return i}selectGlslLibRoutinesToBeIncluded(t){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(i=>{let o=i.split(".")[1];t.indexOf(o)!==-1&&r.push(this.glslLibRoutineDependencyGraph[i])}),$n.returnOrderedNodes(r)}getUniforms(t,r){let i=[];if(t)for(let o of t)i.push(`uniform sampler2D ${o};`);if(r)for(let o of r)i.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return i.join(`
`)}}}),Xn,yp=O(()=>{Yt(),Ut(),gp(),ut(),Xn=class{constructor(t,r,i){this.profiler=t,this.glContext=r,this.textureLayoutStrategy=i,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,i){this.profiler.event("op",`ProgramManager.run ${t.programInfo.name??"unknown kernel"}`,()=>{let o=this.glContext.gl,u=t.program;o.useProgram(u);try{this.bindOutput(i),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,t.programInfo.variables??[],r)}catch(n){throw tt.error("ProgramManager",t.programInfo.shaderSource),n}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(t=>this.glContext.deleteProgram(t.program))}build(t,r,i){return this.profiler.event("backend","ProgramManager.build",()=>{let o=new jn(this.glContext,t,r,i),u=o.preprocess(),n=this.compile(u);return{programInfo:t,program:n,uniformLocations:this.getUniformLocations(n,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(n)}})}compile(t){if(!this.vertexShader){tt.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let o=Xu(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}z.debug&&tt.verbose("ProrgramManager",`FragShader:
${t}
`);let r=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),i=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),i}bindOutput(t){let r=t.width,i=t.height;tt.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${i}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,r,i)}bindAttributes(t){let r=t.position,i=t.textureCoord;this.glContext.setVertexAttributes(r,i),this.attributesBound=!0}bindUniforms(t,r,i){let o=this.glContext.gl,u=0;for(let{name:n,type:a,location:c,arrayLength:p}of t){let e=r.find(l=>l.name===n)?.data;if(a!=="sampler2D"&&!e)throw new Error(`variable '${n}' does not have data defined in program info`);switch(a){case"sampler2D":this.bindTexture(i[u],c,u),u++;break;case"float":p?o.uniform1fv(c,e):o.uniform1f(c,e);break;case"int":p?o.uniform1iv(c,e):o.uniform1i(c,e);break;default:throw new Error(`Uniform not implemented: ${a}`)}}}bindTexture(t,r,i){this.glContext.bindTextureToUniform(t.texture,i,r)}getAttribLocations(t){return{position:this.getAttribLocation(t,"position"),textureCoord:this.getAttribLocation(t,"textureCoord")}}getUniformLocations(t,r,i){let o=[];if(r)for(let u of r)o.push({name:u,type:"sampler2D",location:this.getUniformLocation(t,u)});if(i)for(let u of i)o.push({...u,location:this.getUniformLocation(t,u.name)});return o}getUniformLocation(t,r){let i=this.glContext.gl.getUniformLocation(t,r);if(i===null)throw new Error(`Uniform ${r} not found.`);return i}getAttribLocation(t,r){return this.glContext.gl.getAttribLocation(t,r)}}}),Kn,xp=O(()=>{Ut(),Fr(),Kn=class{constructor(t,r,i,o){this.glContext=t,this.layoutStrategy=r,this.profiler=i,this.config=o,this.pendingRead=new Map,o.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,r,i,o){let u=this.toEncoderType(t),n=this.glContext.getEncoder(u,r.channels||1,o);if(r.isPacked&&o===1)throw new Error("not implemented");let a=r.width,c=r.height,p,e;if(this.config.reuseTextures){p=`${a}x${c}_${n.format}_${n.internalFormat}_${n.textureType}`,e=this.inUseTextures.get(p),e||(e=[],this.inUseTextures.set(p,e));let s=this.idleTextures.get(p);if(s&&s.length>0){let d=s.pop();return e.push(d),o===1&&this.glContext.updateTexture(d,a,c,n,this.toTextureData(t,i)),d}}tt.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let l=this.glContext.allocateTexture(a,c,n,this.toTextureData(t,i));return this.config.reuseTextures&&(e.push(l),this.textureLookup.set(l,p)),l}readTexture(t,r,i){return i||(i=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let o=t.shape.reduce((n,a)=>n*a)*i,u=this.glContext.readTexture(t.texture,t.width,t.height,o,this.toEncoderType(r),i);return this.toTensorData(r,u)})}async readTextureAsync(t,r,i){let o=t.tensor.dataId;if(i||(i=1),this.pendingRead.has(o)){let u=this.pendingRead.get(o);return new Promise(n=>u?.push(n))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(o,[]);let u=t.shape.reduce((p,e)=>p*e)*i;await this.glContext.createAndWaitForFence();let n=this.glContext.readTexture(t.texture,t.width,t.height,u,this.toEncoderType(r),i),a=this.toTensorData(r,n),c=this.pendingRead.get(o);return this.pendingRead.delete(o),c?.forEach(p=>p(a)),a})}readUint8TextureAsFloat(t){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=t.shape.reduce((o,u)=>o*u),i=this.glContext.readTexture(t.texture,t.width,t.height,r*4,"byte",4);return new Float32Array(i.buffer,i.byteOffset,r)})}releaseTexture(t,r){let i;if(this.config.reuseTextures&&(i=this.textureLookup.get(t.texture),i)){r&&this.textureLookup.delete(i);let o=this.inUseTextures.get(i);if(o){let u=o.indexOf(t.texture);if(u!==-1){o.splice(u,1);let n=this.idleTextures.get(i);n||(n=[],this.idleTextures.set(i,n)),n.push(t.texture)}}}(!i||r)&&(tt.verbose("TextureManager",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,r){switch(t){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(t){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),Jn,Tp=O(()=>{Ut(),Bs(),cl(),ap(),yp(),Ni(),xp(),Jn=class{constructor(t,r){this.backend=t,this.context=r,this.layoutStrategy=new Un(t.glContext.maxTextureSize),this.programManager=new Xn(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new Kn(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:t.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Dn(this)}onGraphInitialized(t){let r=t.getValues().filter(i=>i.from===-1&&i.tensor).map(i=>i.tensor.dataId);this.initializers=new Set(r)}isInitializer(t){return this.initializers?this.initializers.has(t):!1}addInitializer(t){this.initializers.add(t)}getTextureData(t,r){return r?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,r,i=!1){tt.verbose("WebGLSessionHandler","Storing Texture data in cache"),i?this.packedTextureDataCache.set(t,r):this.unpackedTextureDataCache.set(t,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.textureManager.releaseTexture(t,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.textureManager.releaseTexture(t,!0)),this.unpackedTextureDataCache=new Map}resolve(t,r,i){let o=ks(t,r,ip);return{impl:o.opImpl,context:o.opInit?o.opInit(t,i):t}}}});function bg(t){let r=0;for(;r<t.length&&t[r]();++r);return r-1}var Mr,wp=O(()=>{Yt(),Fr(),Fr(),pe(),Mr=class{constructor(t,r){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=t,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,r,i,o){let u=this.gl,n=u.createTexture();u.bindTexture(u.TEXTURE_2D,n),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MIN_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MAG_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE);let a=o?i.encode(o,t*r):null;return u.texImage2D(u.TEXTURE_2D,0,i.internalFormat,t,r,0,i.format,i.textureType,a),this.checkError(),n}updateTexture(t,r,i,o,u){let n=this.gl;n.bindTexture(n.TEXTURE_2D,t);let a=o.encode(u,r*i);n.texSubImage2D(n.TEXTURE_2D,0,0,0,r,i,o.format,o.textureType,a),this.checkError()}attachFramebuffer(t,r,i){let o=this.gl;o.bindTexture(o.TEXTURE_2D,t),o.bindFramebuffer(o.FRAMEBUFFER,this.framebuffer),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,t,0),this.checkError(),o.viewport(0,0,r,i),o.scissor(0,0,r,i)}readTexture(t,r,i,o,u,n){let a=this.gl;n||(n=1),this.frameBufferBound||this.attachFramebuffer(t,r,i);let c=this.getEncoder(u,n),p=c.allocate(r*i);return a.bindTexture(a.TEXTURE_2D,t),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,t,0),a.readPixels(0,0,r,i,a.RGBA,c.textureType,p),this.checkError(),c.decode(p,o)}isFramebufferReady(){return!0}getActiveTexture(){let t=this.gl;return`TEXTURE${t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,r){let i=this.gl;i.vertexAttribPointer(t,3,i.FLOAT,!1,20,0),i.enableVertexAttribArray(t),r!==-1&&(i.vertexAttribPointer(r,2,i.FLOAT,!1,20,12),i.enableVertexAttribArray(r)),this.checkError()}createProgram(t,r){let i=this.gl,o=i.createProgram();return i.attachShader(o,t),i.attachShader(o,r),i.linkProgram(o),o}compileShader(t,r){let i=this.gl,o=i.createShader(r);if(!o)throw new Error(`createShader() returned null with type ${r}`);if(i.shaderSource(o,t),i.compileShader(o),i.getShaderParameter(o,i.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${i.getShaderInfoLog(o)}
Shader source:
${t}`);return o}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,r,i){let o=this.gl;o.activeTexture(o.TEXTURE0+r),this.checkError(),o.bindTexture(o.TEXTURE_2D,t),this.checkError(),o.uniform1i(i,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(z.debug){let t=this.gl,r=t.getError(),i="";switch(r){case t.NO_ERROR:return;case t.INVALID_ENUM:i="INVALID_ENUM";break;case t.INVALID_VALUE:i="INVALID_VALUE";break;case t.INVALID_OPERATION:i="INVALID_OPERATION";break;case t.INVALID_FRAMEBUFFER_OPERATION:i="INVALID_FRAMEBUFFER_OPERATION";break;case t.OUT_OF_MEMORY:i="OUT_OF_MEMORY";break;case t.CONTEXT_LOST_WEBGL:i="CONTEXT_LOST_WEBGL";break;default:i=`Unknown WebGL Error: ${r.toString(16)}`}throw new Error(i)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,r,i=0){if(this.version===2)return new Pn(this.gl,r);switch(t){case"float":return i===1||this.isRenderFloat32Supported?new Br(this.gl,r):new Br(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new En(this.gl,r);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){let t=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)t.activeTexture(t.TEXTURE0+r),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let t=this.gl,r=t.createBuffer();if(!r)throw new Error("createBuffer() returned null");let i=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,i,t.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let t=this.gl.createFramebuffer();if(!t)throw new Error("createFramebuffer returned null");return t}queryVitalParameters(){let t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let t=this.gl,r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);let i=this.version===2?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,i,1,1,0,t.RGBA,t.FLOAT,null);let o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);let u=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),u}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let t=this.gl,r,i,o,u,n;try{r=t.createTexture(),i=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,r);let a=this.version===2?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,a,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0),t.enable(t.BLEND),o=t.createShader(t.VERTEX_SHADER),!o||(t.shaderSource(o,"void main(){}"),t.compileShader(o),u=t.createShader(t.FRAGMENT_SHADER),!u)||(t.shaderSource(u,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),t.compileShader(u),n=t.createProgram(),!n)?!1:(t.attachShader(n,o),t.attachShader(n,u),t.linkProgram(n),t.useProgram(n),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR)}finally{t.disable(t.BLEND),n&&t.deleteProgram(n),o&&t.deleteShader(o),u&&t.deleteShader(u),i&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(i)),r&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(r))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let t=this.gl,r=this.disjointTimerQueryWebgl2Extension,i=t.createQuery();return t.beginQuery(r.TIME_ELAPSED_EXT,i),i}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let t=this.gl,r=this.disjointTimerQueryWebgl2Extension;t.endQuery(r.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(t){let r=!1,i=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let o=this.gl,u=this.disjointTimerQueryWebgl2Extension;r=o.getQueryParameter(t,o.QUERY_RESULT_AVAILABLE),i=o.getParameter(u.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return r&&!i}getTimerResult(t){let r=0;if(this.version===2){let i=this.gl;r=i.getQueryParameter(t,i.QUERY_RESULT),i.deleteQuery(t)}else throw new Error("WebGL1 profiling currently not supported");return r/1e6}async waitForQueryAndGetTime(t){return await li(()=>this.isTimerResultAvailable(t)),this.getTimerResult(t)}async createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let r,i=t,o=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),o===null?r=()=>!0:r=()=>{let u=i.clientWaitSync(o,0,0);return u===i.ALREADY_SIGNALED||u===i.CONDITION_SATISFIED},{query:o,isFencePassed:r}}async pollFence(t){return new Promise(r=>{this.addItemToPoll(()=>t.isFencePassed(),()=>r())})}pollItems(){let t=bg(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=t;++r){let{resolveFn:i}=this.itemsToPoll[r];i()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,r){this.itemsToPoll.push({isDoneFn:t,resolveFn:r}),!(this.itemsToPoll.length>1)&&await li(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Gi(t){let r;if((!t||t==="webgl2")&&"webgl2"in mr?r=mr.webgl2:(!t||t==="webgl")&&"webgl"in mr&&(r=mr.webgl),!r)try{let o=yg();r=vp(o,t)}catch{let o=gg();r=vp(o,t)}t=t||r.version===1?"webgl":"webgl2";let i=r.gl;return mr[t]=r,i.isContextLost()?(delete mr[t],Gi(t)):(i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.disable(i.BLEND),i.disable(i.DITHER),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SAMPLE_COVERAGE),i.enable(i.SCISSOR_TEST),i.enable(i.CULL_FACE),i.cullFace(i.BACK),r)}function vp(t,r){let i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},o,u=i;if((!r||r==="webgl2")&&(o=t.getContext("webgl2",u),o))try{return new Mr(o,2)}catch(n){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!r||r==="webgl")&&(o=t.getContext("webgl",u)||t.getContext("experimental-webgl",u),o))try{return new Mr(o,1)}catch(n){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error("WebGL is not supported")}function gg(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let t=document.createElement("canvas");return t.width=1,t.height=1,t}function yg(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var mr,Ip=O(()=>{Ut(),wp(),mr={}}),Yn,_p=O(()=>{Yt(),Ut(),Tp(),Ip(),Yn=class{get contextId(){return z.webgl.contextId}set contextId(t){z.webgl.contextId=t}get matmulMaxBatchSize(){return z.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){z.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return z.webgl.textureCacheMode}set textureCacheMode(t){z.webgl.textureCacheMode=t}get pack(){return z.webgl.pack}set pack(t){z.webgl.pack=t}get async(){return z.webgl.async}set async(t){z.webgl.async=t}initialize(){try{return this.glContext=Gi(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),tt.setWithEnv(z),z.webgl.context||Object.defineProperty(z.webgl,"context",{value:this.glContext.gl}),tt.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return tt.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new Jn(this,t)}dispose(){this.glContext.dispose()}}});async function Mi(t){if(t){let r=typeof t=="string"?[t]:t;for(let i of r){let o=Op.get(i);if(o)return o;let u=await Tg(i);if(u)return u}}else return Mi(["webgl"]);throw new Error("no available backend to use")}async function Tg(t){let r=xg;if(typeof r[t]<"u"&&wg(r[t])){let i=r[t],o=i.initialize();if(typeof o=="object"&&"then"in o&&(o=await o),o)return Op.set(t,i),i}}function wg(t){let r=t;return"initialize"in r&&typeof r.initialize=="function"&&"createSessionHandler"in r&&typeof r.createSessionHandler=="function"&&"dispose"in r&&typeof r.dispose=="function"}var Op,xg,Sp=O(()=>{_p(),Op=new Map,xg={webgl:new Yn}}),Ui,Zn,Ap=O(()=>{Ut(),Ui=class{constructor(t,r){this.op=t,this.node=r}},Zn=class{constructor(t,r,i){this.graph=t,this.profiler=i,this.initialize(r)}initialize(t){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==t.length)throw new Error("The size of nodes and OPs do not match.");this._ops=t.map((i,o)=>new Ui(i,r[o])),this.reset(),this._starter=[],this._ops.forEach((i,o)=>{let u=!0;for(let n of i.node.inputs)if(!this._values[n]&&this.graph.getInputIndices().indexOf(n)===-1){u=!1;break}u&&this._starter.push(o)})})}reset(){this._values=this.graph.getValues().map(t=>t.tensor)}async execute(t,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let i=t.createInferenceHandler(),o=this.graph.getInputIndices();if(r.length!==o.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${o.length}`);r.forEach((e,l)=>{let s=o[l];this._values[s]=e});let u=this._starter.slice(0),n=this.graph.getValues(),a=this.graph.getNodes(),c=0;for(;c<u.length;){let e=u[c++],l=this._ops[e],s=l.node.inputs.map(m=>this._values[m]);if(s.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${l.node}`);let d=s;tt.verbose("ExecPlan",`Running op:${l.node.name} (${d.map((m,I)=>`'${l.node.inputs[I]}': ${m.type}[${m.dims.join(",")}]`).join(", ")})`);let h=await this.profiler.event("node",l.node.name,async()=>l.op.impl(i,d,l.op.context));if(h.length!==l.node.outputs.length)throw new Error("the size of output does not match model definition.");h.forEach((m,I)=>{let _=l.node.outputs[I];if(this._values[_])throw new Error(`output [${_}] already has value: op:${l.node.name}`);this._values[_]=m});let g=new Set;h.forEach((m,I)=>{let _=l.node.outputs[I];for(let v of n[_].to){let S=a[v],E=!0;for(let $ of S.inputs)if(!this._values[$]){E=!1;break}E&&g.add(v)}}),u.push(...g)}let p=[];for(let e=0;e<this.graph.getOutputIndices().length;e++){let l=this.graph.getOutputIndices()[e],s=this._values[l];if(s===void 0)throw new Error(`required output [${l}] does not have value`);l===0?await s.getData():s.data,p.push(s)}return tt.verbose("ExecPlan","disposing of inferenceHandler"),i.dispose(),p})}}}),q,Xt,Ur,Pp=O(()=>{Pr(),q=rr(sr()),We(),Y(),Xt=F.experimental.fbs,Ur=class ve{constructor(r){if(this._attributes=new Map,r!=null){for(let i of r)i instanceof q.onnx.AttributeProto?this._attributes.set(i.name,[ve.getValue(i),ve.getType(i)]):i instanceof Xt.Attribute&&this._attributes.set(i.name(),[ve.getValue(i),ve.getType(i)]);if(this._attributes.size<r.length)throw new Error("duplicated attribute names")}}set(r,i,o){this._attributes.set(r,[o,i])}delete(r){this._attributes.delete(r)}getFloat(r,i){return this.get(r,"float",i)}getInt(r,i){return this.get(r,"int",i)}getString(r,i){return this.get(r,"string",i)}getTensor(r,i){return this.get(r,"tensor",i)}getFloats(r,i){return this.get(r,"floats",i)}getInts(r,i){return this.get(r,"ints",i)}getStrings(r,i){return this.get(r,"strings",i)}getTensors(r,i){return this.get(r,"tensors",i)}get(r,i,o){let u=this._attributes.get(r);if(u===void 0){if(o!==void 0)return o;throw new Error(`required attribute not found: ${r}`)}if(u[1]!==i)throw new Error(`type mismatch: expected ${i} but got ${u[1]}`);return u[0]}static getType(r){let i=r instanceof q.onnx.AttributeProto?r.type:r.type();switch(i){case q.onnx.AttributeProto.AttributeType.FLOAT:return"float";case q.onnx.AttributeProto.AttributeType.INT:return"int";case q.onnx.AttributeProto.AttributeType.STRING:return"string";case q.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case q.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case q.onnx.AttributeProto.AttributeType.INTS:return"ints";case q.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case q.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${q.onnx.AttributeProto.AttributeType[i]}`)}}static getValue(r){let i=r instanceof q.onnx.AttributeProto?r.type:r.type();if(i===q.onnx.AttributeProto.AttributeType.GRAPH||i===q.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let o=this.getValueNoCheck(r);if(i===q.onnx.AttributeProto.AttributeType.INT&&Rt.isLong(o))return Rt.longToNumber(o);if(i===q.onnx.AttributeProto.AttributeType.INTS){let u=o,n=new Array(u.length);for(let a=0;a<u.length;a++){let c=u[a];n[a]=Rt.longToNumber(c)}return n}if(i===q.onnx.AttributeProto.AttributeType.TENSOR)return r instanceof q.onnx.AttributeProto?bt.fromProto(o):bt.fromOrtTensor(o);if(i===q.onnx.AttributeProto.AttributeType.TENSORS){if(r instanceof q.onnx.AttributeProto)return o.map(u=>bt.fromProto(u));if(r instanceof Xt.Attribute)return o.map(u=>bt.fromOrtTensor(u))}return i===q.onnx.AttributeProto.AttributeType.STRING&&r instanceof q.onnx.AttributeProto?kr(o):i===q.onnx.AttributeProto.AttributeType.STRINGS&&r instanceof q.onnx.AttributeProto?o.map(kr):o}static getValueNoCheck(r){return r instanceof q.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(r):this.getValueNoCheckFromOrtFormat(r)}static getValueNoCheckFromOnnxFormat(r){switch(r.type){case q.onnx.AttributeProto.AttributeType.FLOAT:return r.f;case q.onnx.AttributeProto.AttributeType.INT:return r.i;case q.onnx.AttributeProto.AttributeType.STRING:return r.s;case q.onnx.AttributeProto.AttributeType.TENSOR:return r.t;case q.onnx.AttributeProto.AttributeType.GRAPH:return r.g;case q.onnx.AttributeProto.AttributeType.FLOATS:return r.floats;case q.onnx.AttributeProto.AttributeType.INTS:return r.ints;case q.onnx.AttributeProto.AttributeType.STRINGS:return r.strings;case q.onnx.AttributeProto.AttributeType.TENSORS:return r.tensors;case q.onnx.AttributeProto.AttributeType.GRAPHS:return r.graphs;default:throw new Error(`unsupported attribute type: ${q.onnx.AttributeProto.AttributeType[r.type]}`)}}static getValueNoCheckFromOrtFormat(r){switch(r.type()){case Xt.AttributeType.FLOAT:return r.f();case Xt.AttributeType.INT:return r.i();case Xt.AttributeType.STRING:return r.s();case Xt.AttributeType.TENSOR:return r.t();case Xt.AttributeType.GRAPH:return r.g();case Xt.AttributeType.FLOATS:return r.floatsArray();case Xt.AttributeType.INTS:{let i=[];for(let o=0;o<r.intsLength();o++)i.push(r.ints(o));return i}case Xt.AttributeType.STRINGS:{let i=[];for(let o=0;o<r.stringsLength();o++)i.push(r.strings(o));return i}case Xt.AttributeType.TENSORS:{let i=[];for(let o=0;o<r.tensorsLength();o++)i.push(r.tensors(o));return i}default:throw new Error(`unsupported attribute type: ${Xt.AttributeType[r.type()]}`)}}}}),zi,Qn,Wi,me,to,Vi,Ep=O(()=>{Pp(),Pr(),zi=rr(sr()),We(),Y(),Qn=F.experimental.fbs,Wi={from:(t,r)=>new Vi(t,r)},me=class{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=At.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}},to=class{constructor(t,r){t instanceof zi.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new Ur(t.attribute)):t instanceof Qn.Node&&(this.name=r??t.name(),this.opType=t.opType(),this.attributes=new Ur(At.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Vi=class{constructor(t,r){if(!t)throw new TypeError("graph is empty");this.buildGraph(t),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof zi.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else if(t instanceof Qn.Graph)this.buildGraphFromOrtFormat(t);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(t){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!t.input)throw new Error("missing information in graph: input");let o=[];for(let u of t.input){if(r.has(u.name))throw new Error(`duplicated input name: ${u.name}`);let n=this._allData.push(new me(u))-1;r.set(u.name,n),o.push(u.name)}if(!t.initializer)throw new Error("missing information in graph: initializer");for(let u of t.initializer){let n=r.get(u.name);if(n===void 0){let a=new me;a.type={shape:{dims:At.tensorDimsFromProto(u.dims)},tensorType:At.tensorDataTypeFromProto(u.dataType)},n=this._allData.push(a)-1,r.set(u.name,n)}this._allData[n]._from=-1,this._allData[n].tensor=bt.fromProto(u)}for(let u=0;u<this._allData.length;u++)this._allData[u].tensor||(this._allInputIndices.push(u),this._allInputNames.push(o[u]));if(!t.output)throw new Error("missing information in graph: output");for(let u of t.output){if(r.has(u.name))throw new Error(`duplicated output name: ${u.name}`);let n=this._allData.push(new me(u))-1;r.set(u.name,n),this._allOutputIndices.push(n),this._allOutputNames.push(u.name)}if(!t.node)throw new Error("missing information in graph: node");for(let u of t.node){if(!u.name)for(let a=0;;a++){let c=`unnamed_${u.opType}_${a}`;if(!i.has(c)){u.name=c;break}}if(i.has(u.name))throw new Error(`duplicated node name: ${u.name}`);let n=this._nodes.push(new to(u))-1;i.set(u.name,n)}for(let u=0;u<this._nodes.length;u++){let n=this._nodes[u],a=t.node[u];if(!a.output)throw new Error(`missing output for node: ${a.name}`);for(let c of a.output){let p=r.get(c);if(typeof p>"u"&&(p=this._allData.push(new me)-1,r.set(c,p)),n.outputs.push(p),this._allData[p]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${p}`);if(this._allData[p]._from=u,a.opType==="Constant"){if(!a.attribute||a.attribute.length!==1||!a.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!a.output||a.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[p]._from=-1,this._allData[p].tensor=bt.fromProto(a.attribute[0].t)}}}for(let u=0;u<this._nodes.length;u++){let n=this._nodes[u],a=t.node[u];if(!a.input)throw new Error(`missing input for node: ${a.name}`);for(let c of a.input){let p=r.get(c);if(typeof p>"u"){if(c===""&&(a.input.length===3||a.input.length===4)&&a.opType==="Resize")continue;throw new Error(`unrecognized input '${c}' for node: ${a.name}`)}n.inputs.push(p),this._allData[p]._to.push(u)}}return!0}buildGraphFromOrtFormat(t){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map,o=[];for(let u=0;u<t.inputsLength();u++){let n=t.inputs(u);if(r.has(n))throw new Error(`duplicated input name: ${n}`);for(let a=0;a<t.nodeArgsLength();a++)if(t.nodeArgs(a)?.name()===n){let c=new me;if(t.nodeArgs(a)?.type()?.valueType()!==Qn.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let p=t.nodeArgs(a).type().value(new Qn.TensorTypeAndShape),e=At.tensorDataTypeFromProto(p.elemType()),l=p.shape(),s=[];for(let h=0;h<l.dimLength();h++)s.push(Rt.longToNumber(l.dim(h).value().dimValue()));c.type={shape:{dims:s},tensorType:e};let d=this._allData.push(c)-1;r.set(n,d),o.push(n)}}for(let u=0;u<t.initializersLength();u++){let n=t.initializers(u),a=r.get(n.name());if(a===void 0){let c=new me,p=At.tensorDimsFromORTFormat(n),e=At.tensorDataTypeFromProto(n.dataType());c.type={shape:{dims:p},tensorType:e},a=this._allData.push(c)-1,r.set(n.name(),a)}this._allData[a]._from=-1,this._allData[a].tensor=bt.fromOrtTensor(n)}for(let u=0;u<this._allData.length;u++)this._allData[u].tensor||(this._allInputIndices.push(u),this._allInputNames.push(o[u]));for(let u=0;u<t.outputsLength();u++){let n=t.outputs(u);if(r.has(n))throw new Error(`duplicated output name: ${n}`);let a=this._allData.push(new me)-1;r.set(n,a),this._allOutputIndices.push(a),this._allOutputNames.push(n)}if(!t.nodes)throw new Error("missing information in graph: node");for(let u=0;u<t.nodesLength();u++){let n=t.nodes(u),a=n.name();if(!a)for(let p=0;a=`unnamed_${n.opType()}_${p}`,!!i.has(a);p++);if(i.has(a))throw new Error(`duplicated node name: ${a}`);let c=this._nodes.push(new to(n,a))-1;i.set(a,c)}for(let u=0;u<this._nodes.length;u++){let n=this._nodes[u],a=t.nodes(u);if(a==null)throw new Error(`No node exists at index ${u}`);if(a?.outputsLength()===0)throw new Error(`missing output for node: ${a.name}`);for(let c=0;c<a?.outputsLength();c++){let p=a?.outputs(c),e=r.get(p);if(typeof e>"u"&&(e=this._allData.push(new me)-1,r.set(p,e)),n.outputs.push(e),this._allData[e]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${e}`);if(this._allData[e]._from=u,a.opType()==="Constant"){if(a.attributesLength()!==1||!a.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(a.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[e]._from=-1,this._allData[e].tensor=bt.fromOrtTensor(a.attributes(0).t())}}}for(let u=0;u<this._nodes.length;u++){let n=this._nodes[u],a=t.nodes(u);if(a.inputsLength()===0)throw new Error(`missing input for node: ${a.name}`);for(let c=0;c<a.inputsLength();c++){let p=a.inputs(c),e=r.get(p);if(typeof e>"u")throw new Error(`unrecognized input '${p}' for node: ${a.name()}`);n.inputs.push(e),this._allData[e]._to.push(u)}}}checkIsAcyclic(){let t=new Set;this._allInputIndices.forEach(o=>{this._allData[o]._to.forEach(u=>{t.add(u)})});let r=Array.from(t),i=new Array(this._nodes.length).fill("white");for(;r.length>0;){let o=r.pop();i[o]==="gray"?i[o]="black":(r.push(o),i[o]="gray",this._nodes[o].outputs.forEach(u=>{let n=this._allData[u];if(typeof n.tensor<"u")throw new Error("node outputs should not be initialized");if(n._from!==o)throw new Error("from property of the Value object doesn't match index of Node being processed");n._to.forEach(a=>{if(i[a]==="gray")throw new Error("model graph is cyclic");i[a]==="white"&&r.push(a)})}))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0,r=new Array(this._nodes.length,0),i=0;for(let o=0;o<this._nodes.length;o++)r[o]=i,this._nodes[o].executeNode?(i!==o&&(this._nodes[i]=this._nodes[o]),i++):this._nodes[o].outputs.forEach(u=>{this._allData[u]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let o=0;o<this._allData.length;o++){let u=this._allData[o];u._from!==void 0&&u._from!==-1&&u._from!==-2&&(u._from=r[u._from]);for(let n=0;n<u._to.length;n++)if(u._to[n]>=0)u._to[n]=r[u._to[n]];else throw new Error("Trying to update a removed node")}t=0;for(let o=0;o<this._allData.length;o++){if(this._allData[o].from===-2&&this._allOutputIndices.indexOf(o+t)===-1){t++,this._allData.splice(o,1),o--;continue}if(t>0){let u=-1;this._allData[o].from!==void 0&&this._allData[o].from!==-1?(u=this._nodes[this._allData[o].from].outputs.indexOf(o+t),u!==-1&&(this._nodes[this._allData[o].from].outputs[u]=o)):(u=this._allInputIndices.indexOf(o+t),u!==-1&&(this._allInputIndices[u]=o)),this._allData[o].to.forEach(n=>{u=this._nodes[n].inputs.indexOf(o+t),u!==-1&&(this._nodes[n].inputs[u]=o)}),this._allData[o].to.length===0&&(u=this._allOutputIndices.indexOf(o+t),u!==-1&&(this._allOutputIndices[u]=o))}}}deleteNode(t){let r=this._nodes[t];if(r.outputs.length>1){for(let a=1;a<r.outputs.length;a++)if(this._allData[r.outputs[a]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let i=r.inputs[0],o=r.outputs[0],u=this._allData[o].to;for(let a=0;a<r.inputs.length;a++){let c=this._allData[r.inputs[a]].to.indexOf(t);if(c===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[a]].to.splice(c,1)}this._allData[o]._to=[];let n=this._allOutputIndices.indexOf(o);if(n!==-1&&(this._allOutputIndices[n]=i),u&&u.length>0)for(let a of u){let c=this._nodes[a].inputs.indexOf(o);if(c===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[a].inputs[c]=i,this._allData[i].to.push(a)}}removeAllDropoutNodes(){let t=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let t of this._nodes)if(t.opType==="Conv"){let r=this._allData[t.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let i=this._nodes[r[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{t.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{t.attributes.set("activation_params","floats",[Ve,ze])}else if(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0)t.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]]);else continue;t.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}}),Dp,vg,eo,Lp=O(()=>{wn(),Ep(),Pr(),Dp=rr(sr()),Y(),vg=F.experimental.fbs,eo=class{constructor(){}load(t,r,i){let o;if(!i)try{this.loadFromOnnxFormat(t,r);return}catch(u){if(i!==void 0)throw u;o=u}try{this.loadFromOrtFormat(t,r)}catch(u){throw i!==void 0?u:new Error(`Failed to load model as ONNX format: ${o}
as ORT format: ${u}`)}}loadFromOnnxFormat(t,r){let i=Dp.onnx.ModelProto.decode(t);if(Rt.longToNumber(i.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=i.opsetImport.map(o=>({domain:o.domain,version:Rt.longToNumber(o.version)})),this._graph=Wi.from(i.graph,r)}loadFromOrtFormat(t,r){let i=new w.ByteBuffer(t),o=vg.InferenceSession.getRootAsInferenceSession(i).model();if(Rt.longToNumber(o.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let u=0;u<o.opsetImportLength();u++){let n=o.opsetImport(u);this._opsets.push({domain:n?.domain(),version:Rt.longToNumber(n.version())})}this._graph=Wi.from(o.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}}),ro,$p=O(()=>{Sp(),Ap(),Ut(),Lp(),ro=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=xn.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,r,i){await this.profiler.event("session","Session.loadModel",async()=>{let o=await Mi(this.backendHint);if(this.sessionHandler=o.createSessionHandler(this.context),this._model=new eo,typeof t=="string"){let u=t.endsWith(".ort");{let n=await(await fetch(t)).arrayBuffer();this.initialize(new Uint8Array(n),u)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{let u=new Uint8Array(t,r||0,i||t.byteLength);this.initialize(u)}})}initialize(t,r){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let i=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,i,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Zn(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(t){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(t),i=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(i)})}normalizeAndValidateInputs(t){let r=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==r.length)throw new Error(`incorrect input array length: expected ${r.length} but got ${t.length}`)}else{if(t.size!==r.length)throw new Error(`incorrect input map size: expected ${r.length} but got ${t.size}`);let i=new Array(t.size),o=0;for(let u=0;u<r.length;++u){let n=t.get(r[u]);if(!n)throw new Error(`missing input tensor for: '${name}'`);i[o++]=n}t=i}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let i=this._model.graph.getInputIndices(),o=this._model.graph.getValues(),u=new Array(i.length);for(let n=0;n<i.length;++n){let a=o[i[n]];u[n]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(t[n].dims)}this.validateInputTensorDims(u,t,!0)}else this.validateInputTensorDims(this.context.graphInputDims,t,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,r){for(let i=0;i<r.length;i++){let o=t[i],u=r[i].type;if(o!==u)throw new Error(`input tensor[${i}] check failed: expected type '${o}' but got ${u}`)}}validateInputTensorDims(t,r,i){for(let o=0;o<r.length;o++){let u=t[o],n=r[o].dims;if(!this.compareTensorDims(u,n,i))throw new Error(`input tensor[${o}] check failed: expected shape '[${u.join(",")}]' but got [${n.join(",")}]`)}}compareTensorDims(t,r,i){if(t.length!==r.length)return!1;for(let o=0;o<t.length;++o)if(t[o]!==r[o]&&(!i||t[o]!==0))return!1;return!0}createOutput(t){let r=this._model.graph.getOutputNames();if(t.length!==r.length)throw new Error("expected number of outputs do not match number of generated outputs");let i=new Map;for(let o=0;o<r.length;++o)i.set(r[o],t[o]);return i}initializeOps(t){let r=t.getNodes();this._ops=new Array(r.length);for(let i=0;i<r.length;i++)this._ops[i]=this.sessionHandler.resolve(r[i],this._model.opsets,t)}}}),no,kp=O(()=>{Yt(),We(),no=class{constructor(t){this.session=t,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,r,i){let o=new Map;for(let a in t)if(Object.hasOwnProperty.call(t,a)){let c=t[a];o.set(a,new bt(c.dims,c.type,void 0,void 0,c.data))}let u=await this.session.run(o),n={};return u.forEach((a,c)=>{n[c]=new yt(a.type,a.data,a.dims)}),n}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),Bp={};Or(Bp,{onnxjsBackend:()=>Ig});var Hi,Ig,Fp=O(()=>{$p(),kp(),Hi=class{async init(){}async createInferenceSessionHandler(t,r){let i=new ro(r);return typeof t=="string"?await i.loadModel(t):await i.loadModel(t),new no(i)}},Ig=new Hi}),oo=O(()=>{}),Rp={};Or(Rp,{default:()=>_g});var Cp,Np,_g,Gp=O(()=>{qi(),Ke(),Vr(),Cp="ort-wasm-proxy-worker",Np=globalThis.self?.name===Cp,Np&&(self.onmessage=t=>{let{type:r,in:i}=t.data;try{switch(r){case"init-wasm":io(i.wasm).then(()=>{ao(i).then(()=>{postMessage({type:r})},o=>{postMessage({type:r,err:o})})},o=>{postMessage({type:r,err:o})});break;case"init-ep":{let{epName:o,env:u}=i;so(u,o).then(()=>{postMessage({type:r})},n=>{postMessage({type:r,err:n})});break}case"copy-from":{let{buffer:o}=i,u=zr(o);postMessage({type:r,out:u});break}case"create":{let{model:o,options:u}=i;uo(o,u).then(n=>{postMessage({type:r,out:n})},n=>{postMessage({type:r,err:n})});break}case"release":lo(i),postMessage({type:r});break;case"run":{let{sessionId:o,inputIndices:u,inputs:n,outputIndices:a,options:c}=i;fo(o,u,n,a,new Array(a.length).fill(null),c).then(p=>{p.some(e=>e[3]!=="cpu")?postMessage({type:r,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:r,out:p},po([...n,...p]))},p=>{postMessage({type:r,err:p})});break}case"end-profiling":co(i),postMessage({type:r});break;default:}}catch(o){postMessage({type:r,err:o})}}),_g=Np?null:t=>new Worker(t??br,{type:"module",name:Cp})}),Up={};Or(Up,{default:()=>Og});var ji,Mp,Og,Vp=O(()=>{Mp=(ji=self.location.href,async function(t={}){function r(){return st.buffer!=lt.buffer&&nt(),lt}function i(){return st.buffer!=lt.buffer&&nt(),L}function o(){return st.buffer!=lt.buffer&&nt(),Ft}function u(){return st.buffer!=lt.buffer&&nt(),Ie}function n(){return st.buffer!=lt.buffer&&nt(),oe}var a,c,p=Object.assign({},t),e=new Promise((f,b)=>{a=f,c=b}),l=typeof window=="object",s=typeof importScripts=="function",d=s&&self.name=="em-pthread";p.mountExternalData=(f,b)=>{f.startsWith("./")&&(f=f.substring(2)),(p.Ua||(p.Ua=new Map)).set(f,b)},p.unmountExternalData=()=>{delete p.Ua};var h,g,m=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,I=Object.assign({},p),_="./this.program",v=(f,b)=>{throw b},S="";(l||s)&&(s?S=self.location.href:typeof document<"u"&&document.currentScript&&(S=document.currentScript.src),ji&&(S=ji),S=S.startsWith("blob:")?"":S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1),s&&(g=f=>{var b=new XMLHttpRequest;return b.open("GET",f,!1),b.responseType="arraybuffer",b.send(null),new Uint8Array(b.response)}),h=(f,b,y)=>{var x=new XMLHttpRequest;x.open("GET",f,!0),x.responseType="arraybuffer",x.onload=()=>{x.status==200||x.status==0&&x.response?b(x.response):y()},x.onerror=y,x.send(null)});var E,$=console.log.bind(console),Q=console.error.bind(console),Z=$,R=Q;if(Object.assign(p,I),I=null,d){let f=function(b){try{var y=b.data,x=y.cmd;if(x==="load"){let T=[];self.onmessage=C=>T.push(C),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let C of T)f(C);self.onmessage=f};for(let C of y.handlers)p[C]&&!p[C].proxy||(p[C]=(...P)=>{postMessage({Za:"callHandler",kb:C,args:P})},C=="print"&&(Z=p[C]),C=="printErr"&&(R=p[C]));st=y.wasmMemory,nt(),at(y.wasmModule)}else if(x==="run"){Dr(y.pthread_ptr,0,0,1,0,0),wr(y.pthread_ptr),Ta(),vn(),Nt||=!0;try{_a(y.start_routine,y.arg)}catch(T){if(T!="unwind")throw T}}else x==="cancel"?ae()&&Ze(-1):y.target!=="setimmediate"&&(x==="checkMailbox"?Nt&&Le():x&&(R(`worker: received unknown command ${x}`),R(y)))}catch(T){throw ca(),T}};var at,Nt=!1;R=function(...b){b=b.join(" "),console.error(b)},self.alert=function(...b){postMessage({Za:"alert",text:b.join(" "),nb:ae()})},p.instantiateWasm=(b,y)=>new Promise(x=>{at=T=>{T=new WebAssembly.Instance(T,Qr()),y(T),x()}}),self.onunhandledrejection=b=>{throw b.reason||b},self.onmessage=f}p.wasmBinary&&(E=p.wasmBinary);var st,Pt,vt,lt,L,Ft,Ie,gt,oe,et=!1;function nt(){var f=st.buffer;p.HEAP8=lt=new Int8Array(f),p.HEAP16=new Int16Array(f),p.HEAPU8=L=new Uint8Array(f),p.HEAPU16=new Uint16Array(f),p.HEAP32=Ft=new Int32Array(f),p.HEAPU32=Ie=new Uint32Array(f),p.HEAPF32=new Float32Array(f),p.HEAPF64=oe=new Float64Array(f),p.HEAP64=gt=new BigInt64Array(f),p.HEAPU64=new BigUint64Array(f)}if(!d){if(!((st=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof m))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");nt()}var Jt=[],Lt=[],Ae=[],te=0,wt=null;function _t(){if(--te==0&&wt){var f=wt;wt=null,f()}}function Dt(f){throw R(f="Aborted("+f+")"),et=!0,vt=1,f=new WebAssembly.RuntimeError(f+". Build with -sASSERTIONS for more info."),c(f),f}var K,it=f=>f.startsWith("data:application/octet-stream;base64,"),$t=f=>f.startsWith("file://");function se(f){if(f==K&&E)return new Uint8Array(E);if(g)return g(f);throw"both async and sync fetching of the wasm failed"}function Oe(f,b,y){return(function(x){if(!E&&(l||s)){if(typeof fetch=="function"&&!$t(x))return fetch(x,{credentials:"same-origin"}).then(T=>{if(!T.ok)throw`failed to load wasm binary file at '${x}'`;return T.arrayBuffer()}).catch(()=>se(x));if(h)return new Promise((T,C)=>{h(x,P=>T(new Uint8Array(P)),C)})}return Promise.resolve().then(()=>se(x))})(f).then(x=>WebAssembly.instantiate(x,b)).then(y,x=>{R(`failed to asynchronously prepare wasm: ${x}`),Dt(x)})}function Qr(){return{a:{j:xa,b:Sa,E:_o,g:Oo,V:Eo,A:$o,C:ko,W:Fo,T:Bo,L:Lo,S:jo,o:zo,B:Zo,y:Xo,U:Ko,z:Jo,_:Oa,Z:Ca,P:Ea,w:Pa,F:Da,k:$a,O:wr,Y:Na,I:ka,J:Fa,K:Ba,G:ti,H:ri,v:Va,q:La,l:Ra,p:ja,e:Ga,X:Ua,x:za,d:ni,f:Ma,i:Ha,u:Za,t:Wa,s:Xa,Q:ra,R:na,D:gr,h:oa,n:ia,M:aa,m:sa,a:st,r:ar,N:pa,c:qa}}}var tn={836900:(f,b,y,x,T)=>{if(p===void 0||!p.Ua)return 1;if((f=ue(f>>>0)).startsWith("./")&&(f=f.substring(2)),!(f=p.Ua.get(f)))return 2;if(x>>>=0,(b>>>=0)+(y>>>=0)>f.byteLength)return 3;try{let C=f.subarray(b,b+y);switch(T){case 0:i().set(C,x>>>0);break;case 1:p.mb(x,C);break;default:return 4}return 0}catch{return 4}},837583:()=>typeof wasmOffsetConverter<"u"};function xa(){return typeof wasmOffsetConverter<"u"}function tr(f){this.name="ExitStatus",this.message=`Program terminated with exit(${f})`,this.status=f}var er=f=>{f.terminate(),f.onmessage=()=>{}},en=f=>{Mt.length==0&&(_n(),In(Mt[0]));var b=Mt.pop();if(!b)return 6;ee.push(b),Ot[f.Ra]=b,b.Ra=f.Ra;var y={cmd:"run",start_routine:f.cb,arg:f.ab,pthread_ptr:f.Ra};return b.postMessage(y,f.ib),0},le=0,M=(f,b,...y)=>{for(var x=2*y.length,T=Kr(),C=Zr(8*x),P=C>>>3,U=0;U<y.length;U++){var pt=y[U];typeof pt=="bigint"?(gt[P+2*U]=1n,gt[P+2*U+1]=pt):(gt[P+2*U]=0n,n()[P+2*U+1>>>0]=pt)}return f=da(f,0,x,C,b),Ye(T),f};function ar(f){if(d)return M(0,1,f);if(vt=f,!(0<le)){for(var b of ee)er(b);for(b of Mt)er(b);Mt=[],ee=[],Ot=[],et=!0}v(f,new tr(f))}function rn(f){if(d)return M(1,0,f);gr(f)}var gr=f=>{if(vt=f,d)throw rn(f),"unwind";ar(f)},Mt=[],ee=[],nn=[],Ot={},on=f=>{var b=f.Ra;delete Ot[b],Mt.push(f),ee.splice(ee.indexOf(f),1),f.Ra=0,Lr(b)};function vn(){nn.forEach(f=>f())}var In=f=>new Promise(b=>{f.onmessage=T=>{var C=(T=T.data).cmd;if(T.targetThread&&T.targetThread!=ae()){var P=Ot[T.targetThread];P?P.postMessage(T,T.transferList):R(`Internal error! Worker sent a message "${C}" to target pthread ${T.targetThread}, but that thread no longer exists!`)}else C==="checkMailbox"?Le():C==="spawnThread"?en(T):C==="cleanupThread"?on(Ot[T.thread]):C==="killThread"?(T=T.thread,C=Ot[T],delete Ot[T],er(C),Lr(T),ee.splice(ee.indexOf(C),1),C.Ra=0):C==="cancelThread"?Ot[T.thread].postMessage({cmd:"cancel"}):C==="loaded"?(f.loaded=!0,b(f)):C==="alert"?alert(`Thread ${T.threadId}: ${T.text}`):T.target==="setimmediate"?f.postMessage(T):C==="callHandler"?p[T.handler](...T.args):C&&R(`worker sent an unknown command ${C}`)},f.onerror=T=>{throw R(`worker sent an error! ${T.filename}:${T.lineno}: ${T.message}`),T};var y,x=[];for(y of[])p.hasOwnProperty(y)&&x.push(y);f.postMessage({cmd:"load",handlers:x,wasmMemory:st,wasmModule:Pt})});function _n(){var f=new Worker(new URL(self.location.href),{type:"module",workerData:"em-pthread",name:"em-pthread"});Mt.push(f)}var On,De=f=>{for(;0<f.length;)f.shift()(p)},Ta=()=>{var f=ae(),b=u()[f+52>>>2>>>0];f=u()[f+56>>>2>>>0],fa(b,b-f),Ye(b)},$e=[],_a=(f,b)=>{le=0;var y=$e[f];y||(f>=$e.length&&($e.length=f+1),$e[f]=y=On.get(f)),f=y(b),0<le?vt=f:Ze(f)};class Aa{constructor(b){this.Xa=b-24}}function Sa(f,b,y){var x=new Aa(f>>>=0);throw b>>>=0,y>>>=0,u()[x.Xa+16>>>2>>>0]=0,u()[x.Xa+4>>>2>>>0]=b,u()[x.Xa+8>>>2>>>0]=y,f}function Io(f,b,y,x){return d?M(2,1,f,b,y,x):_o(f,b,y,x)}function _o(f,b,y,x){if(f>>>=0,b>>>=0,y>>>=0,x>>>=0,m===void 0)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var T=[];return d&&T.length===0?Io(f,b,y,x):(f={cb:y,Ra:f,ab:x,ib:T},d?(f.Za="spawnThread",postMessage(f,T),0):en(f))}var Ao=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,So=(f,b,y)=>{var x=(b>>>=0)+y;for(y=b;f[y]&&!(y>=x);)++y;if(16<y-b&&f.buffer&&Ao)return Ao.decode(f.buffer instanceof m?f.slice(b,y):f.subarray(b,y));for(x="";b<y;){var T=f[b++];if(128&T){var C=63&f[b++];if((224&T)==192)x+=String.fromCharCode((31&T)<<6|C);else{var P=63&f[b++];65536>(T=(240&T)==224?(15&T)<<12|C<<6|P:(7&T)<<18|C<<12|P<<6|63&f[b++])?x+=String.fromCharCode(T):(T-=65536,x+=String.fromCharCode(55296|T>>10,56320|1023&T))}}else x+=String.fromCharCode(T)}return x},ue=(f,b)=>(f>>>=0)?So(i(),f,b):"";function Oo(f,b,y){return d?M(3,1,f,b,y):0}function Eo(f,b){if(d)return M(4,1,f,b)}var Po=f=>{for(var b=0,y=0;y<f.length;++y){var x=f.charCodeAt(y);127>=x?b++:2047>=x?b+=2:55296<=x&&57343>=x?(b+=4,++y):b+=3}return b},Do=(f,b,y,x)=>{if(!(0<x))return 0;var T=y>>>=0;x=y+x-1;for(var C=0;C<f.length;++C){var P=f.charCodeAt(C);if(55296<=P&&57343>=P&&(P=65536+((1023&P)<<10)|1023&f.charCodeAt(++C)),127>=P){if(y>=x)break;b[y++>>>0]=P}else{if(2047>=P){if(y+1>=x)break;b[y++>>>0]=192|P>>6}else{if(65535>=P){if(y+2>=x)break;b[y++>>>0]=224|P>>12}else{if(y+3>=x)break;b[y++>>>0]=240|P>>18,b[y++>>>0]=128|P>>12&63}b[y++>>>0]=128|P>>6&63}b[y++>>>0]=128|63&P}}return b[y>>>0]=0,y-T},ce=(f,b,y)=>Do(f,i(),b,y);function $o(f,b){if(d)return M(5,1,f,b)}function ko(f,b,y){if(d)return M(6,1,f,b,y)}function Fo(f,b,y){return d?M(7,1,f,b,y):0}function Bo(f,b){if(d)return M(8,1,f,b)}function Lo(f,b,y){if(d)return M(9,1,f,b,y)}function jo(f,b,y,x){if(d)return M(10,1,f,b,y,x)}function zo(f,b,y,x){if(d)return M(11,1,f,b,y,x)}function Zo(f,b,y,x){if(d)return M(12,1,f,b,y,x)}function Xo(f){if(d)return M(13,1,f)}function Ko(f,b){if(d)return M(14,1,f,b)}function Jo(f,b,y){if(d)return M(15,1,f,b,y)}var Oa=()=>{Dt("")},Ca=()=>1;function Ea(f){Dr(f>>>0,!s,1,!l,131072,!1),vn()}function wr(f){f>>>=0,typeof Atomics.jb=="function"&&(Atomics.jb(o(),f>>>2,f).value.then(Le),f+=128,Atomics.store(o(),f>>>2,1))}var Le=()=>{var f=ae();if(f&&(wr(f),f=ha,!et))try{if(f(),!(0<le))try{d?Ze(vt):gr(vt)}catch(b){b instanceof tr||b=="unwind"||v(1,b)}}catch(b){b instanceof tr||b=="unwind"||v(1,b)}};function Pa(f,b){(f>>>=0)==b>>>0?setTimeout(Le):d?postMessage({targetThread:f,cmd:"checkMailbox"}):(f=Ot[f])&&f.postMessage({cmd:"checkMailbox"})}var vr=[];function Da(f,b,y,x,T){for(b>>>=0,x/=2,vr.length=x,y=T>>>0>>>3,T=0;T<x;T++)vr[T]=gt[y+2*T]?gt[y+2*T+1]:n()[y+2*T+1>>>0];return(b?tn[b]:Ya[f])(...vr)}function $a(f){f>>>=0,d?postMessage({cmd:"cleanupThread",thread:f}):on(Ot[f])}function Na(f){}function ka(f,b){f=-9007199254740992>f||9007199254740992<f?NaN:Number(f),b>>>=0,f=new Date(1e3*f),o()[b>>>2>>>0]=f.getUTCSeconds(),o()[b+4>>>2>>>0]=f.getUTCMinutes(),o()[b+8>>>2>>>0]=f.getUTCHours(),o()[b+12>>>2>>>0]=f.getUTCDate(),o()[b+16>>>2>>>0]=f.getUTCMonth(),o()[b+20>>>2>>>0]=f.getUTCFullYear()-1900,o()[b+24>>>2>>>0]=f.getUTCDay(),f=(f.getTime()-Date.UTC(f.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[b+28>>>2>>>0]=f}var ie=f=>f%4==0&&(f%100!=0||f%400==0),Yo=[0,31,60,91,121,152,182,213,244,274,305,335],Qo=[0,31,59,90,120,151,181,212,243,273,304,334];function Fa(f,b){f=-9007199254740992>f||9007199254740992<f?NaN:Number(f),b>>>=0,f=new Date(1e3*f),o()[b>>>2>>>0]=f.getSeconds(),o()[b+4>>>2>>>0]=f.getMinutes(),o()[b+8>>>2>>>0]=f.getHours(),o()[b+12>>>2>>>0]=f.getDate(),o()[b+16>>>2>>>0]=f.getMonth(),o()[b+20>>>2>>>0]=f.getFullYear()-1900,o()[b+24>>>2>>>0]=f.getDay();var y=(ie(f.getFullYear())?Yo:Qo)[f.getMonth()]+f.getDate()-1|0;o()[b+28>>>2>>>0]=y,o()[b+36>>>2>>>0]=-60*f.getTimezoneOffset(),y=new Date(f.getFullYear(),6,1).getTimezoneOffset();var x=new Date(f.getFullYear(),0,1).getTimezoneOffset();f=0|(y!=x&&f.getTimezoneOffset()==Math.min(x,y)),o()[b+32>>>2>>>0]=f}function Ba(f){f>>>=0;var b=new Date(o()[f+20>>>2>>>0]+1900,o()[f+16>>>2>>>0],o()[f+12>>>2>>>0],o()[f+8>>>2>>>0],o()[f+4>>>2>>>0],o()[f>>>2>>>0],0),y=o()[f+32>>>2>>>0],x=b.getTimezoneOffset(),T=new Date(b.getFullYear(),6,1).getTimezoneOffset(),C=new Date(b.getFullYear(),0,1).getTimezoneOffset(),P=Math.min(C,T);return 0>y?o()[f+32>>>2>>>0]=+(T!=C&&P==x):0<y!=(P==x)&&(T=Math.max(C,T),b.setTime(b.getTime()+6e4*((0<y?P:T)-x))),o()[f+24>>>2>>>0]=b.getDay(),y=(ie(b.getFullYear())?Yo:Qo)[b.getMonth()]+b.getDate()-1|0,o()[f+28>>>2>>>0]=y,o()[f>>>2>>>0]=b.getSeconds(),o()[f+4>>>2>>>0]=b.getMinutes(),o()[f+8>>>2>>>0]=b.getHours(),o()[f+12>>>2>>>0]=b.getDate(),o()[f+16>>>2>>>0]=b.getMonth(),o()[f+20>>>2>>>0]=b.getYear(),f=b.getTime(),BigInt(isNaN(f)?-1:f/1e3)}function ti(f,b,y,x,T,C,P){return d?M(16,1,f,b,y,x,T,C,P):-52}function ri(f,b,y,x,T,C){if(d)return M(17,1,f,b,y,x,T,C)}function Va(f,b,y,x){f>>>=0,b>>>=0,y>>>=0,x>>>=0;var T=new Date().getFullYear(),C=new Date(T,0,1),P=new Date(T,6,1);T=C.getTimezoneOffset();var U=P.getTimezoneOffset(),pt=Math.max(T,U);u()[f>>>2>>>0]=60*pt,o()[b>>>2>>>0]=+(T!=U),C=(f=ct=>ct.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(C),P=f(P),U<T?(ce(C,y,17),ce(P,x,17)):(ce(C,x,17),ce(P,y,17))}var Ir=[];function La(f,b,y){f>>>=0,b>>>=0,y>>>=0,Ir.length=0;for(var x;x=i()[b++>>>0];){var T=x!=105;y+=(T&=x!=112)&&y%8?4:0,Ir.push(x==112?u()[y>>>2>>>0]:x==106?gt[y>>>3]:x==105?o()[y>>>2>>>0]:n()[y>>>3>>>0]),y+=T?8:4}return tn[f](...Ir)}var Ra=()=>{},ja=()=>Date.now();function Ga(f,b){return R(ue(f>>>0,b>>>0))}var ni,Ua=()=>{throw le+=1,"unwind"};function za(){return 4294901760}ni=()=>performance.timeOrigin+performance.now();var Ma=()=>navigator.hardwareConcurrency;function Ha(){return Dt("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Za(f){f>>>=0;var b=i().length;if(f<=b||4294901760<f)return!1;for(var y=1;4>=y;y*=2){var x=b*(1+.2/y);x=Math.min(x,f+100663296);var T=Math;x=Math.max(f,x);t:{T=(T.min.call(T,4294901760,x+(65536-x%65536)%65536)-st.buffer.byteLength+65535)/65536;try{st.grow(T),nt();var C=1;break t}catch{}C=void 0}if(C)return!0}return!1}var Re=()=>(Dt("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),fe={},ii=f=>{f.forEach(b=>{Re()})};function Wa(){var f=Error().stack.toString().split(`
`);return f[0]=="Error"&&f.shift(),ii(f),fe.$a=Re(),fe.bb=f,fe.$a}function Xa(f,b,y){if(f>>>=0,b>>>=0,fe.$a==f)var x=fe.bb;else(x=Error().stack.toString().split(`
`))[0]=="Error"&&x.shift(),ii(x);for(var T=3;x[T]&&Re()!=f;)++T;for(f=0;f<y&&x[f+T];++f)o()[b+4*f>>>2>>>0]=Re();return f}var _r,Er={},ea=()=>{if(!_r){var f,b={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_};for(f in Er)Er[f]===void 0?delete b[f]:b[f]=Er[f];var y=[];for(f in b)y.push(`${f}=${b[f]}`);_r=y}return _r};function ra(f,b){if(d)return M(18,1,f,b);f>>>=0,b>>>=0;var y=0;return ea().forEach((x,T)=>{var C=b+y;for(T=u()[f+4*T>>>2>>>0]=C,C=0;C<x.length;++C)r()[T++>>>0]=x.charCodeAt(C);r()[T>>>0]=0,y+=x.length+1}),0}function na(f,b){if(d)return M(19,1,f,b);f>>>=0,b>>>=0;var y=ea();u()[f>>>2>>>0]=y.length;var x=0;return y.forEach(T=>x+=T.length+1),u()[b>>>2>>>0]=x,0}function oa(f){return d?M(20,1,f):52}function ia(f,b,y,x){return d?M(21,1,f,b,y,x):52}function aa(f,b,y,x){return d?M(22,1,f,b,y,x):70}var Ka=[null,[],[]];function sa(f,b,y,x){if(d)return M(23,1,f,b,y,x);b>>>=0,y>>>=0,x>>>=0;for(var T=0,C=0;C<y;C++){var P=u()[b>>>2>>>0],U=u()[b+4>>>2>>>0];b+=8;for(var pt=0;pt<U;pt++){var ct=i()[P+pt>>>0],ft=Ka[f];ct===0||ct===10?((f===1?Z:R)(So(ft,0)),ft.length=0):ft.push(ct)}T+=U}return u()[x>>>2>>>0]=T,0}var la=[31,29,31,30,31,30,31,31,30,31,30,31],ua=[31,28,31,30,31,30,31,31,30,31,30,31],Ja=(f,b)=>{r().set(f,b>>>0)};function pa(f,b,y,x){function T(A,V,X){for(A=typeof A=="number"?A.toString():A||"";A.length<V;)A=X[0]+A;return A}function C(A,V){return T(A,V,"0")}function P(A,V){function X(ya){return 0>ya?-1:0<ya?1:0}var re;return(re=X(A.getFullYear()-V.getFullYear()))===0&&(re=X(A.getMonth()-V.getMonth()))===0&&(re=X(A.getDate()-V.getDate())),re}function U(A){switch(A.getDay()){case 0:return new Date(A.getFullYear()-1,11,29);case 1:return A;case 2:return new Date(A.getFullYear(),0,3);case 3:return new Date(A.getFullYear(),0,2);case 4:return new Date(A.getFullYear(),0,1);case 5:return new Date(A.getFullYear()-1,11,31);case 6:return new Date(A.getFullYear()-1,11,30)}}function pt(A){var V=A.Sa;for(A=new Date(new Date(A.Ta+1900,0,1).getTime());0<V;){var X=A.getMonth(),re=(ie(A.getFullYear())?la:ua)[X];if(!(V>re-A.getDate())){A.setDate(A.getDate()+V);break}V-=re-A.getDate()+1,A.setDate(1),11>X?A.setMonth(X+1):(A.setMonth(0),A.setFullYear(A.getFullYear()+1))}return X=new Date(A.getFullYear()+1,0,4),V=U(new Date(A.getFullYear(),0,4)),X=U(X),0>=P(V,A)?0>=P(X,A)?A.getFullYear()+1:A.getFullYear():A.getFullYear()-1}f>>>=0,b>>>=0,y>>>=0,x>>>=0;var ct=u()[x+40>>>2>>>0];for(var ft in x={gb:o()[x>>>2>>>0],fb:o()[x+4>>>2>>>0],Va:o()[x+8>>>2>>>0],Ya:o()[x+12>>>2>>>0],Wa:o()[x+16>>>2>>>0],Ta:o()[x+20>>>2>>>0],Qa:o()[x+24>>>2>>>0],Sa:o()[x+28>>>2>>>0],ob:o()[x+32>>>2>>>0],eb:o()[x+36>>>2>>>0],hb:ct?ue(ct):""},y=ue(y),ct={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})y=y.replace(new RegExp(ft,"g"),ct[ft]);var ba="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ma="January February March April May June July August September October November December".split(" ");for(ft in ct={"%a":A=>ba[A.Qa].substring(0,3),"%A":A=>ba[A.Qa],"%b":A=>ma[A.Wa].substring(0,3),"%B":A=>ma[A.Wa],"%C":A=>C((A.Ta+1900)/100|0,2),"%d":A=>C(A.Ya,2),"%e":A=>T(A.Ya,2," "),"%g":A=>pt(A).toString().substring(2),"%G":pt,"%H":A=>C(A.Va,2),"%I":A=>((A=A.Va)==0?A=12:12<A&&(A-=12),C(A,2)),"%j":A=>{for(var V=0,X=0;X<=A.Wa-1;V+=(ie(A.Ta+1900)?la:ua)[X++]);return C(A.Ya+V,3)},"%m":A=>C(A.Wa+1,2),"%M":A=>C(A.fb,2),"%n":()=>`
`,"%p":A=>0<=A.Va&&12>A.Va?"AM":"PM","%S":A=>C(A.gb,2),"%t":()=>"	","%u":A=>A.Qa||7,"%U":A=>C(Math.floor((A.Sa+7-A.Qa)/7),2),"%V":A=>{var V=Math.floor((A.Sa+7-(A.Qa+6)%7)/7);if(2>=(A.Qa+371-A.Sa-2)%7&&V++,V)V==53&&((X=(A.Qa+371-A.Sa)%7)==4||X==3&&ie(A.Ta)||(V=1));else{V=52;var X=(A.Qa+7-A.Sa-1)%7;(X==4||X==5&&ie(A.Ta%400-1))&&V++}return C(V,2)},"%w":A=>A.Qa,"%W":A=>C(Math.floor((A.Sa+7-(A.Qa+6)%7)/7),2),"%y":A=>(A.Ta+1900).toString().substring(2),"%Y":A=>A.Ta+1900,"%z":A=>{var V=0<=(A=A.eb);return A=Math.abs(A)/60,(V?"+":"-")+("0000"+(A/60*100+A%60)).slice(-4)},"%Z":A=>A.hb,"%%":()=>"%"},y=y.replace(/%%/g,"\0\0"),ct)y.includes(ft)&&(y=y.replace(new RegExp(ft,"g"),ct[ft](x)));return ft=(function(A){var V=Array(Po(A)+1);return Do(A,V,0,V.length),V})(y=y.replace(/\0\0/g,"%")),ft.length>b?0:(Ja(ft,f),ft.length-1)}function qa(f,b,y,x){return pa(f>>>0,b>>>0,y>>>0,x>>>0)}d||(function(){for(var f=p.numThreads-1;f--;)_n();Jt.unshift(()=>{te++,(function(b){d?b():Promise.all(Mt.map(In)).then(b)})(()=>_t())})})();var Ya=[ar,rn,Io,Oo,Eo,$o,ko,Fo,Bo,Lo,jo,zo,Zo,Xo,Ko,Jo,ti,ri,ra,na,oa,ia,aa,sa],N=(function(){function f(y,x){return N=y.exports,N=(function(){var T=N,C=U=>()=>U()>>>0,P=U=>pt=>U(pt)>>>0;return(T=Object.assign({},T)).Ba=C(T.Ba),T.Ca=P(T.Ca),T.emscripten_main_runtime_thread_id=C(T.emscripten_main_runtime_thread_id),T.Oa=P(T.Oa),T.Pa=C(T.Pa),T})(),nn.push(N.Ea),On=N.Fa,Lt.unshift(N.$),Pt=x,_t(),N}var b=Qr();if(te++,p.instantiateWasm)try{return p.instantiateWasm(b,f)}catch(y){R(`Module.instantiateWasm callback failed with error: ${y}`),c(y)}return K||=p.locateFile?it("ort-wasm-simd-threaded.wasm")?"ort-wasm-simd-threaded.wasm":p.locateFile?p.locateFile("ort-wasm-simd-threaded.wasm",S):S+"ort-wasm-simd-threaded.wasm":new URL(""+new URL("ort-wasm-simd-threaded-CMx4Stf1.wasm",self.location.href).href,self.location.href).href,(function(y,x){var T=K;return E||typeof WebAssembly.instantiateStreaming!="function"||it(T)||$t(T)||typeof fetch!="function"?Oe(T,y,x):fetch(T,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,y).then(x,function(P){return R(`wasm streaming compile failed: ${P}`),R("falling back to ArrayBuffer instantiation"),Oe(T,y,x)}))})(b,function(y){f(y.instance,y.module)}).catch(c),{}})();p._OrtInit=(f,b)=>(p._OrtInit=N.aa)(f,b),p._OrtGetLastError=(f,b)=>(p._OrtGetLastError=N.ba)(f,b),p._OrtCreateSessionOptions=(f,b,y,x,T,C,P,U,pt,ct)=>(p._OrtCreateSessionOptions=N.ca)(f,b,y,x,T,C,P,U,pt,ct),p._OrtAppendExecutionProvider=(f,b)=>(p._OrtAppendExecutionProvider=N.da)(f,b),p._OrtAddFreeDimensionOverride=(f,b,y)=>(p._OrtAddFreeDimensionOverride=N.ea)(f,b,y),p._OrtAddSessionConfigEntry=(f,b,y)=>(p._OrtAddSessionConfigEntry=N.fa)(f,b,y),p._OrtReleaseSessionOptions=f=>(p._OrtReleaseSessionOptions=N.ga)(f),p._OrtCreateSession=(f,b,y)=>(p._OrtCreateSession=N.ha)(f,b,y),p._OrtReleaseSession=f=>(p._OrtReleaseSession=N.ia)(f),p._OrtGetInputOutputCount=(f,b,y)=>(p._OrtGetInputOutputCount=N.ja)(f,b,y),p._OrtGetInputName=(f,b)=>(p._OrtGetInputName=N.ka)(f,b),p._OrtGetOutputName=(f,b)=>(p._OrtGetOutputName=N.la)(f,b),p._OrtFree=f=>(p._OrtFree=N.ma)(f),p._OrtCreateTensor=(f,b,y,x,T,C)=>(p._OrtCreateTensor=N.na)(f,b,y,x,T,C),p._OrtGetTensorData=(f,b,y,x,T)=>(p._OrtGetTensorData=N.oa)(f,b,y,x,T),p._OrtReleaseTensor=f=>(p._OrtReleaseTensor=N.pa)(f),p._OrtCreateRunOptions=(f,b,y,x)=>(p._OrtCreateRunOptions=N.qa)(f,b,y,x),p._OrtAddRunConfigEntry=(f,b,y)=>(p._OrtAddRunConfigEntry=N.ra)(f,b,y),p._OrtReleaseRunOptions=f=>(p._OrtReleaseRunOptions=N.sa)(f),p._OrtCreateBinding=f=>(p._OrtCreateBinding=N.ta)(f),p._OrtBindInput=(f,b,y)=>(p._OrtBindInput=N.ua)(f,b,y),p._OrtBindOutput=(f,b,y,x)=>(p._OrtBindOutput=N.va)(f,b,y,x),p._OrtClearBoundOutputs=f=>(p._OrtClearBoundOutputs=N.wa)(f),p._OrtReleaseBinding=f=>(p._OrtReleaseBinding=N.xa)(f),p._OrtRunWithBinding=(f,b,y,x,T)=>(p._OrtRunWithBinding=N.ya)(f,b,y,x,T),p._OrtRun=(f,b,y,x,T,C,P,U)=>(p._OrtRun=N.za)(f,b,y,x,T,C,P,U),p._OrtEndProfiling=f=>(p._OrtEndProfiling=N.Aa)(f);var ae=()=>(ae=N.Ba)();p._malloc=f=>(p._malloc=N.Ca)(f),p._free=f=>(p._free=N.Da)(f);var Ge,Dr=(f,b,y,x,T,C)=>(Dr=N.Ga)(f,b,y,x,T,C),ca=()=>(ca=N.Ha)(),da=(f,b,y,x,T)=>(da=N.Ia)(f,b,y,x,T),Lr=f=>(Lr=N.Ja)(f),Ze=f=>(Ze=N.Ka)(f),ha=()=>(ha=N.La)(),fa=(f,b)=>(fa=N.Ma)(f,b),Ye=f=>(Ye=N.Na)(f),Zr=f=>(Zr=N.Oa)(f),Kr=()=>(Kr=N.Pa)();function ga(){0<te||(d?(a(p),d||De(Lt),startWorker(p)):(De(Jt),0<te||Ge||(Ge=!0,p.calledRun=!0,et||(d||De(Lt),a(p),d||De(Ae)))))}return p.___start_em_js=837640,p.___stop_em_js=837701,p.stackSave=()=>Kr(),p.stackRestore=f=>Ye(f),p.stackAlloc=f=>Zr(f),p.UTF8ToString=ue,p.stringToUTF8=ce,p.lengthBytesUTF8=Po,wt=function f(){Ge||ga(),Ge||(wt=f)},ga(),e}),Og=Mp,globalThis.self?.name==="em-pthread"&&Mp()}),br,Sg,Ag,Pg,zp,Wp,Eg,Hp,Vr=O(()=>{oo(),br=self.location.href??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),Sg=typeof location>"u"?void 0:location.origin,Ag=(t,r)=>{try{let i=r??br;return(i?new URL(t,i):new URL(t)).origin===Sg}catch{return!1}},Pg=async t=>{let r=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},zp=(Gp(),sn(Rp)).default,Wp=async()=>{if(!br)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ag(br))return[void 0,zp()];let t=await Pg(br);return[t,zp(t)]},Eg=(Vp(),sn(Up)).default,Hp=async(t,r,i)=>[void 0,Eg]}),Xi,Ki,ho,qp,Dg,Lg,io,xt,Ke=O(()=>{Vr(),Ki=!1,ho=!1,qp=!1,Dg=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lg=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},io=async t=>{if(Ki)return Promise.resolve();if(ho)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(qp)throw new Error("previous call to 'initializeWebAssembly()' failed.");ho=!0;let r=t.initTimeout,i=t.numThreads;if(!Lg())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=Dg();i>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=i=1);let u=t.wasmPaths,n=typeof u=="string"?u:void 0,a=u?.mjs,c=a?.href??a,p=u?.wasm,e=p?.href??p,l=t.wasmBinary,[s,d]=await Hp(c,n,i>1),h=!1,g=[];if(r>0&&g.push(new Promise(m=>{setTimeout(()=>{h=!0,m()},r)})),g.push(new Promise((m,I)=>{let _={numThreads:i};l?_.wasmBinary=l:(e||n)&&(_.locateFile=(v,S)=>e??(n??S)+v),d(_).then(v=>{ho=!1,Ki=!0,Xi=v,m(),s&&URL.revokeObjectURL(s)},v=>{ho=!1,qp=!0,I(v)})})),await Promise.race(g),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},xt=()=>{if(Ki&&Xi)return Xi;throw new Error("WebAssembly is not initialized yet.")}}),Tt,Wr,ht,mo=O(()=>{Ke(),Tt=(t,r)=>{let i=xt(),o=i.lengthBytesUTF8(t)+1,u=i._malloc(o);return i.stringToUTF8(t,u,o),r.push(u),u},Wr=(t,r,i,o)=>{if(typeof t=="object"&&t!==null){if(i.has(t))throw new Error("Circular reference in options");i.add(t)}Object.entries(t).forEach(([u,n])=>{let a=r?r+u:u;if(typeof n=="object")Wr(n,a+".",i,o);else if(typeof n=="string"||typeof n=="number")o(a,n.toString());else if(typeof n=="boolean")o(a,n?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof n}`)})},ht=t=>{let r=xt(),i=r.stackSave();try{let o=r.stackAlloc(8);r._OrtGetLastError(o,o+4);let u=r.HEAP32[o/4],n=r.HEAPU32[o/4+1],a=n?r.UTF8ToString(n):"";throw new Error(`${t} ERROR_CODE: ${u}, ERROR_MESSAGE: ${a}`)}finally{r.stackRestore(i)}}}),jp,Xp=O(()=>{Ke(),mo(),jp=t=>{let r=xt(),i=0,o=[],u=t||{};try{if(t?.logSeverityLevel===void 0)u.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)u.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(u.terminate=!1);let n=0;return t?.tag!==void 0&&(n=Tt(t.tag,o)),i=r._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,n),i===0&&ht("Can't create run options."),t?.extra!==void 0&&Wr(t.extra,"",new WeakSet,(a,c)=>{let p=Tt(a,o),e=Tt(c,o);r._OrtAddRunConfigEntry(i,p,e)!==0&&ht(`Can't set a run config entry: ${a} - ${c}.`)}),[i,o]}catch(n){throw i!==0&&r._OrtReleaseRunOptions(i),o.forEach(a=>r._free(a)),n}}}),$g,kg,Bg,Fg,Kp,Jp=O(()=>{Ke(),mo(),$g=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},kg=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},Bg=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let r=t.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(i=>(typeof i=="string"?i:i.name)==="webgpu")&&(t.enableMemPattern=!1)},Fg=(t,r,i)=>{for(let o of r){let u=typeof o=="string"?o:o.name;switch(u){case"webnn":if(u="WEBNN",typeof o!="string"){let a=o?.deviceType;if(a){let c=Tt("deviceType",i),p=Tt(a,i);xt()._OrtAddSessionConfigEntry(t,c,p)!==0&&ht(`Can't set a session config entry: 'deviceType' - ${a}.`)}}break;case"webgpu":if(u="JS",typeof o!="string"){let a=o;if(a?.preferredLayout){if(a.preferredLayout!=="NCHW"&&a.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${a.preferredLayout}`);let c=Tt("preferredLayout",i),p=Tt(a.preferredLayout,i);xt()._OrtAddSessionConfigEntry(t,c,p)!==0&&ht(`Can't set a session config entry: 'preferredLayout' - ${a.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${u}`)}let n=Tt(u,i);xt()._OrtAppendExecutionProvider(t,n)!==0&&ht(`Can't append execution provider: ${u}.`)}},Kp=t=>{let r=xt(),i=0,o=[],u=t||{};Bg(u);try{let n=$g(u.graphOptimizationLevel??"all"),a=kg(u.executionMode??"sequential"),c=typeof u.logId=="string"?Tt(u.logId,o):0,p=u.logSeverityLevel??2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);let e=u.logVerbosityLevel??0;if(!Number.isInteger(e)||e<0||e>4)throw new Error(`log verbosity level is not valid: ${e}`);let l=typeof u.optimizedModelFilePath=="string"?Tt(u.optimizedModelFilePath,o):0;if(i=r._OrtCreateSessionOptions(n,!!u.enableCpuMemArena,!!u.enableMemPattern,a,!!u.enableProfiling,0,c,p,e,l),i===0&&ht("Can't create session options."),u.executionProviders&&Fg(i,u.executionProviders,o),u.enableGraphCapture!==void 0){if(typeof u.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${u.enableGraphCapture}`);let s=Tt("enableGraphCapture",o),d=Tt(u.enableGraphCapture.toString(),o);r._OrtAddSessionConfigEntry(i,s,d)!==0&&ht(`Can't set a session config entry: 'enableGraphCapture' - ${u.enableGraphCapture}.`)}if(u.freeDimensionOverrides)for(let[s,d]of Object.entries(u.freeDimensionOverrides)){if(typeof s!="string")throw new Error(`free dimension override name must be a string: ${s}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let h=Tt(s,o);r._OrtAddFreeDimensionOverride(i,h,d)!==0&&ht(`Can't set a free dimension override: ${s} - ${d}.`)}return u.extra!==void 0&&Wr(u.extra,"",new WeakSet,(s,d)=>{let h=Tt(s,o),g=Tt(d,o);r._OrtAddSessionConfigEntry(i,h,g)!==0&&ht(`Can't set a session config entry: ${s} - ${d}.`)}),[i,o]}catch(n){throw i!==0&&r._OrtReleaseSessionOptions(i),o.forEach(a=>r._free(a)),n}}}),Hr,Yp,qr,Zp,Qp,bo,go,td,Ji=O(()=>{Hr=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},Yp=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},qr=(t,r)=>{let i=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],o=typeof r=="number"?r:r.reduce((u,n)=>u*n,1);return i>0?Math.ceil(o*i):void 0},Zp=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},Qp=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},bo=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",go=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool",td=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}}),jr,Yi=O(()=>{oo(),jr=async t=>{if(typeof t=="string"){let r=await fetch(t);if(!r.ok)throw new Error(`failed to load external data file: ${t}`);let i=r.headers.get("Content-Length"),o=i?parseInt(i,10):0;if(o<1073741824)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let u=r.body.getReader(),n;try{n=new ArrayBuffer(o)}catch(c){if(c instanceof RangeError){let p=Math.ceil(o/65536);n=new WebAssembly.Memory({initial:p,maximum:p}).buffer}else throw c}let a=0;for(;;){let{done:c,value:p}=await u.read();if(c)break;let e=p.byteLength;new Uint8Array(n,a,e).set(p),a+=e}return new Uint8Array(n,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}}),Cg,ao,so,yr,Ng,zr,uo,lo,ed,fo,co,po,qi=O(()=>{Xp(),Jp(),Ji(),Ke(),mo(),Yi(),Cg=(t,r)=>{xt()._OrtInit(t,r)!==0&&ht("Can't initialize onnxruntime.")},ao=async t=>{Cg(t.wasm.numThreads,Qp(t.logLevel))},so=async(t,r)=>{},yr=new Map,Ng=t=>{let r=xt(),i=r.stackSave();try{let o=r.stackAlloc(8);return r._OrtGetInputOutputCount(t,o,o+4)!==0&&ht("Can't get session input/output count."),[r.HEAP32[o/4],r.HEAP32[o/4+1]]}finally{r.stackRestore(i)}},zr=t=>{let r=xt(),i=r._malloc(t.byteLength);if(i===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return r.HEAPU8.set(t,i),[i,t.byteLength]},uo=async(t,r)=>{let i,o,u=xt();Array.isArray(t)?[i,o]=t:t.buffer===u.HEAPU8.buffer?[i,o]=[t.byteOffset,t.byteLength]:[i,o]=zr(t);let n=0,a=0,c=[],p=[],e=[];try{if([a,c]=Kp(r),r?.externalData&&u.mountExternalData){let _=[];for(let v of r.externalData){let S=typeof v=="string"?v:v.path;_.push(jr(typeof v=="string"?v:v.data).then(E=>{u.mountExternalData(S,E)}))}await Promise.all(_)}for(let _ of r?.executionProviders??[])if((typeof _=="string"?_:_.name)==="webnn"){if(u.shouldTransferToMLTensor=!1,u.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof _!="string"){let v=_,S=v?.context,E=v?.gpuDevice,$=v?.deviceType,Q=v?.numThreads,Z=v?.powerPreference;S?u.currentContext=S:E?u.currentContext=await navigator.ml.createContext(E):u.currentContext=await navigator.ml.createContext({deviceType:$,numThreads:Q,powerPreference:Z})}else u.currentContext=await navigator.ml.createContext();break}n=await u._OrtCreateSession(i,o,a),n===0&&ht("Can't create a session."),u.currentContext&&(u.jsepRegisterMLContext(n,u.currentContext),u.currentContext=void 0,u.shouldTransferToMLTensor=!0);let[l,s]=Ng(n),d=!!r?.enableGraphCapture,h=[],g=[],m=[];for(let _=0;_<l;_++){let v=u._OrtGetInputName(n,_);v===0&&ht("Can't get an input name."),p.push(v),h.push(u.UTF8ToString(v))}for(let _=0;_<s;_++){let v=u._OrtGetOutputName(n,_);v===0&&ht("Can't get an output name."),e.push(v);let S=u.UTF8ToString(v);g.push(S)}return yr.set(n,[n,p,e,null,d,!1]),[n,h,g]}catch(l){throw p.forEach(s=>u._OrtFree(s)),e.forEach(s=>u._OrtFree(s)),n!==0&&u._OrtReleaseSession(n),l}finally{u._free(i),a!==0&&u._OrtReleaseSessionOptions(a),c.forEach(l=>u._free(l)),u.unmountExternalData?.()}},lo=t=>{let r=xt(),i=yr.get(t);if(!i)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,u,n,a,c]=i;a&&(c&&r._OrtClearBoundOutputs(a.handle),r._OrtReleaseBinding(a.handle)),r.jsepOnReleaseSession?.(t),u.forEach(p=>r._OrtFree(p)),n.forEach(p=>r._OrtFree(p)),r._OrtReleaseSession(o),yr.delete(t)},ed=(t,r,i,o,u,n=!1)=>{if(!t){r.push(0);return}let a=xt(),c=t[0],p=t[1],e=t[3],l,s;if(c==="string"&&(e==="gpu-buffer"||e==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(n&&e!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${u} when enableGraphCapture is true.`);if(e==="gpu-buffer"){let g=t[2].gpuBuffer;s=qr(Hr(c),p);let m=a.jsepRegisterBuffer;if(!m)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');l=m(o,u,g,s)}else if(e==="ml-tensor"){let g=t[2].mlTensor;s=qr(Hr(c),p);let m=a.jsepRegisterMLTensor;if(!m)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');l=m(g,Hr(c),p)}else{let g=t[2];if(Array.isArray(g)){s=4*g.length,l=a._malloc(s),i.push(l);let m=l/4;for(let I=0;I<g.length;I++){if(typeof g[I]!="string")throw new TypeError(`tensor data at index ${I} is not a string`);a.HEAPU32[m++]=Tt(g[I],i)}}else s=g.byteLength,l=a._malloc(s),i.push(l),a.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,s),l)}let d=a.stackSave(),h=a.stackAlloc(4*p.length);try{let g=h/4;p.forEach(I=>a.HEAP32[g++]=I);let m=a._OrtCreateTensor(Hr(c),l,s,h,p.length,td(e));m===0&&ht(`Can't create tensor for input/output. session=${o}, index=${u}.`),r.push(m)}finally{a.stackRestore(d)}},fo=async(t,r,i,o,u,n)=>{let a=xt(),c=yr.get(t);if(!c)throw new Error(`cannot run inference. invalid session id: ${t}`);let p=c[0],e=c[1],l=c[2],s=c[3],d=c[4];c[5];let h=r.length,g=o.length,m=0,I=[],_=[],v=[],S=[],E=a.stackSave(),$=a.stackAlloc(h*4),Q=a.stackAlloc(h*4),Z=a.stackAlloc(g*4),R=a.stackAlloc(g*4);try{a.jsepOnRunStart?.(p),[m,I]=jp(n);for(let L=0;L<h;L++)ed(i[L],_,S,t,r[L],d);for(let L=0;L<g;L++)ed(u[L],v,S,t,h+o[L],d);let at=$/4,Nt=Q/4,st=Z/4,Pt=R/4;for(let L=0;L<h;L++)a.HEAPU32[at++]=_[L],a.HEAPU32[Nt++]=e[r[L]];for(let L=0;L<g;L++)a.HEAPU32[st++]=v[L],a.HEAPU32[Pt++]=l[o[L]];let vt;vt=await a._OrtRun(p,Q,$,h,R,g,Z,m),vt!==0&&ht("failed to call OrtRun().");let lt=[];for(let L=0;L<g;L++){let Ft=a.HEAPU32[Z/4+L];if(Ft===v[L]){lt.push(u[L]);continue}let Ie=a.stackSave(),gt=a.stackAlloc(16),oe=!1,et,nt=0;try{a._OrtGetTensorData(Ft,gt,gt+4,gt+8,gt+12)!==0&&ht(`Can't access output tensor data on index ${L}.`);let Jt=gt/4,Lt=a.HEAPU32[Jt++];nt=a.HEAPU32[Jt++];let Ae=a.HEAPU32[Jt++],te=a.HEAPU32[Jt++],wt=[];for(let K=0;K<te;K++)wt.push(a.HEAPU32[Ae/4+K]);a._OrtFree(Ae);let _t=wt.reduce((K,it)=>K*it,1);et=Yp(Lt);let Dt=s?.outputPreferredLocations[o[L]];if(et==="string"){if(Dt==="gpu-buffer"||Dt==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let K=[],it=nt/4;for(let $t=0;$t<_t;$t++){let se=a.HEAPU32[it++],Oe=$t===_t-1?void 0:a.HEAPU32[it]-se;K.push(a.UTF8ToString(se,Oe))}lt.push([et,wt,K,"cpu"])}else if(Dt==="gpu-buffer"&&_t>0){let K=a.jsepGetBuffer;if(!K)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let it=K(nt),$t=qr(Lt,_t);if($t===void 0||!bo(et))throw new Error(`Unsupported data type: ${et}`);oe=!0,lt.push([et,wt,{gpuBuffer:it,download:a.jsepCreateDownloader(it,$t,et),dispose:()=>{a._OrtReleaseTensor(Ft)}},"gpu-buffer"])}else if(Dt==="ml-tensor"&&_t>0){let K=a.jsepEnsureTensor;if(!K)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(qr(Lt,_t)===void 0||!go(et))throw new Error(`Unsupported data type: ${et}`);let it=await K(nt,Lt,wt,!1);oe=!0,lt.push([et,wt,{mlTensor:it,download:a.jsepCreateMLTensorDownloader(nt,et),dispose:()=>{a.jsepReleaseTensorId(nt),a._OrtReleaseTensor(Ft)}},"ml-tensor"])}else{let K=Zp(et),it=new K(_t);new Uint8Array(it.buffer,it.byteOffset,it.byteLength).set(a.HEAPU8.subarray(nt,nt+it.byteLength)),lt.push([et,wt,it,"cpu"])}}finally{a.stackRestore(Ie),et==="string"&&nt&&a._free(nt),oe||a._OrtReleaseTensor(Ft)}}return s&&!d&&(a._OrtClearBoundOutputs(s.handle),yr.set(t,[p,e,l,s,d,!1])),lt}finally{a.stackRestore(E),_.forEach(at=>a._OrtReleaseTensor(at)),v.forEach(at=>a._OrtReleaseTensor(at)),S.forEach(at=>a._free(at)),m!==0&&a._OrtReleaseRunOptions(m),I.forEach(at=>a._free(at))}},co=t=>{let r=xt(),i=yr.get(t);if(!i)throw new Error("invalid session id");let o=i[0],u=r._OrtEndProfiling(o);u===0&&ht("Can't get an profile file name."),r._OrtFree(u)},po=t=>{let r=[];for(let i of t){let o=i[2];!Array.isArray(o)&&"buffer"in o&&r.push(o.buffer)}return r}}),Je,Kt,Xr,xo,To,yo,Zi,Qi,xr,Tr,Gg,rd,nd,od,id,ad,sd,ud,ta=O(()=>{Yt(),qi(),Ke(),Vr(),Je=()=>!!z.wasm.proxy&&typeof document<"u",Xr=!1,xo=!1,To=!1,Qi=new Map,xr=(t,r)=>{let i=Qi.get(t);i?i.push(r):Qi.set(t,[r])},Tr=()=>{if(Xr||!xo||To||!Kt)throw new Error("worker not ready")},Gg=t=>{switch(t.data.type){case"init-wasm":Xr=!1,t.data.err?(To=!0,Zi[1](t.data.err)):(xo=!0,Zi[0]()),yo&&(URL.revokeObjectURL(yo),yo=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=Qi.get(t.data.type);t.data.err?r.shift()[1](t.data.err):r.shift()[0](t.data.out);break}}},rd=async()=>{if(!xo){if(Xr)throw new Error("multiple calls to 'initWasm()' detected.");if(To)throw new Error("previous call to 'initWasm()' failed.");if(Xr=!0,Je())return new Promise((t,r)=>{Kt?.terminate(),Wp().then(([i,o])=>{try{Kt=o,Kt.onerror=n=>r(n),Kt.onmessage=Gg,Zi=[t,r];let u={type:"init-wasm",in:z};Kt.postMessage(u),yo=i}catch(u){r(u)}},r)});try{await io(z.wasm),await ao(z),xo=!0}catch(t){throw To=!0,t}finally{Xr=!1}}},nd=async t=>{if(Je())return Tr(),new Promise((r,i)=>{xr("init-ep",[r,i]);let o={type:"init-ep",in:{epName:t,env:z}};Kt.postMessage(o)});await so(z,t)},od=async t=>Je()?(Tr(),new Promise((r,i)=>{xr("copy-from",[r,i]);let o={type:"copy-from",in:{buffer:t}};Kt.postMessage(o,[t.buffer])})):zr(t),id=async(t,r)=>{if(Je()){if(r?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Tr(),new Promise((i,o)=>{xr("create",[i,o]);let u={type:"create",in:{model:t,options:{...r}}},n=[];t instanceof Uint8Array&&n.push(t.buffer),Kt.postMessage(u,n)})}else return uo(t,r)},ad=async t=>{if(Je())return Tr(),new Promise((r,i)=>{xr("release",[r,i]);let o={type:"release",in:t};Kt.postMessage(o)});lo(t)},sd=async(t,r,i,o,u,n)=>{if(Je()){if(i.some(a=>a[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(u.some(a=>a))throw new Error("pre-allocated output tensor is not supported for proxy.");return Tr(),new Promise((a,c)=>{xr("run",[a,c]);let p=i,e={type:"run",in:{sessionId:t,inputIndices:r,inputs:p,outputIndices:o,options:n}};Kt.postMessage(e,po(p))})}else return fo(t,r,i,o,u,n)},ud=async t=>{if(Je())return Tr(),new Promise((r,i)=>{xr("end-profiling",[r,i]);let o={type:"end-profiling",in:t};Kt.postMessage(o)});co(t)}}),ld,Mg,wo,fd=O(()=>{Yt(),ta(),Ji(),oo(),Yi(),ld=(t,r)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${r()}`)}},Mg=t=>{switch(t[3]){case"cpu":return new yt(t[0],t[2],t[1]);case"gpu-buffer":{let r=t[0];if(!bo(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:i,download:o,dispose:u}=t[2];return yt.fromGpuBuffer(i,{dataType:r,dims:t[1],download:o,dispose:u})}case"ml-tensor":{let r=t[0];if(!go(r))throw new Error(`not supported data type: ${r} for deserializing MLTensor tensor`);let{mlTensor:i,download:o,dispose:u}=t[2];return yt.fromMLTensor(i,{dataType:r,dims:t[1],download:o,dispose:u})}default:throw new Error(`invalid data location: ${t[3]}`)}},wo=class{async fetchModelAndCopyToWasmMemory(t){return od(await jr(t))}async loadModel(t,r){Fe();let i;typeof t=="string"?i=await this.fetchModelAndCopyToWasmMemory(t):i=t,[this.sessionId,this.inputNames,this.outputNames]=await id(i,r),Ce()}async dispose(){return ad(this.sessionId)}async run(t,r,i){Fe();let o=[],u=[];Object.entries(t).forEach(s=>{let d=s[0],h=s[1],g=this.inputNames.indexOf(d);if(g===-1)throw new Error(`invalid input '${d}'`);o.push(h),u.push(g)});let n=[],a=[];Object.entries(r).forEach(s=>{let d=s[0],h=s[1],g=this.outputNames.indexOf(d);if(g===-1)throw new Error(`invalid output '${d}'`);n.push(h),a.push(g)});let c=o.map((s,d)=>ld(s,()=>`input "${this.inputNames[u[d]]}"`)),p=n.map((s,d)=>s?ld(s,()=>`output "${this.outputNames[a[d]]}"`):null),e=await sd(this.sessionId,u,c,a,p,i),l={};for(let s=0;s<e.length;s++)l[this.outputNames[a[s]]]=n[s]??Mg(e[s]);return Ce(),l}startProfiling(){}endProfiling(){ud(this.sessionId)}}}),pd={};Or(pd,{OnnxruntimeWebAssemblyBackend:()=>vo,initializeFlags:()=>cd,wasmBackend:()=>Ug});var cd,vo,Ug,dd=O(()=>{Yt(),ta(),fd(),Vr(),cd=()=>{if((typeof z.wasm.initTimeout!="number"||z.wasm.initTimeout<0)&&(z.wasm.initTimeout=0),z.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof z.wasm.proxy!="boolean"&&(z.wasm.proxy=!1),typeof z.wasm.trace!="boolean"&&(z.wasm.trace=!1),typeof z.wasm.numThreads!="number"||!Number.isInteger(z.wasm.numThreads)||z.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)z.wasm.numThreads=1;else{let t=typeof navigator>"u"?Co("node:os").cpus().length:navigator.hardwareConcurrency;z.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},vo=class{async init(t){cd(),await rd(),await nd(t)}async createInferenceSessionHandler(t,r){let i=new wo;return await i.loadModel(t,r),Promise.resolve(i)}},Ug=new vo});Yt(),Yt(),Yt();var Ds="1.20.0";{let t=(Fp(),sn(Bp)).onnxjsBackend;nr("webgl",t,-10)}{let t=(dd(),sn(pd)).wasmBackend;nr("cpu",t,10),nr("wasm",t,10)}Object.defineProperty(z.versions,"web",{value:Ds,enumerable:!0});/*! Bundled license information:

  long/index.js:
    (**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     *)
  */class FFT{fftSize;reverseTable;sinTable;cosTable;constructor(r){if((r&r-1)!==0)throw new Error("FFT size must be a power of 2.");this.fftSize=r,this.reverseTable=new Uint32Array(r),this.sinTable=new Float32Array(r),this.cosTable=new Float32Array(r);let i=1,o=r>>1;for(;i<r;){for(let u=0;u<i;u++)this.reverseTable[u+i]=this.reverseTable[u]+o;i=i<<1,o=o>>1}for(let u=0;u<r;u++){const n=-2*Math.PI*u/r;this.sinTable[u]=Math.sin(n),this.cosTable[u]=Math.cos(n)}}transform(r){for(let i=0;i<this.fftSize;i++){const o=this.reverseTable[i];i<o&&([r[i*2],r[o*2]]=[r[o*2],r[i*2]],[r[i*2+1],r[o*2+1]]=[r[o*2+1],r[i*2+1]])}for(let i=1;i<this.fftSize;i*=2){const o=2*i,u=this.fftSize/o;for(let n=0;n<this.fftSize;n+=o)for(let a=0;a<i;a++){const c=a*u,p=this.cosTable[c],e=this.sinTable[c],l=(n+a)*2,s=(n+a+i)*2,d=p*r[s]-e*r[s+1],h=p*r[s+1]+e*r[s],g=r[l],m=r[l+1];r[l]=g+d,r[l+1]=m+h,r[s]=g-d,r[s+1]=m-h}}}}class STFT{fftSize;hopSize;fft;window;constructor(r,i){if(r<=0)throw new Error("FFT size must be positive.");if(i<=0)throw new Error("Hop size must be positive.");this.fftSize=r,this.hopSize=i,this.fft=new FFT(r),this.window=this.generateHanningWindow()}generateHanningWindow(){const r=new Float32Array(this.fftSize);for(let i=0;i<this.fftSize;i++)r[i]=.5*(1-Math.cos(2*Math.PI*i/(this.fftSize-1)));return r}analyze(r){const i=[],o=new Float32Array(this.fftSize),u=new Float32Array(this.fftSize*2);for(let n=0;n+this.fftSize<=r.length;n+=this.hopSize){const a=r.subarray(n,n+this.fftSize);o.set(a);for(let c=0;c<this.fftSize;c++)o[c]*=this.window[c];for(let c=0;c<this.fftSize;c++)u[c*2]=o[c],u[c*2+1]=0;this.fft.transform(u),i.push(u.slice())}return i}}const ENGLISH_CONFIG={MODEL_FILE:"model.onnx",VOCABULARY:["[UNK]","/","0","1","2","3","4","5","6","7","8","9","?","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","","","","","","",""," "],ABBREVIATION:{"":"AR","":"BT","":"HH","":"KN","":"SK","":"BK","":"UR"}},JAPANESE_CONFIG={MODEL_FILE:"model_ja.onnx",VOCABULARY:["[UNK]"," ","","0","1","2","3","4","5","6","7","8","9","?","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""," "],ABBREVIATION:{:"",:""}};Object.fromEntries(ENGLISH_CONFIG.VOCABULARY.map((t,r)=>[r,t]));const FFT_LENGTH=256,HOP_LENGTH=64,SAMPLE_RATE=3200;function applyBandpassFilter(t,r,i,o,u=4){const n=i/o,a=2*Math.PI*i/r,c=Math.sin(a),p=Math.cos(a),e=c/(2*n),l=e,s=0,d=-e,h=1+e,g=-2*p,m=1-e,I=l/h,_=s/h,v=d/h,S=g/h,E=m/h;let $=t,Q=new Float32Array(t.length);for(let Z=0;Z<u;Z++){let R=0,at=0,Nt=0,st=0;for(let Pt=0;Pt<$.length;Pt++){const vt=$[Pt],lt=I*vt+_*R+v*at-S*Nt-E*st;Q[Pt]=lt,at=R,R=vt,st=Nt,Nt=lt}$=Q,Z<u-1&&(Q=new Float32Array(t.length))}return Q}function computeMagnitudeSpectrogram(t){return t.map(r=>{const i=new Float32Array(FFT_LENGTH/2+1);for(let o=0;o<i.length;o++){const u=r[o*2],n=r[o*2+1];i[o]=Math.sqrt(u*u+n*n)}return i})}function cropSpectrogram(t){const r=FFT_LENGTH/2+1,i=Math.floor(r/4),o=i,u=r-i;return t.map(n=>n.slice(o,u))}function audioToSpectrogram(t,r,i){let o=t;r!==null&&i>0&&(o=applyBandpassFilter(t,SAMPLE_RATE,r,i));const n=new STFT(FFT_LENGTH,HOP_LENGTH).analyze(o),a=computeMagnitudeSpectrogram(n);return cropSpectrogram(a)}function replaceConsecutiveChars(t){const r=/(\S)\1+/g;return t.replace(r,(i,o)=>o+" ".repeat(i.length-1))}function convertAbbreviationsWithSegments(t,r="en"){const o=Object.entries((r==="ja"?JAPANESE_CONFIG:ENGLISH_CONFIG).ABBREVIATION);if(o.length===0)return[{text:t,isAbbreviation:!1}];const u=o.map(([e])=>e).join("|"),n=new RegExp(`(${u})`,"g"),a=[];let c=0,p;for(;(p=n.exec(t))!==null;){p.index>c&&a.push({text:t.slice(c,p.index),isAbbreviation:!1});const e=p[0],l=o.find(([d])=>d===e),s=l?l[1]:e;a.push({text:s,isAbbreviation:!0}),c=n.lastIndex}return c<t.length&&a.push({text:t.slice(c),isAbbreviation:!1}),a.length>0?a:[{text:t,isAbbreviation:!1}]}function decodePredictions(t,r,i="en"){const[o,u,n]=r,a=[],p=(i==="ja"?JAPANESE_CONFIG:ENGLISH_CONFIG).VOCABULARY;for(let e=0;e<o;e++){const l=[];for(let h=0;h<u;h++){let g=-1/0,m=0;const I=e*u*n+h*n;for(let _=0;_<n;_++)t[I+_]>g&&(g=t[I+_],m=_);l.push(m)}const s=l.map(h=>p[h]||"").join(""),d=convertAbbreviationsWithSegments(replaceConsecutiveChars(s),i);a.push(d)}return a}const MODEL_URLS={en:new URL(Object.assign({"../App.tsx":__vite_glob_1_0,"../Decoder.tsx":__vite_glob_1_1,"../Scope.tsx":__vite_glob_1_2,"../const.ts":__vite_glob_1_3,"../global.css":__vite_glob_1_4,"../main.tsx":__vite_glob_1_5,"../model.onnx":__vite_glob_1_6,"../model_ja.onnx":__vite_glob_1_7,"../onnxruntime-web.d.ts":__vite_glob_1_8,"../stft.ts":__vite_glob_1_9,"../useDecode.ts":__vite_glob_1_10,"../vite-env.d.ts":__vite_glob_1_11})[`../${ENGLISH_CONFIG.MODEL_FILE}`],self.location.href).href,ja:new URL(Object.assign({"../App.tsx":__vite_glob_1_0,"../Decoder.tsx":__vite_glob_1_1,"../Scope.tsx":__vite_glob_1_2,"../const.ts":__vite_glob_1_3,"../global.css":__vite_glob_1_4,"../main.tsx":__vite_glob_1_5,"../model.onnx":__vite_glob_1_6,"../model_ja.onnx":__vite_glob_1_7,"../onnxruntime-web.d.ts":__vite_glob_1_8,"../stft.ts":__vite_glob_1_9,"../useDecode.ts":__vite_glob_1_10,"../vite-env.d.ts":__vite_glob_1_11})[`../${JAPANESE_CONFIG.MODEL_FILE}`],self.location.href).href},sessions={en:null,ja:null};async function ensureSession(t){return sessions[t]||(z.wasm.wasmPaths="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/",sessions[t]=await Yd.create(MODEL_URLS[t],{executionProviders:["wasm"]})),sessions[t]}async function handleRunInference(t,r,i,o){const u=await ensureSession(o),n=audioToSpectrogram(t,r,i),a=n.length;if(a===0)return[];const c=n[0].length,p=new Float32Array(a*c);for(let I=0;I<a;I++)p.set(n[I],I*c);const e=[1,a,c,1],l=new yt("float32",p,e),d={[u.inputNames[0]]:l},g=(await u.run(d))[u.outputNames[0]],m=decodePredictions(g.data,g.dims,o);return m.length>0?m[0]:[]}const ctx=self;ctx.onmessage=async t=>{const r=t.data,i=o=>ctx.postMessage(o);try{if(r.type==="loadModel"){await ensureSession(r.lang),i({id:r.id,type:"modelLoaded"});return}if(r.type==="runInference"){const o=await handleRunInference(r.audioBuffer,r.filterFreq,r.filterWidth,r.lang);i({id:r.id,type:"inferenceResult",segments:o});return}i({id:r.id,type:"error",error:"Unsupported worker message type."})}catch(o){const u=o instanceof Error?o.message:"Unknown worker error";i({id:r.id,type:"error",error:u})}}})();
